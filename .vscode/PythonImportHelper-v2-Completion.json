[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "code",
        "description": "code",
        "detail": "code",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Semaphore",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "ssl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ssl",
        "description": "ssl",
        "detail": "ssl",
        "documentation": {}
    },
    {
        "label": "gzip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gzip",
        "description": "gzip",
        "detail": "gzip",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "six",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "six",
        "description": "six",
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "six.moves.urllib.parse",
        "description": "six.moves.urllib.parse",
        "isExtraImport": true,
        "detail": "six.moves.urllib.parse",
        "documentation": {}
    },
    {
        "label": "websocket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "websocket",
        "description": "websocket",
        "detail": "websocket",
        "documentation": {}
    },
    {
        "label": "networkx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "networkx",
        "description": "networkx",
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "nx",
        "importPath": "networkx",
        "description": "networkx",
        "isExtraImport": true,
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "nx",
        "importPath": "networkx",
        "description": "networkx",
        "isExtraImport": true,
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "nx",
        "importPath": "networkx",
        "description": "networkx",
        "isExtraImport": true,
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "nx",
        "importPath": "networkx",
        "description": "networkx",
        "isExtraImport": true,
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "Graph",
        "importPath": "networkx",
        "description": "networkx",
        "isExtraImport": true,
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "mlab",
        "importPath": "mayavi",
        "description": "mayavi",
        "isExtraImport": true,
        "detail": "mayavi",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy.linalg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.linalg",
        "description": "numpy.linalg",
        "detail": "numpy.linalg",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "cpu_count",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "imap",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "imap",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log10",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log10",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "hierarchy",
        "importPath": "scipy.cluster",
        "description": "scipy.cluster",
        "isExtraImport": true,
        "detail": "scipy.cluster",
        "documentation": {}
    },
    {
        "label": "distance",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "networkx.algorithms.bipartite",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "networkx.algorithms.bipartite",
        "description": "networkx.algorithms.bipartite",
        "detail": "networkx.algorithms.bipartite",
        "documentation": {}
    },
    {
        "label": "moral",
        "importPath": "networkx.algorithms",
        "description": "networkx.algorithms",
        "isExtraImport": true,
        "detail": "networkx.algorithms",
        "documentation": {}
    },
    {
        "label": "junction_tree",
        "importPath": "networkx.algorithms.tree.decomposition",
        "description": "networkx.algorithms.tree.decomposition",
        "isExtraImport": true,
        "detail": "networkx.algorithms.tree.decomposition",
        "documentation": {}
    },
    {
        "label": "graphviz_layout",
        "importPath": "networkx.drawing.nx_agraph",
        "description": "networkx.drawing.nx_agraph",
        "isExtraImport": true,
        "detail": "networkx.drawing.nx_agraph",
        "documentation": {}
    },
    {
        "label": "graphviz_layout",
        "importPath": "networkx.drawing.nx_agraph",
        "description": "networkx.drawing.nx_agraph",
        "isExtraImport": true,
        "detail": "networkx.drawing.nx_agraph",
        "documentation": {}
    },
    {
        "label": "graphviz_layout",
        "importPath": "networkx.drawing.nx_agraph",
        "description": "networkx.drawing.nx_agraph",
        "isExtraImport": true,
        "detail": "networkx.drawing.nx_agraph",
        "documentation": {}
    },
    {
        "label": "graphviz_layout",
        "importPath": "networkx.drawing.nx_agraph",
        "description": "networkx.drawing.nx_agraph",
        "isExtraImport": true,
        "detail": "networkx.drawing.nx_agraph",
        "documentation": {}
    },
    {
        "label": "graphviz_layout",
        "importPath": "networkx.drawing.nx_agraph",
        "description": "networkx.drawing.nx_agraph",
        "isExtraImport": true,
        "detail": "networkx.drawing.nx_agraph",
        "documentation": {}
    },
    {
        "label": "write_dot",
        "importPath": "networkx.drawing.nx_agraph",
        "description": "networkx.drawing.nx_agraph",
        "isExtraImport": true,
        "detail": "networkx.drawing.nx_agraph",
        "documentation": {}
    },
    {
        "label": "reverse_cuthill_mckee_ordering",
        "importPath": "networkx.utils",
        "description": "networkx.utils",
        "isExtraImport": true,
        "detail": "networkx.utils",
        "documentation": {}
    },
    {
        "label": "pairwise",
        "importPath": "networkx.utils",
        "description": "networkx.utils",
        "isExtraImport": true,
        "detail": "networkx.utils",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "graph_could_be_isomorphic",
        "importPath": "networkx.algorithms.isomorphism.isomorph",
        "description": "networkx.algorithms.isomorphism.isomorph",
        "isExtraImport": true,
        "detail": "networkx.algorithms.isomorphism.isomorph",
        "documentation": {}
    },
    {
        "label": "graph_atlas_g",
        "importPath": "networkx.generators.atlas",
        "description": "networkx.generators.atlas",
        "isExtraImport": true,
        "detail": "networkx.generators.atlas",
        "documentation": {}
    },
    {
        "label": "graph_atlas_g",
        "importPath": "networkx.generators.atlas",
        "description": "networkx.generators.atlas",
        "isExtraImport": true,
        "detail": "networkx.generators.atlas",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "cm",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "cm",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "cm",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "compile",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "compile",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "getaddresses",
        "importPath": "email.utils",
        "description": "email.utils",
        "isExtraImport": true,
        "detail": "email.utils",
        "documentation": {}
    },
    {
        "label": "parseaddr",
        "importPath": "email.utils",
        "description": "email.utils",
        "isExtraImport": true,
        "detail": "email.utils",
        "documentation": {}
    },
    {
        "label": "mailbox",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mailbox",
        "description": "mailbox",
        "detail": "mailbox",
        "documentation": {}
    },
    {
        "label": "expected_degree_graph",
        "importPath": "networkx.generators.degree_seq",
        "description": "networkx.generators.degree_seq",
        "isExtraImport": true,
        "detail": "networkx.generators.degree_seq",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "ascii_lowercase",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "flask",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "flask",
        "description": "flask",
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "json_graph",
        "importPath": "networkx.readwrite",
        "description": "networkx.readwrite",
        "isExtraImport": true,
        "detail": "networkx.readwrite",
        "documentation": {}
    },
    {
        "label": "jit_data",
        "importPath": "networkx.readwrite.json_graph",
        "description": "networkx.readwrite.json_graph",
        "isExtraImport": true,
        "detail": "networkx.readwrite.json_graph",
        "documentation": {}
    },
    {
        "label": "jit_graph",
        "importPath": "networkx.readwrite.json_graph",
        "description": "networkx.readwrite.json_graph",
        "isExtraImport": true,
        "detail": "networkx.readwrite.json_graph",
        "documentation": {}
    },
    {
        "label": "NetworkXError",
        "importPath": "networkx.exception",
        "description": "networkx.exception",
        "isExtraImport": true,
        "detail": "networkx.exception",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "torchvision.datasets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision.datasets",
        "description": "torchvision.datasets",
        "detail": "torchvision.datasets",
        "documentation": {}
    },
    {
        "label": "MNIST",
        "importPath": "torchvision.datasets",
        "description": "torchvision.datasets",
        "isExtraImport": true,
        "detail": "torchvision.datasets",
        "documentation": {}
    },
    {
        "label": "torchvision.transforms",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision.transforms",
        "description": "torchvision.transforms",
        "detail": "torchvision.transforms",
        "documentation": {}
    },
    {
        "label": "imageio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imageio",
        "description": "imageio",
        "detail": "imageio",
        "documentation": {}
    },
    {
        "label": "ttools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ttools",
        "description": "ttools",
        "detail": "ttools",
        "documentation": {}
    },
    {
        "label": "rendering",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "rendering",
        "description": "rendering",
        "detail": "rendering",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "pydiffvg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pydiffvg",
        "description": "pydiffvg",
        "detail": "pydiffvg",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "models",
        "description": "models",
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ttools.modules.image_operators",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ttools.modules.image_operators",
        "description": "ttools.modules.image_operators",
        "detail": "ttools.modules.image_operators",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "ttools.interfaces",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ttools.interfaces",
        "description": "ttools.interfaces",
        "detail": "ttools.interfaces",
        "documentation": {}
    },
    {
        "label": "modules",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "modules",
        "description": "modules",
        "detail": "modules",
        "documentation": {}
    },
    {
        "label": "Flatten",
        "importPath": "modules",
        "description": "modules",
        "isExtraImport": true,
        "detail": "modules",
        "documentation": {}
    },
    {
        "label": "torch.multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.multiprocessing",
        "description": "torch.multiprocessing",
        "detail": "torch.multiprocessing",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "wget",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wget",
        "description": "wget",
        "detail": "wget",
        "documentation": {}
    },
    {
        "label": "ttools.modules",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ttools.modules",
        "description": "ttools.modules",
        "detail": "ttools.modules",
        "documentation": {}
    },
    {
        "label": "networks",
        "importPath": "ttools.modules",
        "description": "ttools.modules",
        "isExtraImport": true,
        "detail": "ttools.modules",
        "documentation": {}
    },
    {
        "label": "networks",
        "importPath": "ttools.modules",
        "description": "ttools.modules",
        "isExtraImport": true,
        "detail": "ttools.modules",
        "documentation": {}
    },
    {
        "label": "losses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "losses",
        "description": "losses",
        "detail": "losses",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "data",
        "description": "data",
        "detail": "data",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "view_as_windows",
        "importPath": "skimage.util.shape",
        "description": "skimage.util.shape",
        "isExtraImport": true,
        "detail": "skimage.util.shape",
        "documentation": {}
    },
    {
        "label": "skimage",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "skimage",
        "description": "skimage",
        "detail": "skimage",
        "documentation": {}
    },
    {
        "label": "io",
        "importPath": "skimage",
        "description": "skimage",
        "isExtraImport": true,
        "detail": "skimage",
        "documentation": {}
    },
    {
        "label": "io",
        "importPath": "skimage",
        "description": "skimage",
        "isExtraImport": true,
        "detail": "skimage",
        "documentation": {}
    },
    {
        "label": "clear_output",
        "importPath": "IPython.display",
        "description": "IPython.display",
        "isExtraImport": true,
        "detail": "IPython.display",
        "documentation": {}
    },
    {
        "label": "svgpathtools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "svgpathtools",
        "description": "svgpathtools",
        "detail": "svgpathtools",
        "documentation": {}
    },
    {
        "label": "svg2paths2",
        "importPath": "svgpathtools",
        "description": "svgpathtools",
        "isExtraImport": true,
        "detail": "svgpathtools",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "svgpathtools",
        "description": "svgpathtools",
        "isExtraImport": true,
        "detail": "svgpathtools",
        "documentation": {}
    },
    {
        "label": "is_path_segment",
        "importPath": "svgpathtools",
        "description": "svgpathtools",
        "isExtraImport": true,
        "detail": "svgpathtools",
        "documentation": {}
    },
    {
        "label": "diffvg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "diffvg",
        "description": "diffvg",
        "detail": "diffvg",
        "documentation": {}
    },
    {
        "label": "scipy.ndimage.filters",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.ndimage.filters",
        "description": "scipy.ndimage.filters",
        "detail": "scipy.ndimage.filters",
        "documentation": {}
    },
    {
        "label": "skimage.io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "skimage.io",
        "description": "skimage.io",
        "detail": "skimage.io",
        "documentation": {}
    },
    {
        "label": "structural_similarity",
        "importPath": "skimage.metrics",
        "description": "skimage.metrics",
        "isExtraImport": true,
        "detail": "skimage.metrics",
        "documentation": {}
    },
    {
        "label": "numba",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numba",
        "description": "numba",
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "torchvision",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision",
        "description": "torchvision",
        "detail": "torchvision",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "visdom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "visdom",
        "description": "visdom",
        "detail": "visdom",
        "documentation": {}
    },
    {
        "label": "colorsys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "colorsys",
        "description": "colorsys",
        "detail": "colorsys",
        "documentation": {}
    },
    {
        "label": "pydiffvg_tensorflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pydiffvg_tensorflow",
        "description": "pydiffvg_tensorflow",
        "detail": "pydiffvg_tensorflow",
        "documentation": {}
    },
    {
        "label": "tensorflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow",
        "description": "tensorflow",
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "torch.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.optim",
        "description": "torch.optim",
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "torchvision.models",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision.models",
        "description": "torchvision.models",
        "detail": "torchvision.models",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "GeometryLoss",
        "importPath": "geometry",
        "description": "geometry",
        "isExtraImport": true,
        "detail": "geometry",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "filedialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "OptimizableSvg",
        "importPath": "optimize_svg",
        "description": "optimize_svg",
        "isExtraImport": true,
        "detail": "optimize_svg",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "patchBasedTextureSynthesis",
        "description": "patchBasedTextureSynthesis",
        "isExtraImport": true,
        "detail": "patchBasedTextureSynthesis",
        "documentation": {}
    },
    {
        "label": "make_gif",
        "importPath": "make_gif",
        "description": "make_gif",
        "isExtraImport": true,
        "detail": "make_gif",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "cssutils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cssutils",
        "description": "cssutils",
        "detail": "cssutils",
        "documentation": {}
    },
    {
        "label": "svgpathtools.parser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "svgpathtools.parser",
        "description": "svgpathtools.parser",
        "detail": "svgpathtools.parser",
        "documentation": {}
    },
    {
        "label": "matplotlib.colors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "test_cmake_build",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "test_cmake_build",
        "description": "test_cmake_build",
        "detail": "test_cmake_build",
        "documentation": {}
    },
    {
        "label": "Widget",
        "importPath": "widget_module",
        "description": "widget_module",
        "isExtraImport": true,
        "detail": "widget_module",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "difflib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "difflib",
        "description": "difflib",
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "env",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "env",
        "description": "env",
        "detail": "env",
        "documentation": {}
    },
    {
        "label": "pybind11_tests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "buffers",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "builtin_casters",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "UserType",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "IncType",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "call_policies",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "chrono",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "class_",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "UserType",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "constants_and_functions",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "copy_move_policies",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "custom_type_casters",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "docstring_options",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "enums",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "eval_",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "factory_constructors",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "gil_scoped",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "iostream",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "kwargs_and_defaults",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "local_bindings",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "methods_and_attributes",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "modules",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "multiple_inheritance",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "numpy_array",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "numpy_dtypes",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "numpy_vectorize",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "opaque_types",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "UserType",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "operators",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "pickling",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "pytypes",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "debug_enabled",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "sequences_and_iterators",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "smart_ptr",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "stl",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "UserType",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "stl_binders",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "tagbased_polymorphic",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "union_",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "virtual_functions",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "ConstructorStats",
        "importPath": "pybind11_tests",
        "description": "pybind11_tests",
        "isExtraImport": true,
        "detail": "pybind11_tests",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "pybind11_cross_module_tests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pybind11_cross_module_tests",
        "description": "pybind11_cross_module_tests",
        "detail": "pybind11_cross_module_tests",
        "documentation": {}
    },
    {
        "label": "tag",
        "importPath": "pybind11_tests.factory_constructors",
        "description": "pybind11_tests.factory_constructors",
        "isExtraImport": true,
        "detail": "pybind11_tests.factory_constructors",
        "documentation": {}
    },
    {
        "label": "subsubmodule",
        "importPath": "pybind11_tests.modules",
        "description": "pybind11_tests.modules",
        "isExtraImport": true,
        "detail": "pybind11_tests.modules",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "clang.enumerations",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "clang.enumerations",
        "description": "clang.enumerations",
        "detail": "clang.enumerations",
        "documentation": {}
    },
    {
        "label": "cindex",
        "importPath": "clang",
        "description": "clang",
        "isExtraImport": true,
        "detail": "clang",
        "documentation": {}
    },
    {
        "label": "CursorKind",
        "importPath": "clang.cindex",
        "description": "clang.cindex",
        "isExtraImport": true,
        "detail": "clang.cindex",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "install_headers",
        "importPath": "distutils.command.install_headers",
        "description": "distutils.command.install_headers",
        "isExtraImport": true,
        "detail": "distutils.command.install_headers",
        "documentation": {}
    },
    {
        "label": "build_py",
        "importPath": "distutils.command.build_py",
        "description": "distutils.command.build_py",
        "isExtraImport": true,
        "detail": "distutils.command.build_py",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "pybind11",
        "description": "pybind11",
        "isExtraImport": true,
        "detail": "pybind11",
        "documentation": {}
    },
    {
        "label": "splitext",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "splitext",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "dirname",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "basename",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "realpath",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "DictReader",
        "importPath": "csv",
        "description": "csv",
        "isExtraImport": true,
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "DictWriter",
        "importPath": "csv",
        "description": "csv",
        "isExtraImport": true,
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "DictReader",
        "importPath": "csv",
        "description": "csv",
        "isExtraImport": true,
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "DictWriter",
        "importPath": "csv",
        "description": "csv",
        "isExtraImport": true,
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "DictReader",
        "importPath": "csv",
        "description": "csv",
        "isExtraImport": true,
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "stat",
        "description": "stat",
        "isExtraImport": true,
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "get_paths",
        "importPath": "sysconfig",
        "description": "sysconfig",
        "isExtraImport": true,
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "importPath": "setuptools.command.build_ext",
        "description": "setuptools.command.build_ext",
        "isExtraImport": true,
        "detail": "setuptools.command.build_ext",
        "documentation": {}
    },
    {
        "label": "install",
        "importPath": "setuptools.command.install",
        "description": "setuptools.command.install",
        "isExtraImport": true,
        "detail": "setuptools.command.install",
        "documentation": {}
    },
    {
        "label": "get_config_var",
        "importPath": "distutils.sysconfig",
        "description": "distutils.sysconfig",
        "isExtraImport": true,
        "detail": "distutils.sysconfig",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "distutils.version",
        "description": "distutils.version",
        "isExtraImport": true,
        "detail": "distutils.version",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "VAction",
        "kind": 6,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "class VAction(argparse.Action):\n    def __call__(self, parser, args, values, option_string=None):\n        if values is None:\n            values = \"1\"\n        try:\n            values = int(values)\n        except ValueError:\n            values = values.count(\"v\") + 1\n        setattr(args, self.dest, values)\ndef parse_args():",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "RawInput",
        "kind": 6,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "class RawInput:\n    def raw_input(self, prompt):\n        if six.PY3:\n            line = input(prompt)\n        else:\n            line = raw_input(prompt)\n        if ENCODING and ENCODING != \"utf-8\" and not isinstance(line, six.text_type):\n            line = line.decode(ENCODING).encode(\"utf-8\")\n        elif isinstance(line, six.text_type):\n            line = line.encode(\"utf-8\")",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "InteractiveConsole",
        "kind": 6,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "class InteractiveConsole(RawInput, code.InteractiveConsole):\n    def write(self, data):\n        sys.stdout.write(\"\\033[2K\\033[E\")\n        # sys.stdout.write(\"\\n\")\n        sys.stdout.write(\"\\033[34m< \" + data + \"\\033[39m\")\n        sys.stdout.write(\"\\n> \")\n        sys.stdout.flush()\n    def read(self):\n        return self.raw_input(\"> \")\nclass NonInteractive(RawInput):",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "NonInteractive",
        "kind": 6,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "class NonInteractive(RawInput):\n    def write(self, data):\n        sys.stdout.write(data)\n        sys.stdout.write(\"\\n\")\n        sys.stdout.flush()\n    def read(self):\n        return self.raw_input(\"\")\ndef main():\n    start_time = time.time()\n    args = parse_args()",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "get_encoding",
        "kind": 2,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "def get_encoding():\n    encoding = getattr(sys.stdin, \"encoding\", \"\")\n    if not encoding:\n        return \"utf-8\"\n    else:\n        return encoding.lower()\nOPCODE_DATA = (websocket.ABNF.OPCODE_TEXT, websocket.ABNF.OPCODE_BINARY)\nENCODING = get_encoding()\nclass VAction(argparse.Action):\n    def __call__(self, parser, args, values, option_string=None):",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "def parse_args():\n    parser = argparse.ArgumentParser(description=\"WebSocket Simple Dump Tool\")\n    parser.add_argument(\"url\", metavar=\"ws_url\",\n                        help=\"websocket url. ex. ws://echo.websocket.org/\")\n    parser.add_argument(\"-p\", \"--proxy\",\n                        help=\"proxy url. ex. http://127.0.0.1:8080\")\n    parser.add_argument(\"-v\", \"--verbose\", default=0, nargs='?', action=VAction,\n                        dest=\"verbose\",\n                        help=\"set verbose mode. If set to 1, show opcode. \"\n                        \"If set to 2, enable to trace  websocket module\")",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "def main():\n    start_time = time.time()\n    args = parse_args()\n    if args.verbose > 1:\n        websocket.enableTrace(True)\n    options = {}\n    if args.proxy:\n        p = urlparse(args.proxy)\n        options[\"http_proxy_host\"] = p.hostname\n        options[\"http_proxy_port\"] = p.port",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "OPCODE_DATA",
        "kind": 5,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "OPCODE_DATA = (websocket.ABNF.OPCODE_TEXT, websocket.ABNF.OPCODE_BINARY)\nENCODING = get_encoding()\nclass VAction(argparse.Action):\n    def __call__(self, parser, args, values, option_string=None):\n        if values is None:\n            values = \"1\"\n        try:\n            values = int(values)\n        except ValueError:\n            values = values.count(\"v\") + 1",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "ENCODING",
        "kind": 5,
        "importPath": ".venv.bin.wsdump",
        "description": ".venv.bin.wsdump",
        "peekOfCode": "ENCODING = get_encoding()\nclass VAction(argparse.Action):\n    def __call__(self, parser, args, values, option_string=None):\n        if values is None:\n            values = \"1\"\n        try:\n            values = int(values)\n        except ValueError:\n            values = values.count(\"v\") + 1\n        setattr(args, self.dest, values)",
        "detail": ".venv.bin.wsdump",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "description": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "peekOfCode": "H = nx.cycle_graph(20)\n# reorder nodes from 0,len(G)-1\nG = nx.convert_node_labels_to_integers(H)\n# 3d spring layout\npos = nx.spring_layout(G, dim=3)\n# numpy array of x,y,z positions in sorted node order\nxyz = np.array([pos[v] for v in sorted(G)])\n# scalar colors\nscalars = np.array(list(G.nodes())) + 5\npts = mlab.points3d(",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "description": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "peekOfCode": "G = nx.convert_node_labels_to_integers(H)\n# 3d spring layout\npos = nx.spring_layout(G, dim=3)\n# numpy array of x,y,z positions in sorted node order\nxyz = np.array([pos[v] for v in sorted(G)])\n# scalar colors\nscalars = np.array(list(G.nodes())) + 5\npts = mlab.points3d(\n    xyz[:, 0],\n    xyz[:, 1],",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "description": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "peekOfCode": "pos = nx.spring_layout(G, dim=3)\n# numpy array of x,y,z positions in sorted node order\nxyz = np.array([pos[v] for v in sorted(G)])\n# scalar colors\nscalars = np.array(list(G.nodes())) + 5\npts = mlab.points3d(\n    xyz[:, 0],\n    xyz[:, 1],\n    xyz[:, 2],\n    scalars,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "documentation": {}
    },
    {
        "label": "xyz",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "description": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "peekOfCode": "xyz = np.array([pos[v] for v in sorted(G)])\n# scalar colors\nscalars = np.array(list(G.nodes())) + 5\npts = mlab.points3d(\n    xyz[:, 0],\n    xyz[:, 1],\n    xyz[:, 2],\n    scalars,\n    scale_factor=0.1,\n    scale_mode=\"none\",",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "documentation": {}
    },
    {
        "label": "scalars",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "description": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "peekOfCode": "scalars = np.array(list(G.nodes())) + 5\npts = mlab.points3d(\n    xyz[:, 0],\n    xyz[:, 1],\n    xyz[:, 2],\n    scalars,\n    scale_factor=0.1,\n    scale_mode=\"none\",\n    colormap=\"Blues\",\n    resolution=20,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "documentation": {}
    },
    {
        "label": "pts",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "description": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "peekOfCode": "pts = mlab.points3d(\n    xyz[:, 0],\n    xyz[:, 1],\n    xyz[:, 2],\n    scalars,\n    scale_factor=0.1,\n    scale_mode=\"none\",\n    colormap=\"Blues\",\n    resolution=20,\n)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "documentation": {}
    },
    {
        "label": "pts.mlab_source.dataset.lines",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "description": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "peekOfCode": "pts.mlab_source.dataset.lines = np.array(list(G.edges()))\ntube = mlab.pipeline.tube(pts, tube_radius=0.01)\nmlab.pipeline.surface(tube, color=(0.8, 0.8, 0.8))\nmlab.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "documentation": {}
    },
    {
        "label": "tube",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "description": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "peekOfCode": "tube = mlab.pipeline.tube(pts, tube_radius=0.01)\nmlab.pipeline.surface(tube, color=(0.8, 0.8, 0.8))\nmlab.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.3d_drawing.mayavi2_spring",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "peekOfCode": "n = 1000  # 1000 nodes\nm = 5000  # 5000 edges\nG = nx.gnm_random_graph(n, m)\nL = nx.normalized_laplacian_matrix(G)\ne = numpy.linalg.eigvals(L.A)\nprint(\"Largest eigenvalue:\", max(e))\nprint(\"Smallest eigenvalue:\", min(e))\nplt.hist(e, bins=100)  # histogram with 100 bins\nplt.xlim(0, 2)  # eigenvalues between 0 and 2\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "peekOfCode": "m = 5000  # 5000 edges\nG = nx.gnm_random_graph(n, m)\nL = nx.normalized_laplacian_matrix(G)\ne = numpy.linalg.eigvals(L.A)\nprint(\"Largest eigenvalue:\", max(e))\nprint(\"Smallest eigenvalue:\", min(e))\nplt.hist(e, bins=100)  # histogram with 100 bins\nplt.xlim(0, 2)  # eigenvalues between 0 and 2\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "peekOfCode": "G = nx.gnm_random_graph(n, m)\nL = nx.normalized_laplacian_matrix(G)\ne = numpy.linalg.eigvals(L.A)\nprint(\"Largest eigenvalue:\", max(e))\nprint(\"Smallest eigenvalue:\", min(e))\nplt.hist(e, bins=100)  # histogram with 100 bins\nplt.xlim(0, 2)  # eigenvalues between 0 and 2\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "peekOfCode": "L = nx.normalized_laplacian_matrix(G)\ne = numpy.linalg.eigvals(L.A)\nprint(\"Largest eigenvalue:\", max(e))\nprint(\"Smallest eigenvalue:\", min(e))\nplt.hist(e, bins=100)  # histogram with 100 bins\nplt.xlim(0, 2)  # eigenvalues between 0 and 2\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "documentation": {}
    },
    {
        "label": "e",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "peekOfCode": "e = numpy.linalg.eigvals(L.A)\nprint(\"Largest eigenvalue:\", max(e))\nprint(\"Smallest eigenvalue:\", min(e))\nplt.hist(e, bins=100)  # histogram with 100 bins\nplt.xlim(0, 2)  # eigenvalues between 0 and 2\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_eigenvalues",
        "documentation": {}
    },
    {
        "label": "hd",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "hd = \"H\" + chr(252) + \"sker D\" + chr(252)\nmh = \"Mot\" + chr(246) + \"rhead\"\nmc = \"M\" + chr(246) + \"tley Cr\" + chr(252) + \"e\"\nst = \"Sp\" + chr(305) + \"n\" + chr(776) + \"al Tap\"\nq = \"Queensr\" + chr(255) + \"che\"\nboc = \"Blue \" + chr(214) + \"yster Cult\"\ndt = \"Deatht\" + chr(246) + \"ngue\"\nG = nx.Graph()\nG.add_edge(hd, mh)\nG.add_edge(mc, st)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "mh",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "mh = \"Mot\" + chr(246) + \"rhead\"\nmc = \"M\" + chr(246) + \"tley Cr\" + chr(252) + \"e\"\nst = \"Sp\" + chr(305) + \"n\" + chr(776) + \"al Tap\"\nq = \"Queensr\" + chr(255) + \"che\"\nboc = \"Blue \" + chr(214) + \"yster Cult\"\ndt = \"Deatht\" + chr(246) + \"ngue\"\nG = nx.Graph()\nG.add_edge(hd, mh)\nG.add_edge(mc, st)\nG.add_edge(boc, mc)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "mc",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "mc = \"M\" + chr(246) + \"tley Cr\" + chr(252) + \"e\"\nst = \"Sp\" + chr(305) + \"n\" + chr(776) + \"al Tap\"\nq = \"Queensr\" + chr(255) + \"che\"\nboc = \"Blue \" + chr(214) + \"yster Cult\"\ndt = \"Deatht\" + chr(246) + \"ngue\"\nG = nx.Graph()\nG.add_edge(hd, mh)\nG.add_edge(mc, st)\nG.add_edge(boc, mc)\nG.add_edge(boc, dt)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "st",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "st = \"Sp\" + chr(305) + \"n\" + chr(776) + \"al Tap\"\nq = \"Queensr\" + chr(255) + \"che\"\nboc = \"Blue \" + chr(214) + \"yster Cult\"\ndt = \"Deatht\" + chr(246) + \"ngue\"\nG = nx.Graph()\nG.add_edge(hd, mh)\nG.add_edge(mc, st)\nG.add_edge(boc, mc)\nG.add_edge(boc, dt)\nG.add_edge(st, dt)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "q = \"Queensr\" + chr(255) + \"che\"\nboc = \"Blue \" + chr(214) + \"yster Cult\"\ndt = \"Deatht\" + chr(246) + \"ngue\"\nG = nx.Graph()\nG.add_edge(hd, mh)\nG.add_edge(mc, st)\nG.add_edge(boc, mc)\nG.add_edge(boc, dt)\nG.add_edge(st, dt)\nG.add_edge(q, st)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "boc",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "boc = \"Blue \" + chr(214) + \"yster Cult\"\ndt = \"Deatht\" + chr(246) + \"ngue\"\nG = nx.Graph()\nG.add_edge(hd, mh)\nG.add_edge(mc, st)\nG.add_edge(boc, mc)\nG.add_edge(boc, dt)\nG.add_edge(st, dt)\nG.add_edge(q, st)\nG.add_edge(dt, mh)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "dt",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "dt = \"Deatht\" + chr(246) + \"ngue\"\nG = nx.Graph()\nG.add_edge(hd, mh)\nG.add_edge(mc, st)\nG.add_edge(boc, mc)\nG.add_edge(boc, dt)\nG.add_edge(st, dt)\nG.add_edge(q, st)\nG.add_edge(dt, mh)\nG.add_edge(st, mh)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "G = nx.Graph()\nG.add_edge(hd, mh)\nG.add_edge(mc, st)\nG.add_edge(boc, mc)\nG.add_edge(boc, dt)\nG.add_edge(st, dt)\nG.add_edge(q, st)\nG.add_edge(dt, mh)\nG.add_edge(st, mh)\n# write in UTF-8 encoding",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "fh",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "fh = open(\"edgelist.utf-8\", \"wb\")\nnx.write_multiline_adjlist(G, fh, delimiter=\"\\t\", encoding=\"utf-8\")\n# read and store in UTF-8\nfh = open(\"edgelist.utf-8\", \"rb\")\nH = nx.read_multiline_adjlist(fh, delimiter=\"\\t\", encoding=\"utf-8\")\nfor n in G.nodes():\n    if n not in H:\n        print(False)\nprint(list(G.nodes()))\npos = nx.spring_layout(G)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "fh",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "fh = open(\"edgelist.utf-8\", \"rb\")\nH = nx.read_multiline_adjlist(fh, delimiter=\"\\t\", encoding=\"utf-8\")\nfor n in G.nodes():\n    if n not in H:\n        print(False)\nprint(list(G.nodes()))\npos = nx.spring_layout(G)\nnx.draw(G, pos, font_size=16, with_labels=False)\nfor p in pos:  # raise text positions\n    pos[p][1] += 0.07",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "H = nx.read_multiline_adjlist(fh, delimiter=\"\\t\", encoding=\"utf-8\")\nfor n in G.nodes():\n    if n not in H:\n        print(False)\nprint(list(G.nodes()))\npos = nx.spring_layout(G)\nnx.draw(G, pos, font_size=16, with_labels=False)\nfor p in pos:  # raise text positions\n    pos[p][1] += 0.07\nnx.draw_networkx_labels(G, pos)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "peekOfCode": "pos = nx.spring_layout(G)\nnx.draw(G, pos, font_size=16, with_labels=False)\nfor p in pos:  # raise text positions\n    pos[p][1] += 0.07\nnx.draw_networkx_labels(G, pos)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_heavy_metal_umlaut",
        "documentation": {}
    },
    {
        "label": "digitsrep",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def digitsrep(n, b=10):\n    \"\"\"Return list of digits comprising n represented in base b.\n    n must be a nonnegative integer\"\"\"\n    if n <= 0:\n        return [0]\n    dlist = []\n    while n > 0:\n        # Prepend next least-significant digit\n        dlist = [n % b] + dlist\n        # Floor-division",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "powersum",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def powersum(n, p, b=10):\n    \"\"\"Return sum of digits of n (in base b) raised to the power p.\"\"\"\n    dlist = digitsrep(n, b)\n    sum = 0\n    for k in dlist:\n        sum += k ** p\n    return sum\ndef attractor153_graph(n, p, multiple=3, b=10):\n    \"\"\"Return digraph of iterations of powersum(n,3,10).\"\"\"\n    G = nx.DiGraph()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "attractor153_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def attractor153_graph(n, p, multiple=3, b=10):\n    \"\"\"Return digraph of iterations of powersum(n,3,10).\"\"\"\n    G = nx.DiGraph()\n    for k in range(1, n + 1):\n        if k % multiple == 0 and k not in G:\n            k1 = k\n            knext = powersum(k1, p, b)\n            while k1 != knext:\n                G.add_edge(k1, knext)\n                k1 = knext",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "squaring_cycle_graph_old",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def squaring_cycle_graph_old(n, b=10):\n    \"\"\"Return digraph of iterations of powersum(n,2,10).\"\"\"\n    G = nx.DiGraph()\n    for k in range(1, n + 1):\n        k1 = k\n        G.add_node(k1)  # case k1==knext, at least add node\n        knext = powersum(k1, 2, b)\n        G.add_edge(k1, knext)\n        while k1 != knext:  # stop if fixed point\n            k1 = knext",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "sum_of_digits_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def sum_of_digits_graph(nmax, b=10):\n    def f(n):\n        return powersum(n, 1, b)\n    return discrete_dynamics_digraph(nmax, f)\ndef squaring_cycle_digraph(nmax, b=10):\n    def f(n):\n        return powersum(n, 2, b)\n    return discrete_dynamics_digraph(nmax, f)\ndef cubing_153_digraph(nmax):\n    def f(n):",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "squaring_cycle_digraph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def squaring_cycle_digraph(nmax, b=10):\n    def f(n):\n        return powersum(n, 2, b)\n    return discrete_dynamics_digraph(nmax, f)\ndef cubing_153_digraph(nmax):\n    def f(n):\n        return powersum(n, 3, 10)\n    return discrete_dynamics_digraph(nmax, f)\ndef discrete_dynamics_digraph(nmax, f, itermax=50000):\n    G = nx.DiGraph()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "cubing_153_digraph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def cubing_153_digraph(nmax):\n    def f(n):\n        return powersum(n, 3, 10)\n    return discrete_dynamics_digraph(nmax, f)\ndef discrete_dynamics_digraph(nmax, f, itermax=50000):\n    G = nx.DiGraph()\n    for k in range(1, nmax + 1):\n        kold = k\n        G.add_node(kold)\n        knew = f(kold)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "discrete_dynamics_digraph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def discrete_dynamics_digraph(nmax, f, itermax=50000):\n    G = nx.DiGraph()\n    for k in range(1, nmax + 1):\n        kold = k\n        G.add_node(kold)\n        knew = f(kold)\n        G.add_edge(kold, knew)\n        while kold != knew and kold << itermax:\n            # iterate until fixed point reached or itermax is exceeded\n            kold = knew",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "collatz_problem_digraph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def collatz_problem_digraph(nmax):\n    def f(n):\n        if n % 2 == 0:\n            return n // 2\n        else:\n            return 3 * n + 1\n    return discrete_dynamics_digraph(nmax, f)\ndef fixed_points(G):\n    \"\"\"Return a list of fixed points for the discrete dynamical\n    system represented by the digraph G.",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "fixed_points",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "def fixed_points(G):\n    \"\"\"Return a list of fixed points for the discrete dynamical\n    system represented by the digraph G.\n    \"\"\"\n    return [n for n in G if G.out_degree(n) == 0]\nnmax = 10000\nprint(f\"Building cubing_153_digraph({nmax})\")\nG = cubing_153_digraph(nmax)\nprint(\"Resulting digraph has\", len(G), \"nodes and\", G.size(), \" edges\")\nprint(\"Shortest path from 177 to 153 is:\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "f(108)",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "f(108) = 1**3 + 0**3 + 8**3 = 513\nand\nf(513) = 5**3 + 1**3 + 3**3 = 153\nSo, starting at 108 we reach 153 in two iterations,\nrepresented as:\n108->513->153\nComputing all orbits of 3N up to 10**5 reveals that the attractor\n153 is reached in a maximum of 14 iterations. In this code we\nshow that 13 cycles is the maximum required for all integers (in 3N)\nless than 10,000.",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "f(513)",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "f(513) = 5**3 + 1**3 + 3**3 = 153\nSo, starting at 108 we reach 153 in two iterations,\nrepresented as:\n108->513->153\nComputing all orbits of 3N up to 10**5 reveals that the attractor\n153 is reached in a maximum of 14 iterations. In this code we\nshow that 13 cycles is the maximum required for all integers (in 3N)\nless than 10,000.\nThe smallest number that requires 13 iterations to reach 153, is 177, i.e.,\n177->687->1071->345->216->225->141->66->432->99->1458->702->351->153",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "nmax",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "nmax = 10000\np = 3\ndef digitsrep(n, b=10):\n    \"\"\"Return list of digits comprising n represented in base b.\n    n must be a nonnegative integer\"\"\"\n    if n <= 0:\n        return [0]\n    dlist = []\n    while n > 0:\n        # Prepend next least-significant digit",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "p = 3\ndef digitsrep(n, b=10):\n    \"\"\"Return list of digits comprising n represented in base b.\n    n must be a nonnegative integer\"\"\"\n    if n <= 0:\n        return [0]\n    dlist = []\n    while n > 0:\n        # Prepend next least-significant digit\n        dlist = [n % b] + dlist",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "nmax",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "nmax = 10000\nprint(f\"Building cubing_153_digraph({nmax})\")\nG = cubing_153_digraph(nmax)\nprint(\"Resulting digraph has\", len(G), \"nodes and\", G.size(), \" edges\")\nprint(\"Shortest path from 177 to 153 is:\")\nprint(nx.shortest_path(G, 177, 153))\nprint(f\"fixed points are {fixed_points(G)}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "peekOfCode": "G = cubing_153_digraph(nmax)\nprint(\"Resulting digraph has\", len(G), \"nodes and\", G.size(), \" edges\")\nprint(\"Shortest path from 177 to 153 is:\")\nprint(nx.shortest_path(G, 177, 153))\nprint(f\"fixed points are {fixed_points(G)}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_iterated_dynamical_systems",
        "documentation": {}
    },
    {
        "label": "chunks",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "peekOfCode": "def chunks(l, n):\n    \"\"\"Divide a list of nodes `l` in `n` chunks\"\"\"\n    l_c = iter(l)\n    while 1:\n        x = tuple(itertools.islice(l_c, n))\n        if not x:\n            return\n        yield x\ndef betweenness_centrality_parallel(G, processes=None):\n    \"\"\"Parallel betweenness centrality  function\"\"\"",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "documentation": {}
    },
    {
        "label": "betweenness_centrality_parallel",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "peekOfCode": "def betweenness_centrality_parallel(G, processes=None):\n    \"\"\"Parallel betweenness centrality  function\"\"\"\n    p = Pool(processes=processes)\n    node_divisor = len(p._pool) * 4\n    node_chunks = list(chunks(G.nodes(), int(G.order() / node_divisor)))\n    num_chunks = len(node_chunks)\n    bt_sc = p.starmap(\n        nx.betweenness_centrality_subset,\n        zip(\n            [G] * num_chunks,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "documentation": {}
    },
    {
        "label": "G_ba",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "peekOfCode": "G_ba = nx.barabasi_albert_graph(1000, 3)\nG_er = nx.gnp_random_graph(1000, 0.01)\nG_ws = nx.connected_watts_strogatz_graph(1000, 4, 0.1)\nfor G in [G_ba, G_er, G_ws]:\n    print(\"\")\n    print(\"Computing betweenness centrality for:\")\n    print(nx.info(G))\n    print(\"\\tParallel version\")\n    start = time.time()\n    bt = betweenness_centrality_parallel(G)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "documentation": {}
    },
    {
        "label": "G_er",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "peekOfCode": "G_er = nx.gnp_random_graph(1000, 0.01)\nG_ws = nx.connected_watts_strogatz_graph(1000, 4, 0.1)\nfor G in [G_ba, G_er, G_ws]:\n    print(\"\")\n    print(\"Computing betweenness centrality for:\")\n    print(nx.info(G))\n    print(\"\\tParallel version\")\n    start = time.time()\n    bt = betweenness_centrality_parallel(G)\n    print(f\"\\t\\tTime: {(time.time() - start):.4F} seconds\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "documentation": {}
    },
    {
        "label": "G_ws",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "description": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "peekOfCode": "G_ws = nx.connected_watts_strogatz_graph(1000, 4, 0.1)\nfor G in [G_ba, G_er, G_ws]:\n    print(\"\")\n    print(\"Computing betweenness centrality for:\")\n    print(nx.info(G))\n    print(\"\\tParallel version\")\n    start = time.time()\n    bt = betweenness_centrality_parallel(G)\n    print(f\"\\t\\tTime: {(time.time() - start):.4F} seconds\")\n    print(f\"\\t\\tBetweenness centrality for node 0: {bt[0]:.5f}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.advanced.plot_parallel_betweenness",
        "documentation": {}
    },
    {
        "label": "progressive_widening_search",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "def progressive_widening_search(G, source, value, condition, initial_width=1):\n    \"\"\"Progressive widening beam search to find a node.\n    The progressive widening beam search involves a repeated beam\n    search, starting with a small beam width then extending to\n    progressively larger beam widths if the target node is not\n    found. This implementation simply returns the first node found that\n    matches the termination condition.\n    `G` is a NetworkX graph.\n    `source` is a node in the graph. The search for the node of interest\n    begins here and extends only to those nodes in the (weakly)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "has_high_centrality",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "def has_high_centrality(v):\n    return centrality[v] >= avg_centrality\nsource = 0\nvalue = centrality.get\ncondition = has_high_centrality\nfound_node = progressive_widening_search(G, source, value, condition)\nc = centrality[found_node]\nprint(f\"found node {found_node} with centrality {c}\")\n# Draw graph\npos = nx.spring_layout(G)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "G = nx.gnp_random_graph(100, 0.5)\ncentrality = nx.eigenvector_centrality(G)\navg_centrality = sum(centrality.values()) / len(G)\ndef has_high_centrality(v):\n    return centrality[v] >= avg_centrality\nsource = 0\nvalue = centrality.get\ncondition = has_high_centrality\nfound_node = progressive_widening_search(G, source, value, condition)\nc = centrality[found_node]",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "centrality",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "centrality = nx.eigenvector_centrality(G)\navg_centrality = sum(centrality.values()) / len(G)\ndef has_high_centrality(v):\n    return centrality[v] >= avg_centrality\nsource = 0\nvalue = centrality.get\ncondition = has_high_centrality\nfound_node = progressive_widening_search(G, source, value, condition)\nc = centrality[found_node]\nprint(f\"found node {found_node} with centrality {c}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "avg_centrality",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "avg_centrality = sum(centrality.values()) / len(G)\ndef has_high_centrality(v):\n    return centrality[v] >= avg_centrality\nsource = 0\nvalue = centrality.get\ncondition = has_high_centrality\nfound_node = progressive_widening_search(G, source, value, condition)\nc = centrality[found_node]\nprint(f\"found node {found_node} with centrality {c}\")\n# Draw graph",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "source",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "source = 0\nvalue = centrality.get\ncondition = has_high_centrality\nfound_node = progressive_widening_search(G, source, value, condition)\nc = centrality[found_node]\nprint(f\"found node {found_node} with centrality {c}\")\n# Draw graph\npos = nx.spring_layout(G)\noptions = {\n    \"node_color\": \"blue\",",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "value",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "value = centrality.get\ncondition = has_high_centrality\nfound_node = progressive_widening_search(G, source, value, condition)\nc = centrality[found_node]\nprint(f\"found node {found_node} with centrality {c}\")\n# Draw graph\npos = nx.spring_layout(G)\noptions = {\n    \"node_color\": \"blue\",\n    \"node_size\": 20,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "condition",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "condition = has_high_centrality\nfound_node = progressive_widening_search(G, source, value, condition)\nc = centrality[found_node]\nprint(f\"found node {found_node} with centrality {c}\")\n# Draw graph\npos = nx.spring_layout(G)\noptions = {\n    \"node_color\": \"blue\",\n    \"node_size\": 20,\n    \"edge_color\": \"grey\",",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "found_node",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "found_node = progressive_widening_search(G, source, value, condition)\nc = centrality[found_node]\nprint(f\"found node {found_node} with centrality {c}\")\n# Draw graph\npos = nx.spring_layout(G)\noptions = {\n    \"node_color\": \"blue\",\n    \"node_size\": 20,\n    \"edge_color\": \"grey\",\n    \"linewidths\": 0,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "c = centrality[found_node]\nprint(f\"found node {found_node} with centrality {c}\")\n# Draw graph\npos = nx.spring_layout(G)\noptions = {\n    \"node_color\": \"blue\",\n    \"node_size\": 20,\n    \"edge_color\": \"grey\",\n    \"linewidths\": 0,\n    \"width\": 0.1,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "pos = nx.spring_layout(G)\noptions = {\n    \"node_color\": \"blue\",\n    \"node_size\": 20,\n    \"edge_color\": \"grey\",\n    \"linewidths\": 0,\n    \"width\": 0.1,\n}\nnx.draw(G, pos, **options)\n# Draw node with high centrality as large and red",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "peekOfCode": "options = {\n    \"node_color\": \"blue\",\n    \"node_size\": 20,\n    \"edge_color\": \"grey\",\n    \"linewidths\": 0,\n    \"width\": 0.1,\n}\nnx.draw(G, pos, **options)\n# Draw node with high centrality as large and red\nnx.draw_networkx_nodes(G, pos, nodelist=[found_node], node_size=100, node_color=\"r\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_beam_search",
        "documentation": {}
    },
    {
        "label": "create_hc",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "def create_hc(G):\n    \"\"\"Creates hierarchical cluster of graph G from distance matrix\"\"\"\n    path_length = nx.all_pairs_shortest_path_length(G)\n    distances = numpy.zeros((len(G), len(G)))\n    for u, p in path_length:\n        for v, d in p.items():\n            distances[u][v] = d\n    # Create hierarchical cluster\n    Y = distance.squareform(distances)\n    Z = hierarchy.complete(Y)  # Creates HC using farthest point linkage",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "G = nx.read_edgelist(\"hartford_drug.edgelist\")\n# Extract largest connected component into graph H\nH = G.subgraph(next(nx.connected_components(G)))\n# Makes life easier to have consecutively labeled integer nodes\nH = nx.convert_node_labels_to_integers(H)\n# Create parititions with hierarchical clustering\npartitions = create_hc(H)\n# Build blockmodel graph\nBM = nx.quotient_graph(H, partitions, relabel=True)\n# Draw original graph",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "H = G.subgraph(next(nx.connected_components(G)))\n# Makes life easier to have consecutively labeled integer nodes\nH = nx.convert_node_labels_to_integers(H)\n# Create parititions with hierarchical clustering\npartitions = create_hc(H)\n# Build blockmodel graph\nBM = nx.quotient_graph(H, partitions, relabel=True)\n# Draw original graph\npos = nx.spring_layout(H, iterations=100)\nplt.subplot(211)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "H = nx.convert_node_labels_to_integers(H)\n# Create parititions with hierarchical clustering\npartitions = create_hc(H)\n# Build blockmodel graph\nBM = nx.quotient_graph(H, partitions, relabel=True)\n# Draw original graph\npos = nx.spring_layout(H, iterations=100)\nplt.subplot(211)\nnx.draw(H, pos, with_labels=False, node_size=10)\n# Draw block model with weighted edges and nodes sized by number of internal nodes",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "partitions",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "partitions = create_hc(H)\n# Build blockmodel graph\nBM = nx.quotient_graph(H, partitions, relabel=True)\n# Draw original graph\npos = nx.spring_layout(H, iterations=100)\nplt.subplot(211)\nnx.draw(H, pos, with_labels=False, node_size=10)\n# Draw block model with weighted edges and nodes sized by number of internal nodes\nnode_size = [BM.nodes[x][\"nnodes\"] * 10 for x in BM.nodes()]\nedge_width = [(2 * d[\"weight\"]) for (u, v, d) in BM.edges(data=True)]",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "BM",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "BM = nx.quotient_graph(H, partitions, relabel=True)\n# Draw original graph\npos = nx.spring_layout(H, iterations=100)\nplt.subplot(211)\nnx.draw(H, pos, with_labels=False, node_size=10)\n# Draw block model with weighted edges and nodes sized by number of internal nodes\nnode_size = [BM.nodes[x][\"nnodes\"] * 10 for x in BM.nodes()]\nedge_width = [(2 * d[\"weight\"]) for (u, v, d) in BM.edges(data=True)]\n# Set positions to mean of positions of internal nodes from original graph\nposBM = {}",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "pos = nx.spring_layout(H, iterations=100)\nplt.subplot(211)\nnx.draw(H, pos, with_labels=False, node_size=10)\n# Draw block model with weighted edges and nodes sized by number of internal nodes\nnode_size = [BM.nodes[x][\"nnodes\"] * 10 for x in BM.nodes()]\nedge_width = [(2 * d[\"weight\"]) for (u, v, d) in BM.edges(data=True)]\n# Set positions to mean of positions of internal nodes from original graph\nposBM = {}\nfor n in BM:\n    xy = numpy.array([pos[u] for u in BM.nodes[n][\"graph\"]])",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "node_size",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "node_size = [BM.nodes[x][\"nnodes\"] * 10 for x in BM.nodes()]\nedge_width = [(2 * d[\"weight\"]) for (u, v, d) in BM.edges(data=True)]\n# Set positions to mean of positions of internal nodes from original graph\nposBM = {}\nfor n in BM:\n    xy = numpy.array([pos[u] for u in BM.nodes[n][\"graph\"]])\n    posBM[n] = xy.mean(axis=0)\nplt.subplot(212)\nnx.draw(BM, posBM, node_size=node_size, width=edge_width, with_labels=False)\nplt.axis(\"off\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "edge_width",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "edge_width = [(2 * d[\"weight\"]) for (u, v, d) in BM.edges(data=True)]\n# Set positions to mean of positions of internal nodes from original graph\nposBM = {}\nfor n in BM:\n    xy = numpy.array([pos[u] for u in BM.nodes[n][\"graph\"]])\n    posBM[n] = xy.mean(axis=0)\nplt.subplot(212)\nnx.draw(BM, posBM, node_size=node_size, width=edge_width, with_labels=False)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "posBM",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "peekOfCode": "posBM = {}\nfor n in BM:\n    xy = numpy.array([pos[u] for u in BM.nodes[n][\"graph\"]])\n    posBM[n] = xy.mean(axis=0)\nplt.subplot(212)\nnx.draw(BM, posBM, node_size=node_size, width=edge_width, with_labels=False)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_blockmodel",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "peekOfCode": "G = nx.davis_southern_women_graph()\nwomen = G.graph[\"top\"]\nclubs = G.graph[\"bottom\"]\nprint(\"Biadjacency matrix\")\nprint(bipartite.biadjacency_matrix(G, women, clubs))\n# project bipartite graph onto women nodes\nW = bipartite.projected_graph(G, women)\nprint()\nprint(\"#Friends, Member\")\nfor w in women:",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "documentation": {}
    },
    {
        "label": "women",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "peekOfCode": "women = G.graph[\"top\"]\nclubs = G.graph[\"bottom\"]\nprint(\"Biadjacency matrix\")\nprint(bipartite.biadjacency_matrix(G, women, clubs))\n# project bipartite graph onto women nodes\nW = bipartite.projected_graph(G, women)\nprint()\nprint(\"#Friends, Member\")\nfor w in women:\n    print(f\"{W.degree(w)} {w}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "documentation": {}
    },
    {
        "label": "clubs",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "peekOfCode": "clubs = G.graph[\"bottom\"]\nprint(\"Biadjacency matrix\")\nprint(bipartite.biadjacency_matrix(G, women, clubs))\n# project bipartite graph onto women nodes\nW = bipartite.projected_graph(G, women)\nprint()\nprint(\"#Friends, Member\")\nfor w in women:\n    print(f\"{W.degree(w)} {w}\")\n# project bipartite graph onto women nodes keeping number of co-occurence",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "documentation": {}
    },
    {
        "label": "W",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "peekOfCode": "W = bipartite.projected_graph(G, women)\nprint()\nprint(\"#Friends, Member\")\nfor w in women:\n    print(f\"{W.degree(w)} {w}\")\n# project bipartite graph onto women nodes keeping number of co-occurence\n# the degree computed is weighted and counts the total number of shared contacts\nW = bipartite.weighted_projected_graph(G, women)\nprint()\nprint(\"#Friend meetings, Member\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "documentation": {}
    },
    {
        "label": "W",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "peekOfCode": "W = bipartite.weighted_projected_graph(G, women)\nprint()\nprint(\"#Friend meetings, Member\")\nfor w in women:\n    print(f\"{W.degree(w, weight='weight')} {w}\")\nnx.draw(G)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_davis_club",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "peekOfCode": "B = nx.DiGraph()\nB.add_nodes_from([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"])\nB.add_edges_from(\n    [(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"D\"), (\"B\", \"F\"), (\"C\", \"E\"), (\"E\", \"F\")]\n)\noptions = {\"with_labels\": True, \"node_color\": \"white\", \"edgecolors\": \"blue\"}\nbayes_pos = layout(B, prog=\"neato\")\nax1 = plt.subplot(1, 3, 1)\nplt.title(\"Bayesian Network\")\nnx.draw_networkx(B, pos=bayes_pos, **options)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "peekOfCode": "options = {\"with_labels\": True, \"node_color\": \"white\", \"edgecolors\": \"blue\"}\nbayes_pos = layout(B, prog=\"neato\")\nax1 = plt.subplot(1, 3, 1)\nplt.title(\"Bayesian Network\")\nnx.draw_networkx(B, pos=bayes_pos, **options)\nmg = moral.moral_graph(B)\nplt.subplot(1, 3, 2, sharex=ax1, sharey=ax1)\nplt.title(\"Moralized Graph\")\nnx.draw_networkx(mg, pos=bayes_pos, **options)\njt = junction_tree(B)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "documentation": {}
    },
    {
        "label": "bayes_pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "peekOfCode": "bayes_pos = layout(B, prog=\"neato\")\nax1 = plt.subplot(1, 3, 1)\nplt.title(\"Bayesian Network\")\nnx.draw_networkx(B, pos=bayes_pos, **options)\nmg = moral.moral_graph(B)\nplt.subplot(1, 3, 2, sharex=ax1, sharey=ax1)\nplt.title(\"Moralized Graph\")\nnx.draw_networkx(mg, pos=bayes_pos, **options)\njt = junction_tree(B)\nplt.subplot(1, 3, 3)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "documentation": {}
    },
    {
        "label": "ax1",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "peekOfCode": "ax1 = plt.subplot(1, 3, 1)\nplt.title(\"Bayesian Network\")\nnx.draw_networkx(B, pos=bayes_pos, **options)\nmg = moral.moral_graph(B)\nplt.subplot(1, 3, 2, sharex=ax1, sharey=ax1)\nplt.title(\"Moralized Graph\")\nnx.draw_networkx(mg, pos=bayes_pos, **options)\njt = junction_tree(B)\nplt.subplot(1, 3, 3)\nplt.title(\"Junction Tree\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "documentation": {}
    },
    {
        "label": "mg",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "peekOfCode": "mg = moral.moral_graph(B)\nplt.subplot(1, 3, 2, sharex=ax1, sharey=ax1)\nplt.title(\"Moralized Graph\")\nnx.draw_networkx(mg, pos=bayes_pos, **options)\njt = junction_tree(B)\nplt.subplot(1, 3, 3)\nplt.title(\"Junction Tree\")\nnsize = [2000 * len(n) for n in list(jt.nodes())]\nnx.draw_networkx(jt, pos=layout(jt, prog=\"neato\"), node_size=nsize, **options)\nplt.tight_layout()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "documentation": {}
    },
    {
        "label": "jt",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "peekOfCode": "jt = junction_tree(B)\nplt.subplot(1, 3, 3)\nplt.title(\"Junction Tree\")\nnsize = [2000 * len(n) for n in list(jt.nodes())]\nnx.draw_networkx(jt, pos=layout(jt, prog=\"neato\"), node_size=nsize, **options)\nplt.tight_layout()\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "documentation": {}
    },
    {
        "label": "nsize",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "peekOfCode": "nsize = [2000 * len(n) for n in list(jt.nodes())]\nnx.draw_networkx(jt, pos=layout(jt, prog=\"neato\"), node_size=nsize, **options)\nplt.tight_layout()\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_decomposition",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "peekOfCode": "G = nx.krackhardt_kite_graph()\nprint(\"Betweenness\")\nb = nx.betweenness_centrality(G)\nfor v in G.nodes():\n    print(f\"{v:2} {b[v]:.3f}\")\nprint(\"Degree centrality\")\nd = nx.degree_centrality(G)\nfor v in G.nodes():\n    print(f\"{v:2} {d[v]:.3f}\")\nprint(\"Closeness centrality\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "peekOfCode": "b = nx.betweenness_centrality(G)\nfor v in G.nodes():\n    print(f\"{v:2} {b[v]:.3f}\")\nprint(\"Degree centrality\")\nd = nx.degree_centrality(G)\nfor v in G.nodes():\n    print(f\"{v:2} {d[v]:.3f}\")\nprint(\"Closeness centrality\")\nc = nx.closeness_centrality(G)\nfor v in G.nodes():",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "peekOfCode": "d = nx.degree_centrality(G)\nfor v in G.nodes():\n    print(f\"{v:2} {d[v]:.3f}\")\nprint(\"Closeness centrality\")\nc = nx.closeness_centrality(G)\nfor v in G.nodes():\n    print(f\"{v:2} {c[v]:.3f}\")\nnx.draw(G)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "peekOfCode": "c = nx.closeness_centrality(G)\nfor v in G.nodes():\n    print(f\"{v:2} {c[v]:.3f}\")\nnx.draw(G)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_krackhardt_centrality",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "peekOfCode": "G = nx.grid_2d_graph(3, 3)\nrcm = list(reverse_cuthill_mckee_ordering(G))\nprint(\"ordering\", rcm)\nprint(\"unordered Laplacian matrix\")\nA = nx.laplacian_matrix(G)\nx, y = np.nonzero(A)\n# print(f\"lower bandwidth: {(y - x).max()}\")\n# print(f\"upper bandwidth: {(x - y).max()}\")\nprint(f\"bandwidth: {(y - x).max() + (x - y).max() + 1}\")\nprint(A)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "documentation": {}
    },
    {
        "label": "rcm",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "peekOfCode": "rcm = list(reverse_cuthill_mckee_ordering(G))\nprint(\"ordering\", rcm)\nprint(\"unordered Laplacian matrix\")\nA = nx.laplacian_matrix(G)\nx, y = np.nonzero(A)\n# print(f\"lower bandwidth: {(y - x).max()}\")\n# print(f\"upper bandwidth: {(x - y).max()}\")\nprint(f\"bandwidth: {(y - x).max() + (x - y).max() + 1}\")\nprint(A)\nB = nx.laplacian_matrix(G, nodelist=rcm)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "peekOfCode": "A = nx.laplacian_matrix(G)\nx, y = np.nonzero(A)\n# print(f\"lower bandwidth: {(y - x).max()}\")\n# print(f\"upper bandwidth: {(x - y).max()}\")\nprint(f\"bandwidth: {(y - x).max() + (x - y).max() + 1}\")\nprint(A)\nB = nx.laplacian_matrix(G, nodelist=rcm)\nprint(\"low-bandwidth Laplacian matrix\")\nx, y = np.nonzero(B)\n# print(f\"lower bandwidth: {(y - x).max()}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "description": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "peekOfCode": "B = nx.laplacian_matrix(G, nodelist=rcm)\nprint(\"low-bandwidth Laplacian matrix\")\nx, y = np.nonzero(B)\n# print(f\"lower bandwidth: {(y - x).max()}\")\n# print(f\"upper bandwidth: {(x - y).max()}\")\nprint(f\"bandwidth: {(y - x).max() + (x - y).max() + 1}\")\nprint(B)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.algorithms.plot_rcm",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "description": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "peekOfCode": "G = nx.lollipop_graph(4, 6)\npathlengths = []\nprint(\"source vertex {target:length, }\")\nfor v in G.nodes():\n    spl = dict(nx.single_source_shortest_path_length(G, v))\n    print(f\"{v} {spl} \")\n    for p in spl:\n        pathlengths.append(spl[p])\nprint()\nprint(f\"average shortest path length {sum(pathlengths) / len(pathlengths)}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "documentation": {}
    },
    {
        "label": "pathlengths",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "description": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "peekOfCode": "pathlengths = []\nprint(\"source vertex {target:length, }\")\nfor v in G.nodes():\n    spl = dict(nx.single_source_shortest_path_length(G, v))\n    print(f\"{v} {spl} \")\n    for p in spl:\n        pathlengths.append(spl[p])\nprint()\nprint(f\"average shortest path length {sum(pathlengths) / len(pathlengths)}\")\n# histogram of path lengths",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "documentation": {}
    },
    {
        "label": "dist",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "description": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "peekOfCode": "dist = {}\nfor p in pathlengths:\n    if p in dist:\n        dist[p] += 1\n    else:\n        dist[p] = 1\nprint()\nprint(\"length #paths\")\nverts = dist.keys()\nfor d in sorted(verts):",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "documentation": {}
    },
    {
        "label": "verts",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "description": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "peekOfCode": "verts = dist.keys()\nfor d in sorted(verts):\n    print(f\"{d} {dist[d]}\")\nprint(f\"radius: {nx.radius(G)}\")\nprint(f\"diameter: {nx.diameter(G)}\")\nprint(f\"eccentricity: {nx.eccentricity(G)}\")\nprint(f\"center: {nx.center(G)}\")\nprint(f\"periphery: {nx.periphery(G)}\")\nprint(f\"density: {nx.density(G)}\")\nnx.draw(G, with_labels=True)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_properties",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_read_write",
        "description": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_read_write",
        "peekOfCode": "G = nx.grid_2d_graph(5, 5)  # 5x5 grid\n# print the adjacency list\nfor line in nx.generate_adjlist(G):\n    print(line)\n# write edgelist to grid.edgelist\nnx.write_edgelist(G, path=\"grid.edgelist\", delimiter=\":\")\n# read edgelist from grid.edgelist\nH = nx.read_edgelist(path=\"grid.edgelist\", delimiter=\":\")\nnx.draw(H)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_read_write",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_read_write",
        "description": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_read_write",
        "peekOfCode": "H = nx.read_edgelist(path=\"grid.edgelist\", delimiter=\":\")\nnx.draw(H)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.basic.plot_read_write",
        "documentation": {}
    },
    {
        "label": "atlas6",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "peekOfCode": "def atlas6():\n    \"\"\" Return the atlas of all connected graphs of 6 nodes or less.\n        Attempt to check for isomorphisms and remove.\n    \"\"\"\n    Atlas = graph_atlas_g()[0:208]  # 208\n    # remove isolated nodes, only connected graphs are left\n    U = nx.Graph()  # graph for union of all graphs in atlas\n    for G in Atlas:\n        zerodegree = [n for n in G if G.degree(n) == 0]\n        for n in zerodegree:",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "documentation": {}
    },
    {
        "label": "iso",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "peekOfCode": "def iso(G1, glist):\n    \"\"\"Quick and dirty nonisomorphism checker used to check isomorphisms.\"\"\"\n    for G2 in glist:\n        if isomorphic(G1, G2):\n            return True\n    return False\nG = atlas6()\nprint(f\"graph has {nx.number_of_nodes(G)} nodes with {nx.number_of_edges(G)} edges\")\nprint(nx.number_connected_components(G), \"connected components\")\nplt.figure(1, figsize=(8, 8))",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "peekOfCode": "G = atlas6()\nprint(f\"graph has {nx.number_of_nodes(G)} nodes with {nx.number_of_edges(G)} edges\")\nprint(nx.number_connected_components(G), \"connected components\")\nplt.figure(1, figsize=(8, 8))\n# layout graphs with positions using graphviz neato\npos = graphviz_layout(G, prog=\"neato\")\n# color nodes the same in each connected subgraph\nC = (G.subgraph(c) for c in nx.connected_components(G))\nfor g in C:\n    c = [random.random()] * nx.number_of_nodes(g)  # random color...",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "peekOfCode": "pos = graphviz_layout(G, prog=\"neato\")\n# color nodes the same in each connected subgraph\nC = (G.subgraph(c) for c in nx.connected_components(G))\nfor g in C:\n    c = [random.random()] * nx.number_of_nodes(g)  # random color...\n    nx.draw(g, pos, node_size=40, node_color=c, vmin=0.0, vmax=1.0, with_labels=False)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "peekOfCode": "C = (G.subgraph(c) for c in nx.connected_components(G))\nfor g in C:\n    c = [random.random()] * nx.number_of_nodes(g)  # random color...\n    nx.draw(g, pos, node_size=40, node_color=c, vmin=0.0, vmax=1.0, with_labels=False)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_atlas",
        "documentation": {}
    },
    {
        "label": "chess_pgn_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "def chess_pgn_graph(pgn_file=\"chess_masters_WCC.pgn.bz2\"):\n    \"\"\"Read chess games in pgn format in pgn_file.\n    Filenames ending in .gz or .bz2 will be uncompressed.\n    Return the MultiDiGraph of players connected by a chess game.\n    Edges contain game data in a dict.\n    \"\"\"\n    import bz2\n    G = nx.MultiDiGraph()\n    game = {}\n    datafile = bz2.BZ2File(pgn_file)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "game_details",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "game_details = [\"Event\", \"Date\", \"Result\", \"ECO\", \"Site\"]\ndef chess_pgn_graph(pgn_file=\"chess_masters_WCC.pgn.bz2\"):\n    \"\"\"Read chess games in pgn format in pgn_file.\n    Filenames ending in .gz or .bz2 will be uncompressed.\n    Return the MultiDiGraph of players connected by a chess game.\n    Edges contain game data in a dict.\n    \"\"\"\n    import bz2\n    G = nx.MultiDiGraph()\n    game = {}",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "G = chess_pgn_graph()\nngames = G.number_of_edges()\nnplayers = G.number_of_nodes()\nprint(f\"Loaded {ngames} chess games between {nplayers} players\\n\")\n# identify connected components\n# of the undirected version\nH = G.to_undirected()\nGcc = [H.subgraph(c) for c in nx.connected_components(H)]\nif len(Gcc) > 1:\n    print(\"Note the disconnected component consisting of:\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "ngames",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "ngames = G.number_of_edges()\nnplayers = G.number_of_nodes()\nprint(f\"Loaded {ngames} chess games between {nplayers} players\\n\")\n# identify connected components\n# of the undirected version\nH = G.to_undirected()\nGcc = [H.subgraph(c) for c in nx.connected_components(H)]\nif len(Gcc) > 1:\n    print(\"Note the disconnected component consisting of:\")\n    print(Gcc[1].nodes())",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "nplayers",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "nplayers = G.number_of_nodes()\nprint(f\"Loaded {ngames} chess games between {nplayers} players\\n\")\n# identify connected components\n# of the undirected version\nH = G.to_undirected()\nGcc = [H.subgraph(c) for c in nx.connected_components(H)]\nif len(Gcc) > 1:\n    print(\"Note the disconnected component consisting of:\")\n    print(Gcc[1].nodes())\n# find all games with B97 opening (as described in ECO)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "H = G.to_undirected()\nGcc = [H.subgraph(c) for c in nx.connected_components(H)]\nif len(Gcc) > 1:\n    print(\"Note the disconnected component consisting of:\")\n    print(Gcc[1].nodes())\n# find all games with B97 opening (as described in ECO)\nopenings = {game_info[\"ECO\"] for (white, black, game_info) in G.edges(data=True)}\nprint(f\"\\nFrom a total of {len(openings)} different openings,\")\nprint(\"the following games used the Sicilian opening\")\nprint('with the Najdorff 7...Qb6 \"Poisoned Pawn\" variation.\\n')",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "Gcc",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "Gcc = [H.subgraph(c) for c in nx.connected_components(H)]\nif len(Gcc) > 1:\n    print(\"Note the disconnected component consisting of:\")\n    print(Gcc[1].nodes())\n# find all games with B97 opening (as described in ECO)\nopenings = {game_info[\"ECO\"] for (white, black, game_info) in G.edges(data=True)}\nprint(f\"\\nFrom a total of {len(openings)} different openings,\")\nprint(\"the following games used the Sicilian opening\")\nprint('with the Najdorff 7...Qb6 \"Poisoned Pawn\" variation.\\n')\nfor (white, black, game_info) in G.edges(data=True):",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "openings",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "openings = {game_info[\"ECO\"] for (white, black, game_info) in G.edges(data=True)}\nprint(f\"\\nFrom a total of {len(openings)} different openings,\")\nprint(\"the following games used the Sicilian opening\")\nprint('with the Najdorff 7...Qb6 \"Poisoned Pawn\" variation.\\n')\nfor (white, black, game_info) in G.edges(data=True):\n    if game_info[\"ECO\"] == \"B97\":\n        print(white, \"vs\", black)\n        for k, v in game_info.items():\n            print(\"   \", k, \": \", v)\n        print(\"\\n\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "H = nx.Graph(G)\n# edge width is proportional number of games played\nedgewidth = []\nfor (u, v, d) in H.edges(data=True):\n    edgewidth.append(len(G.get_edge_data(u, v)))\n# node size is proportional to number of games won\nwins = dict.fromkeys(G.nodes(), 0.0)\nfor (u, v, d) in G.edges(data=True):\n    r = d[\"Result\"].split(\"-\")\n    if r[0] == \"1\":",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "edgewidth",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "edgewidth = []\nfor (u, v, d) in H.edges(data=True):\n    edgewidth.append(len(G.get_edge_data(u, v)))\n# node size is proportional to number of games won\nwins = dict.fromkeys(G.nodes(), 0.0)\nfor (u, v, d) in G.edges(data=True):\n    r = d[\"Result\"].split(\"-\")\n    if r[0] == \"1\":\n        wins[u] += 1.0\n    elif r[0] == \"1/2\":",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "wins",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "wins = dict.fromkeys(G.nodes(), 0.0)\nfor (u, v, d) in G.edges(data=True):\n    r = d[\"Result\"].split(\"-\")\n    if r[0] == \"1\":\n        wins[u] += 1.0\n    elif r[0] == \"1/2\":\n        wins[u] += 0.5\n        wins[v] += 0.5\n    else:\n        wins[v] += 1.0",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "plt.rcParams[\"text.usetex\"]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "plt.rcParams[\"text.usetex\"] = False\nplt.figure(figsize=(8, 8))\nnx.draw_networkx_edges(H, pos, alpha=0.3, width=edgewidth, edge_color=\"m\")\nnodesize = [wins[v] * 50 for v in H]\nnx.draw_networkx_nodes(H, pos, node_size=nodesize, node_color=\"w\", alpha=0.4)\nnx.draw_networkx_edges(H, pos, alpha=0.4, node_size=0, width=1, edge_color=\"k\")\nnx.draw_networkx_labels(H, pos, font_size=14)\nfont = {\"fontname\": \"Helvetica\", \"color\": \"k\", \"fontweight\": \"bold\", \"fontsize\": 14}\nplt.title(\"World Chess Championship Games: 1886 - 1985\", font)\n# change font and write text (using data coordinates)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "nodesize",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "nodesize = [wins[v] * 50 for v in H]\nnx.draw_networkx_nodes(H, pos, node_size=nodesize, node_color=\"w\", alpha=0.4)\nnx.draw_networkx_edges(H, pos, alpha=0.4, node_size=0, width=1, edge_color=\"k\")\nnx.draw_networkx_labels(H, pos, font_size=14)\nfont = {\"fontname\": \"Helvetica\", \"color\": \"k\", \"fontweight\": \"bold\", \"fontsize\": 14}\nplt.title(\"World Chess Championship Games: 1886 - 1985\", font)\n# change font and write text (using data coordinates)\nfont = {\"fontname\": \"Helvetica\", \"color\": \"r\", \"fontweight\": \"bold\", \"fontsize\": 14}\nplt.text(\n    0.5,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "font",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "font = {\"fontname\": \"Helvetica\", \"color\": \"k\", \"fontweight\": \"bold\", \"fontsize\": 14}\nplt.title(\"World Chess Championship Games: 1886 - 1985\", font)\n# change font and write text (using data coordinates)\nfont = {\"fontname\": \"Helvetica\", \"color\": \"r\", \"fontweight\": \"bold\", \"fontsize\": 14}\nplt.text(\n    0.5,\n    0.97,\n    \"edge width = # games played\",\n    horizontalalignment=\"center\",\n    transform=plt.gca().transAxes,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "font",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "peekOfCode": "font = {\"fontname\": \"Helvetica\", \"color\": \"r\", \"fontweight\": \"bold\", \"fontsize\": 14}\nplt.text(\n    0.5,\n    0.97,\n    \"edge width = # games played\",\n    horizontalalignment=\"center\",\n    transform=plt.gca().transAxes,\n)\nplt.text(\n    0.5,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_chess_masters",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_circular_tree",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_circular_tree",
        "peekOfCode": "G = nx.balanced_tree(3, 5)\npos = graphviz_layout(G, prog=\"twopi\", args=\"\")\nplt.figure(figsize=(8, 8))\nnx.draw(G, pos, node_size=20, alpha=0.5, node_color=\"blue\", with_labels=False)\nplt.axis(\"equal\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_circular_tree",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_circular_tree",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_circular_tree",
        "peekOfCode": "pos = graphviz_layout(G, prog=\"twopi\", args=\"\")\nplt.figure(figsize=(8, 8))\nnx.draw(G, pos, node_size=20, alpha=0.5, node_color=\"blue\", with_labels=False)\nplt.axis(\"equal\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_circular_tree",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "peekOfCode": "G = nx.gnp_random_graph(100, 0.02)\ndegree_sequence = sorted([d for n, d in G.degree()], reverse=True)  # degree sequence\ndegreeCount = collections.Counter(degree_sequence)\ndeg, cnt = zip(*degreeCount.items())\nfig, ax = plt.subplots()\nplt.bar(deg, cnt, width=0.80, color=\"b\")\nplt.title(\"Degree Histogram\")\nplt.ylabel(\"Count\")\nplt.xlabel(\"Degree\")\nax.set_xticks([d + 0.4 for d in deg])",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "documentation": {}
    },
    {
        "label": "degree_sequence",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "peekOfCode": "degree_sequence = sorted([d for n, d in G.degree()], reverse=True)  # degree sequence\ndegreeCount = collections.Counter(degree_sequence)\ndeg, cnt = zip(*degreeCount.items())\nfig, ax = plt.subplots()\nplt.bar(deg, cnt, width=0.80, color=\"b\")\nplt.title(\"Degree Histogram\")\nplt.ylabel(\"Count\")\nplt.xlabel(\"Degree\")\nax.set_xticks([d + 0.4 for d in deg])\nax.set_xticklabels(deg)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "documentation": {}
    },
    {
        "label": "degreeCount",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "peekOfCode": "degreeCount = collections.Counter(degree_sequence)\ndeg, cnt = zip(*degreeCount.items())\nfig, ax = plt.subplots()\nplt.bar(deg, cnt, width=0.80, color=\"b\")\nplt.title(\"Degree Histogram\")\nplt.ylabel(\"Count\")\nplt.xlabel(\"Degree\")\nax.set_xticks([d + 0.4 for d in deg])\nax.set_xticklabels(deg)\n# draw graph in inset",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "documentation": {}
    },
    {
        "label": "Gcc",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "peekOfCode": "Gcc = G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])\npos = nx.spring_layout(G)\nplt.axis(\"off\")\nnx.draw_networkx_nodes(G, pos, node_size=20)\nnx.draw_networkx_edges(G, pos, alpha=0.4)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "peekOfCode": "pos = nx.spring_layout(G)\nplt.axis(\"off\")\nnx.draw_networkx_nodes(G, pos, node_size=20)\nnx.draw_networkx_edges(G, pos, alpha=0.4)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_histogram",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "peekOfCode": "G = nx.gnp_random_graph(100, 0.02)\ndegree_sequence = sorted([d for n, d in G.degree()], reverse=True)\ndmax = max(degree_sequence)\nplt.loglog(degree_sequence, \"b-\", marker=\"o\")\nplt.title(\"Degree rank plot\")\nplt.ylabel(\"degree\")\nplt.xlabel(\"rank\")\n# draw graph in inset\nplt.axes([0.45, 0.45, 0.45, 0.45])\nGcc = G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "documentation": {}
    },
    {
        "label": "degree_sequence",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "peekOfCode": "degree_sequence = sorted([d for n, d in G.degree()], reverse=True)\ndmax = max(degree_sequence)\nplt.loglog(degree_sequence, \"b-\", marker=\"o\")\nplt.title(\"Degree rank plot\")\nplt.ylabel(\"degree\")\nplt.xlabel(\"rank\")\n# draw graph in inset\nplt.axes([0.45, 0.45, 0.45, 0.45])\nGcc = G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])\npos = nx.spring_layout(Gcc)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "documentation": {}
    },
    {
        "label": "dmax",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "peekOfCode": "dmax = max(degree_sequence)\nplt.loglog(degree_sequence, \"b-\", marker=\"o\")\nplt.title(\"Degree rank plot\")\nplt.ylabel(\"degree\")\nplt.xlabel(\"rank\")\n# draw graph in inset\nplt.axes([0.45, 0.45, 0.45, 0.45])\nGcc = G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])\npos = nx.spring_layout(Gcc)\nplt.axis(\"off\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "documentation": {}
    },
    {
        "label": "Gcc",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "peekOfCode": "Gcc = G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])\npos = nx.spring_layout(Gcc)\nplt.axis(\"off\")\nnx.draw_networkx_nodes(Gcc, pos, node_size=20)\nnx.draw_networkx_edges(Gcc, pos, alpha=0.4)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "peekOfCode": "pos = nx.spring_layout(Gcc)\nplt.axis(\"off\")\nnx.draw_networkx_nodes(Gcc, pos, node_size=20)\nnx.draw_networkx_edges(Gcc, pos, alpha=0.4)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_degree_rank",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "G = nx.generators.directed.random_k_out_graph(10, 3, 0.5)\npos = nx.layout.spring_layout(G)\nnode_sizes = [3 + 10 * i for i in range(len(G))]\nM = G.number_of_edges()\nedge_colors = range(2, M + 2)\nedge_alphas = [(5 + i) / (M + 4) for i in range(M)]\nnodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"blue\")\nedges = nx.draw_networkx_edges(\n    G,\n    pos,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "pos = nx.layout.spring_layout(G)\nnode_sizes = [3 + 10 * i for i in range(len(G))]\nM = G.number_of_edges()\nedge_colors = range(2, M + 2)\nedge_alphas = [(5 + i) / (M + 4) for i in range(M)]\nnodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"blue\")\nedges = nx.draw_networkx_edges(\n    G,\n    pos,\n    node_size=node_sizes,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "node_sizes",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "node_sizes = [3 + 10 * i for i in range(len(G))]\nM = G.number_of_edges()\nedge_colors = range(2, M + 2)\nedge_alphas = [(5 + i) / (M + 4) for i in range(M)]\nnodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"blue\")\nedges = nx.draw_networkx_edges(\n    G,\n    pos,\n    node_size=node_sizes,\n    arrowstyle=\"->\",",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "M = G.number_of_edges()\nedge_colors = range(2, M + 2)\nedge_alphas = [(5 + i) / (M + 4) for i in range(M)]\nnodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"blue\")\nedges = nx.draw_networkx_edges(\n    G,\n    pos,\n    node_size=node_sizes,\n    arrowstyle=\"->\",\n    arrowsize=10,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "edge_colors",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "edge_colors = range(2, M + 2)\nedge_alphas = [(5 + i) / (M + 4) for i in range(M)]\nnodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"blue\")\nedges = nx.draw_networkx_edges(\n    G,\n    pos,\n    node_size=node_sizes,\n    arrowstyle=\"->\",\n    arrowsize=10,\n    edge_color=edge_colors,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "edge_alphas",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "edge_alphas = [(5 + i) / (M + 4) for i in range(M)]\nnodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"blue\")\nedges = nx.draw_networkx_edges(\n    G,\n    pos,\n    node_size=node_sizes,\n    arrowstyle=\"->\",\n    arrowsize=10,\n    edge_color=edge_colors,\n    edge_cmap=plt.cm.Blues,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "nodes",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "nodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"blue\")\nedges = nx.draw_networkx_edges(\n    G,\n    pos,\n    node_size=node_sizes,\n    arrowstyle=\"->\",\n    arrowsize=10,\n    edge_color=edge_colors,\n    edge_cmap=plt.cm.Blues,\n    width=2,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "edges",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "edges = nx.draw_networkx_edges(\n    G,\n    pos,\n    node_size=node_sizes,\n    arrowstyle=\"->\",\n    arrowsize=10,\n    edge_color=edge_colors,\n    edge_cmap=plt.cm.Blues,\n    width=2,\n)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "pc",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "pc = mpl.collections.PatchCollection(edges, cmap=plt.cm.Blues)\npc.set_array(edge_colors)\nplt.colorbar(pc)\nax = plt.gca()\nax.set_axis_off()\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "ax",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "peekOfCode": "ax = plt.gca()\nax.set_axis_off()\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_directed",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "peekOfCode": "G = nx.star_graph(20)\npos = nx.spring_layout(G)\ncolors = range(20)\noptions = {\n    \"node_color\": \"#A0CBE2\",\n    \"edge_color\": colors,\n    \"width\": 4,\n    \"edge_cmap\": plt.cm.Blues,\n    \"with_labels\": False,\n}",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "peekOfCode": "pos = nx.spring_layout(G)\ncolors = range(20)\noptions = {\n    \"node_color\": \"#A0CBE2\",\n    \"edge_color\": colors,\n    \"width\": 4,\n    \"edge_cmap\": plt.cm.Blues,\n    \"with_labels\": False,\n}\nnx.draw(G, pos, **options)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "peekOfCode": "colors = range(20)\noptions = {\n    \"node_color\": \"#A0CBE2\",\n    \"edge_color\": colors,\n    \"width\": 4,\n    \"edge_cmap\": plt.cm.Blues,\n    \"with_labels\": False,\n}\nnx.draw(G, pos, **options)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "peekOfCode": "options = {\n    \"node_color\": \"#A0CBE2\",\n    \"edge_color\": colors,\n    \"width\": 4,\n    \"edge_cmap\": plt.cm.Blues,\n    \"with_labels\": False,\n}\nnx.draw(G, pos, **options)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_edge_colormap",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "peekOfCode": "n = 1000\nm = 2\nG = nx.generators.barabasi_albert_graph(n, m)\n# find node with largest degree\nnode_and_degree = G.degree()\n(largest_hub, degree) = sorted(node_and_degree, key=itemgetter(1))[-1]\n# Create ego graph of main hub\nhub_ego = nx.ego_graph(G, largest_hub)\n# Draw graph\npos = nx.spring_layout(hub_ego)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "peekOfCode": "m = 2\nG = nx.generators.barabasi_albert_graph(n, m)\n# find node with largest degree\nnode_and_degree = G.degree()\n(largest_hub, degree) = sorted(node_and_degree, key=itemgetter(1))[-1]\n# Create ego graph of main hub\nhub_ego = nx.ego_graph(G, largest_hub)\n# Draw graph\npos = nx.spring_layout(hub_ego)\nnx.draw(hub_ego, pos, node_color=\"b\", node_size=50, with_labels=False)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "peekOfCode": "G = nx.generators.barabasi_albert_graph(n, m)\n# find node with largest degree\nnode_and_degree = G.degree()\n(largest_hub, degree) = sorted(node_and_degree, key=itemgetter(1))[-1]\n# Create ego graph of main hub\nhub_ego = nx.ego_graph(G, largest_hub)\n# Draw graph\npos = nx.spring_layout(hub_ego)\nnx.draw(hub_ego, pos, node_color=\"b\", node_size=50, with_labels=False)\n# Draw ego as large and red",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "documentation": {}
    },
    {
        "label": "node_and_degree",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "peekOfCode": "node_and_degree = G.degree()\n(largest_hub, degree) = sorted(node_and_degree, key=itemgetter(1))[-1]\n# Create ego graph of main hub\nhub_ego = nx.ego_graph(G, largest_hub)\n# Draw graph\npos = nx.spring_layout(hub_ego)\nnx.draw(hub_ego, pos, node_color=\"b\", node_size=50, with_labels=False)\n# Draw ego as large and red\noptions = {\"node_size\": 300, \"node_color\": \"r\"}\nnx.draw_networkx_nodes(hub_ego, pos, nodelist=[largest_hub], **options)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "documentation": {}
    },
    {
        "label": "hub_ego",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "peekOfCode": "hub_ego = nx.ego_graph(G, largest_hub)\n# Draw graph\npos = nx.spring_layout(hub_ego)\nnx.draw(hub_ego, pos, node_color=\"b\", node_size=50, with_labels=False)\n# Draw ego as large and red\noptions = {\"node_size\": 300, \"node_color\": \"r\"}\nnx.draw_networkx_nodes(hub_ego, pos, nodelist=[largest_hub], **options)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "peekOfCode": "pos = nx.spring_layout(hub_ego)\nnx.draw(hub_ego, pos, node_color=\"b\", node_size=50, with_labels=False)\n# Draw ego as large and red\noptions = {\"node_size\": 300, \"node_color\": \"r\"}\nnx.draw_networkx_nodes(hub_ego, pos, nodelist=[largest_hub], **options)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "peekOfCode": "options = {\"node_size\": 300, \"node_color\": \"r\"}\nnx.draw_networkx_nodes(hub_ego, pos, nodelist=[largest_hub], **options)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_ego_graph",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "peekOfCode": "G = nx.grid_2d_graph(4, 4)  # 4x4 grid\npos = nx.spring_layout(G, iterations=100)\nplt.subplot(221)\nnx.draw(G, pos, font_size=8)\nplt.subplot(222)\nnx.draw(G, pos, node_color=\"k\", node_size=0, with_labels=False)\nplt.subplot(223)\nnx.draw(G, pos, node_color=\"g\", node_size=250, with_labels=False, width=6)\nplt.subplot(224)\nH = G.to_directed()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "peekOfCode": "pos = nx.spring_layout(G, iterations=100)\nplt.subplot(221)\nnx.draw(G, pos, font_size=8)\nplt.subplot(222)\nnx.draw(G, pos, node_color=\"k\", node_size=0, with_labels=False)\nplt.subplot(223)\nnx.draw(G, pos, node_color=\"g\", node_size=250, with_labels=False, width=6)\nplt.subplot(224)\nH = G.to_directed()\nnx.draw(H, pos, node_color=\"b\", node_size=20, with_labels=False)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "peekOfCode": "H = G.to_directed()\nnx.draw(H, pos, node_color=\"b\", node_size=20, with_labels=False)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_four_grids",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "peekOfCode": "n = 150  # 150 nodes\n# p value at which giant component (of size log(n) nodes) is expected\np_giant = 1.0 / (n - 1)\n# p value at which graph is expected to become completely connected\np_conn = math.log(n) / float(n)\n# the following range of p values should be close to the threshold\npvals = [0.003, 0.006, 0.008, 0.015]\nregion = 220  # for pylab 2x2 subplot layout\nplt.subplots_adjust(left=0, right=1, bottom=0, top=0.95, wspace=0.01, hspace=0.01)\nfor p in pvals:",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "documentation": {}
    },
    {
        "label": "p_giant",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "peekOfCode": "p_giant = 1.0 / (n - 1)\n# p value at which graph is expected to become completely connected\np_conn = math.log(n) / float(n)\n# the following range of p values should be close to the threshold\npvals = [0.003, 0.006, 0.008, 0.015]\nregion = 220  # for pylab 2x2 subplot layout\nplt.subplots_adjust(left=0, right=1, bottom=0, top=0.95, wspace=0.01, hspace=0.01)\nfor p in pvals:\n    G = nx.binomial_graph(n, p)\n    pos = layout(G)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "documentation": {}
    },
    {
        "label": "p_conn",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "peekOfCode": "p_conn = math.log(n) / float(n)\n# the following range of p values should be close to the threshold\npvals = [0.003, 0.006, 0.008, 0.015]\nregion = 220  # for pylab 2x2 subplot layout\nplt.subplots_adjust(left=0, right=1, bottom=0, top=0.95, wspace=0.01, hspace=0.01)\nfor p in pvals:\n    G = nx.binomial_graph(n, p)\n    pos = layout(G)\n    region += 1\n    plt.subplot(region)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "documentation": {}
    },
    {
        "label": "pvals",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "peekOfCode": "pvals = [0.003, 0.006, 0.008, 0.015]\nregion = 220  # for pylab 2x2 subplot layout\nplt.subplots_adjust(left=0, right=1, bottom=0, top=0.95, wspace=0.01, hspace=0.01)\nfor p in pvals:\n    G = nx.binomial_graph(n, p)\n    pos = layout(G)\n    region += 1\n    plt.subplot(region)\n    plt.title(f\"p = {p:.3f}\")\n    nx.draw(G, pos, with_labels=False, node_size=10)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "documentation": {}
    },
    {
        "label": "region",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "peekOfCode": "region = 220  # for pylab 2x2 subplot layout\nplt.subplots_adjust(left=0, right=1, bottom=0, top=0.95, wspace=0.01, hspace=0.01)\nfor p in pvals:\n    G = nx.binomial_graph(n, p)\n    pos = layout(G)\n    region += 1\n    plt.subplot(region)\n    plt.title(f\"p = {p:.3f}\")\n    nx.draw(G, pos, with_labels=False, node_size=10)\n    # identify largest connected component",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_giant_component",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_house_with_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_house_with_colors",
        "peekOfCode": "G = nx.house_graph()\n# explicitly set positions\npos = {0: (0, 0), 1: (1, 0), 2: (0, 1), 3: (1, 1), 4: (0.5, 2.0)}\nnx.draw_networkx_nodes(G, pos, node_size=2000, nodelist=[4])\nnx.draw_networkx_nodes(G, pos, node_size=3000, nodelist=[0, 1, 2, 3], node_color=\"b\")\nnx.draw_networkx_edges(G, pos, alpha=0.5, width=6)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_house_with_colors",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_house_with_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_house_with_colors",
        "peekOfCode": "pos = {0: (0, 0), 1: (1, 0), 2: (0, 1), 3: (1, 1), 4: (0.5, 2.0)}\nnx.draw_networkx_nodes(G, pos, node_size=2000, nodelist=[4])\nnx.draw_networkx_nodes(G, pos, node_size=3000, nodelist=[0, 1, 2, 3], node_color=\"b\")\nnx.draw_networkx_edges(G, pos, alpha=0.5, width=6)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_house_with_colors",
        "documentation": {}
    },
    {
        "label": "miles_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "peekOfCode": "def miles_graph():\n    \"\"\" Return the cites example graph in miles_dat.txt\n        from the Stanford GraphBase.\n    \"\"\"\n    # open file miles_dat.txt.gz (or miles_dat.txt)\n    fh = gzip.open(\"knuth_miles.txt.gz\", \"r\")\n    G = nx.Graph()\n    G.position = {}\n    G.population = {}\n    cities = []",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "peekOfCode": "G = miles_graph()\nprint(\"Loaded miles_dat.txt containing 128 cities.\")\nprint(f\"digraph has {nx.number_of_nodes(G)} nodes with {nx.number_of_edges(G)} edges\")\n# make new graph of cites, edge if less then 300 miles between them\nH = nx.Graph()\nfor v in G:\n    H.add_node(v)\nfor (u, v, d) in G.edges(data=True):\n    if d[\"weight\"] < 300:\n        H.add_edge(u, v)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "documentation": {}
    },
    {
        "label": "H",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "peekOfCode": "H = nx.Graph()\nfor v in G:\n    H.add_node(v)\nfor (u, v, d) in G.edges(data=True):\n    if d[\"weight\"] < 300:\n        H.add_edge(u, v)\n# draw with matplotlib/pylab\nplt.figure(figsize=(8, 8))\n# with nodes colored by degree sized by population\nnode_color = [float(H.degree(v)) for v in H]",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "documentation": {}
    },
    {
        "label": "node_color",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "peekOfCode": "node_color = [float(H.degree(v)) for v in H]\nnx.draw(\n    H,\n    G.position,\n    node_size=[G.population[v] for v in H],\n    node_color=node_color,\n    with_labels=False,\n)\n# scale the axes equally\nplt.xlim(-5000, 500)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_knuth_miles",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "G = nx.cubical_graph()\npos = nx.spring_layout(G)  # positions for all nodes\n# nodes\noptions = {\"node_size\": 500, \"alpha\": 0.8}\nnx.draw_networkx_nodes(G, pos, nodelist=[0, 1, 2, 3], node_color=\"r\", **options)\nnx.draw_networkx_nodes(G, pos, nodelist=[4, 5, 6, 7], node_color=\"b\", **options)\n# edges\nnx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)\nnx.draw_networkx_edges(\n    G,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "pos = nx.spring_layout(G)  # positions for all nodes\n# nodes\noptions = {\"node_size\": 500, \"alpha\": 0.8}\nnx.draw_networkx_nodes(G, pos, nodelist=[0, 1, 2, 3], node_color=\"r\", **options)\nnx.draw_networkx_nodes(G, pos, nodelist=[4, 5, 6, 7], node_color=\"b\", **options)\n# edges\nnx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)\nnx.draw_networkx_edges(\n    G,\n    pos,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "options = {\"node_size\": 500, \"alpha\": 0.8}\nnx.draw_networkx_nodes(G, pos, nodelist=[0, 1, 2, 3], node_color=\"r\", **options)\nnx.draw_networkx_nodes(G, pos, nodelist=[4, 5, 6, 7], node_color=\"b\", **options)\n# edges\nnx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)\nnx.draw_networkx_edges(\n    G,\n    pos,\n    edgelist=[(0, 1), (1, 2), (2, 3), (3, 0)],\n    width=8,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels = {}\nlabels[0] = r\"$a$\"\nlabels[1] = r\"$b$\"\nlabels[2] = r\"$c$\"\nlabels[3] = r\"$d$\"\nlabels[4] = r\"$\\alpha$\"\nlabels[5] = r\"$\\beta$\"\nlabels[6] = r\"$\\gamma$\"\nlabels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels[0]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels[0] = r\"$a$\"\nlabels[1] = r\"$b$\"\nlabels[2] = r\"$c$\"\nlabels[3] = r\"$d$\"\nlabels[4] = r\"$\\alpha$\"\nlabels[5] = r\"$\\beta$\"\nlabels[6] = r\"$\\gamma$\"\nlabels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)\nplt.axis(\"off\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels[1]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels[1] = r\"$b$\"\nlabels[2] = r\"$c$\"\nlabels[3] = r\"$d$\"\nlabels[4] = r\"$\\alpha$\"\nlabels[5] = r\"$\\beta$\"\nlabels[6] = r\"$\\gamma$\"\nlabels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels[2]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels[2] = r\"$c$\"\nlabels[3] = r\"$d$\"\nlabels[4] = r\"$\\alpha$\"\nlabels[5] = r\"$\\beta$\"\nlabels[6] = r\"$\\gamma$\"\nlabels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels[3]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels[3] = r\"$d$\"\nlabels[4] = r\"$\\alpha$\"\nlabels[5] = r\"$\\beta$\"\nlabels[6] = r\"$\\gamma$\"\nlabels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels[4]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels[4] = r\"$\\alpha$\"\nlabels[5] = r\"$\\beta$\"\nlabels[6] = r\"$\\gamma$\"\nlabels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels[5]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels[5] = r\"$\\beta$\"\nlabels[6] = r\"$\\gamma$\"\nlabels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels[6]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels[6] = r\"$\\gamma$\"\nlabels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "labels[7]",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "peekOfCode": "labels[7] = r\"$\\delta$\"\nnx.draw_networkx_labels(G, pos, labels, font_size=16)\nplt.axis(\"off\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_labels_and_colors",
        "documentation": {}
    },
    {
        "label": "lanl_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "peekOfCode": "def lanl_graph():\n    \"\"\" Return the lanl internet view graph from lanl.edges\n    \"\"\"\n    try:\n        fh = open(\"lanl_routes.edgelist\")\n    except OSError:\n        print(\"lanl.edges not found\")\n        raise\n    G = nx.Graph()\n    time = {}",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "peekOfCode": "G = lanl_graph()\nprint(f\"graph has {nx.number_of_nodes(G)} nodes with {nx.number_of_edges(G)} edges\")\nprint(nx.number_connected_components(G), \"connected components\")\nplt.figure(figsize=(8, 8))\n# use graphviz to find radial layout\npos = graphviz_layout(G, prog=\"twopi\", root=0)\n# draw nodes, coloring by rtt ping time\noptions = {\"with_labels\": False, \"alpha\": 0.5, \"node_size\": 15}\nnx.draw(G, pos, node_color=[G.rtt[v] for v in G], **options)\n# adjust the plot limits",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "peekOfCode": "pos = graphviz_layout(G, prog=\"twopi\", root=0)\n# draw nodes, coloring by rtt ping time\noptions = {\"with_labels\": False, \"alpha\": 0.5, \"node_size\": 15}\nnx.draw(G, pos, node_color=[G.rtt[v] for v in G], **options)\n# adjust the plot limits\nxmax = 1.02 * max(xx for xx, yy in pos.values())\nymax = 1.02 * max(yy for xx, yy in pos.values())\nplt.xlim(0, xmax)\nplt.ylim(0, ymax)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "peekOfCode": "options = {\"with_labels\": False, \"alpha\": 0.5, \"node_size\": 15}\nnx.draw(G, pos, node_color=[G.rtt[v] for v in G], **options)\n# adjust the plot limits\nxmax = 1.02 * max(xx for xx, yy in pos.values())\nymax = 1.02 * max(yy for xx, yy in pos.values())\nplt.xlim(0, xmax)\nplt.ylim(0, ymax)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "documentation": {}
    },
    {
        "label": "xmax",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "peekOfCode": "xmax = 1.02 * max(xx for xx, yy in pos.values())\nymax = 1.02 * max(yy for xx, yy in pos.values())\nplt.xlim(0, xmax)\nplt.ylim(0, ymax)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "documentation": {}
    },
    {
        "label": "ymax",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "peekOfCode": "ymax = 1.02 * max(yy for xx, yy in pos.values())\nplt.xlim(0, xmax)\nplt.ylim(0, ymax)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_lanl_routes",
        "documentation": {}
    },
    {
        "label": "multilayered_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "peekOfCode": "def multilayered_graph(*subset_sizes):\n    extents = pairwise(itertools.accumulate((0,) + subset_sizes))\n    layers = [range(start, end) for start, end in extents]\n    G = nx.Graph()\n    for (i, layer) in enumerate(layers):\n        G.add_nodes_from(layer, layer=i)\n    for layer1, layer2 in pairwise(layers):\n        G.add_edges_from(itertools.product(layer1, layer2))\n    return G\nG = multilayered_graph(*subset_sizes)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "documentation": {}
    },
    {
        "label": "subset_sizes",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "peekOfCode": "subset_sizes = [5, 5, 4, 3, 2, 4, 4, 3]\nsubset_color = [\n    \"gold\",\n    \"violet\",\n    \"violet\",\n    \"violet\",\n    \"violet\",\n    \"limegreen\",\n    \"limegreen\",\n    \"darkorange\",",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "documentation": {}
    },
    {
        "label": "subset_color",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "peekOfCode": "subset_color = [\n    \"gold\",\n    \"violet\",\n    \"violet\",\n    \"violet\",\n    \"violet\",\n    \"limegreen\",\n    \"limegreen\",\n    \"darkorange\",\n]",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "peekOfCode": "G = multilayered_graph(*subset_sizes)\ncolor = [subset_color[data[\"layer\"]] for v, data in G.nodes(data=True)]\npos = nx.multipartite_layout(G, subset_key=\"layer\")\nplt.figure(figsize=(8, 8))\nnx.draw(G, pos, node_color=color, with_labels=False)\nplt.axis(\"equal\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "peekOfCode": "color = [subset_color[data[\"layer\"]] for v, data in G.nodes(data=True)]\npos = nx.multipartite_layout(G, subset_key=\"layer\")\nplt.figure(figsize=(8, 8))\nnx.draw(G, pos, node_color=color, with_labels=False)\nplt.axis(\"equal\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "peekOfCode": "pos = nx.multipartite_layout(G, subset_key=\"layer\")\nplt.figure(figsize=(8, 8))\nnx.draw(G, pos, node_color=color, with_labels=False)\nplt.axis(\"equal\")\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_multipartite_graph",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_node_colormap",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_node_colormap",
        "peekOfCode": "G = nx.cycle_graph(24)\npos = nx.spring_layout(G, iterations=200)\nnx.draw(G, pos, node_color=range(24), node_size=800, cmap=plt.cm.Blues)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_node_colormap",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_node_colormap",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_node_colormap",
        "peekOfCode": "pos = nx.spring_layout(G, iterations=200)\nnx.draw(G, pos, node_color=range(24), node_size=800, cmap=plt.cm.Blues)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_node_colormap",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "peekOfCode": "G = nx.random_geometric_graph(200, 0.125)\n# position is stored as node attribute data for random_geometric_graph\npos = nx.get_node_attributes(G, \"pos\")\n# find node near center (0.5,0.5)\ndmin = 1\nncenter = 0\nfor n in pos:\n    x, y = pos[n]\n    d = (x - 0.5) ** 2 + (y - 0.5) ** 2\n    if d < dmin:",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "peekOfCode": "pos = nx.get_node_attributes(G, \"pos\")\n# find node near center (0.5,0.5)\ndmin = 1\nncenter = 0\nfor n in pos:\n    x, y = pos[n]\n    d = (x - 0.5) ** 2 + (y - 0.5) ** 2\n    if d < dmin:\n        ncenter = n\n        dmin = d",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "documentation": {}
    },
    {
        "label": "dmin",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "peekOfCode": "dmin = 1\nncenter = 0\nfor n in pos:\n    x, y = pos[n]\n    d = (x - 0.5) ** 2 + (y - 0.5) ** 2\n    if d < dmin:\n        ncenter = n\n        dmin = d\n# color by path length from node near center\np = dict(nx.single_source_shortest_path_length(G, ncenter))",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "documentation": {}
    },
    {
        "label": "ncenter",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "peekOfCode": "ncenter = 0\nfor n in pos:\n    x, y = pos[n]\n    d = (x - 0.5) ** 2 + (y - 0.5) ** 2\n    if d < dmin:\n        ncenter = n\n        dmin = d\n# color by path length from node near center\np = dict(nx.single_source_shortest_path_length(G, ncenter))\nplt.figure(figsize=(8, 8))",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "peekOfCode": "p = dict(nx.single_source_shortest_path_length(G, ncenter))\nplt.figure(figsize=(8, 8))\nnx.draw_networkx_edges(G, pos, nodelist=[ncenter], alpha=0.4)\nnx.draw_networkx_nodes(\n    G,\n    pos,\n    nodelist=list(p.keys()),\n    node_size=80,\n    node_color=list(p.values()),\n    cmap=plt.cm.Reds_r,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_random_geometric_graph",
        "documentation": {}
    },
    {
        "label": "G1",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "peekOfCode": "G1 = nx.read_edgelist(e1, delimiter=\"\\t\")\nG2 = nx.read_edgelist(e2, delimiter=\"\\t\")\nG3 = nx.read_edgelist(e3, delimiter=\"\\t\")\npos = nx.spring_layout(G3, iterations=100)\nplt.clf()\nplt.subplot(221)\nplt.title(\"samplike1\")\nnx.draw(G1, pos, node_size=50, with_labels=False)\nplt.subplot(222)\nplt.title(\"samplike2\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "documentation": {}
    },
    {
        "label": "G2",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "peekOfCode": "G2 = nx.read_edgelist(e2, delimiter=\"\\t\")\nG3 = nx.read_edgelist(e3, delimiter=\"\\t\")\npos = nx.spring_layout(G3, iterations=100)\nplt.clf()\nplt.subplot(221)\nplt.title(\"samplike1\")\nnx.draw(G1, pos, node_size=50, with_labels=False)\nplt.subplot(222)\nplt.title(\"samplike2\")\nnx.draw(G2, pos, node_size=50, with_labels=False)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "documentation": {}
    },
    {
        "label": "G3",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "peekOfCode": "G3 = nx.read_edgelist(e3, delimiter=\"\\t\")\npos = nx.spring_layout(G3, iterations=100)\nplt.clf()\nplt.subplot(221)\nplt.title(\"samplike1\")\nnx.draw(G1, pos, node_size=50, with_labels=False)\nplt.subplot(222)\nplt.title(\"samplike2\")\nnx.draw(G2, pos, node_size=50, with_labels=False)\nplt.subplot(223)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "peekOfCode": "pos = nx.spring_layout(G3, iterations=100)\nplt.clf()\nplt.subplot(221)\nplt.title(\"samplike1\")\nnx.draw(G1, pos, node_size=50, with_labels=False)\nplt.subplot(222)\nplt.title(\"samplike2\")\nnx.draw(G2, pos, node_size=50, with_labels=False)\nplt.subplot(223)\nplt.title(\"samplike3\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_sampson",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_simple_path",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_simple_path",
        "peekOfCode": "G = nx.path_graph(8)\nnx.draw(G)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_simple_path",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_spectral_grid",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_spectral_grid",
        "peekOfCode": "options = {\"node_color\": \"C0\", \"node_size\": 100}\nG = nx.grid_2d_graph(6, 6)\nplt.subplot(332)\nnx.draw_spectral(G, **options)\nG.remove_edge((2, 2), (2, 3))\nplt.subplot(334)\nnx.draw_spectral(G, **options)\nG.remove_edge((3, 2), (3, 3))\nplt.subplot(335)\nnx.draw_spectral(G, **options)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_spectral_grid",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_spectral_grid",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_spectral_grid",
        "peekOfCode": "G = nx.grid_2d_graph(6, 6)\nplt.subplot(332)\nnx.draw_spectral(G, **options)\nG.remove_edge((2, 2), (2, 3))\nplt.subplot(334)\nnx.draw_spectral(G, **options)\nG.remove_edge((3, 2), (3, 3))\nplt.subplot(335)\nnx.draw_spectral(G, **options)\nG.remove_edge((2, 2), (3, 2))",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_spectral_grid",
        "documentation": {}
    },
    {
        "label": "mbox_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "peekOfCode": "def mbox_graph():\n    mbox = mailbox.mbox(\"unix_email.mbox\")  # parse unix mailbox\n    G = nx.MultiDiGraph()  # create empty graph\n    # parse each messages and build graph\n    for msg in mbox:  # msg is python email.Message.Message object\n        (source_name, source_addr) = parseaddr(msg[\"From\"])  # sender\n        # get all recipients\n        # see https://docs.python.org/3/library/email.html\n        tos = msg.get_all(\"to\", [])\n        ccs = msg.get_all(\"cc\", [])",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "peekOfCode": "G = mbox_graph()\n# print edges with message subject\nfor (u, v, d) in G.edges(data=True):\n    print(f\"From: {u} To: {v} Subject: {d['message']['Subject']}\")\npos = nx.spring_layout(G, iterations=10)\nnx.draw(G, pos, node_size=0, alpha=0.4, edge_color=\"r\", font_size=16, with_labels=True)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "peekOfCode": "pos = nx.spring_layout(G, iterations=10)\nnx.draw(G, pos, node_size=0, alpha=0.4, edge_color=\"r\", font_size=16, with_labels=True)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_unix_email",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "peekOfCode": "G = nx.Graph()\nG.add_edge(\"a\", \"b\", weight=0.6)\nG.add_edge(\"a\", \"c\", weight=0.2)\nG.add_edge(\"c\", \"d\", weight=0.1)\nG.add_edge(\"c\", \"e\", weight=0.7)\nG.add_edge(\"c\", \"f\", weight=0.9)\nG.add_edge(\"a\", \"d\", weight=0.3)\nelarge = [(u, v) for (u, v, d) in G.edges(data=True) if d[\"weight\"] > 0.5]\nesmall = [(u, v) for (u, v, d) in G.edges(data=True) if d[\"weight\"] <= 0.5]\npos = nx.spring_layout(G)  # positions for all nodes",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "documentation": {}
    },
    {
        "label": "elarge",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "peekOfCode": "elarge = [(u, v) for (u, v, d) in G.edges(data=True) if d[\"weight\"] > 0.5]\nesmall = [(u, v) for (u, v, d) in G.edges(data=True) if d[\"weight\"] <= 0.5]\npos = nx.spring_layout(G)  # positions for all nodes\n# nodes\nnx.draw_networkx_nodes(G, pos, node_size=700)\n# edges\nnx.draw_networkx_edges(G, pos, edgelist=elarge, width=6)\nnx.draw_networkx_edges(\n    G, pos, edgelist=esmall, width=6, alpha=0.5, edge_color=\"b\", style=\"dashed\"\n)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "documentation": {}
    },
    {
        "label": "esmall",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "peekOfCode": "esmall = [(u, v) for (u, v, d) in G.edges(data=True) if d[\"weight\"] <= 0.5]\npos = nx.spring_layout(G)  # positions for all nodes\n# nodes\nnx.draw_networkx_nodes(G, pos, node_size=700)\n# edges\nnx.draw_networkx_edges(G, pos, edgelist=elarge, width=6)\nnx.draw_networkx_edges(\n    G, pos, edgelist=esmall, width=6, alpha=0.5, edge_color=\"b\", style=\"dashed\"\n)\n# labels",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "peekOfCode": "pos = nx.spring_layout(G)  # positions for all nodes\n# nodes\nnx.draw_networkx_nodes(G, pos, node_size=700)\n# edges\nnx.draw_networkx_edges(G, pos, edgelist=elarge, width=6)\nnx.draw_networkx_edges(\n    G, pos, edgelist=esmall, width=6, alpha=0.5, edge_color=\"b\", style=\"dashed\"\n)\n# labels\nnx.draw_networkx_labels(G, pos, font_size=20, font_family=\"sans-serif\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.drawing.plot_weighted_graph",
        "documentation": {}
    },
    {
        "label": "atlas",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.dot_atlas",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.dot_atlas",
        "peekOfCode": "atlas = graph_atlas_g()[0:20]\nfor G in atlas:\n    print(\n        f\"{G.name} has {nx.number_of_nodes(G)} nodes with {nx.number_of_edges(G)} edges\"\n    )\n    A = nx.nx_agraph.to_agraph(G)\n    A.graph_attr[\"label\"] = G.name\n    # set default node attributes\n    A.node_attr[\"color\"] = \"red\"\n    A.node_attr[\"style\"] = \"filled\"",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.dot_atlas",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "peekOfCode": "z = [5, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1]\nprint(nx.is_graphical(z))\nprint(\"Configuration model\")\nG = nx.configuration_model(z)  # configuration model\ndegree_sequence = [d for n, d in G.degree()]  # degree sequence\nprint(f\"Degree sequence {degree_sequence}\")\nprint(\"Degree histogram\")\nhist = {}\nfor d in degree_sequence:\n    if d in hist:",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "peekOfCode": "G = nx.configuration_model(z)  # configuration model\ndegree_sequence = [d for n, d in G.degree()]  # degree sequence\nprint(f\"Degree sequence {degree_sequence}\")\nprint(\"Degree histogram\")\nhist = {}\nfor d in degree_sequence:\n    if d in hist:\n        hist[d] += 1\n    else:\n        hist[d] = 1",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "documentation": {}
    },
    {
        "label": "degree_sequence",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "peekOfCode": "degree_sequence = [d for n, d in G.degree()]  # degree sequence\nprint(f\"Degree sequence {degree_sequence}\")\nprint(\"Degree histogram\")\nhist = {}\nfor d in degree_sequence:\n    if d in hist:\n        hist[d] += 1\n    else:\n        hist[d] = 1\nprint(\"degree #nodes\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "documentation": {}
    },
    {
        "label": "hist",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "peekOfCode": "hist = {}\nfor d in degree_sequence:\n    if d in hist:\n        hist[d] += 1\n    else:\n        hist[d] = 1\nprint(\"degree #nodes\")\nfor d in hist:\n    print(f\"{d:4} {hist[d]:6}\")\nnx.draw(G)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_degree_sequence",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "peekOfCode": "n = 10  # 10 nodes\nm = 20  # 20 edges\nG = nx.gnm_random_graph(n, m)\n# some properties\nprint(\"node degree clustering\")\nfor v in nx.nodes(G):\n    print(f\"{v} {nx.degree(G, v)} {nx.clustering(G, v)}\")\nprint()\nprint(\"the adjacency list\")\nfor line in nx.generate_adjlist(G):",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "peekOfCode": "m = 20  # 20 edges\nG = nx.gnm_random_graph(n, m)\n# some properties\nprint(\"node degree clustering\")\nfor v in nx.nodes(G):\n    print(f\"{v} {nx.degree(G, v)} {nx.clustering(G, v)}\")\nprint()\nprint(\"the adjacency list\")\nfor line in nx.generate_adjlist(G):\n    print(line)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "peekOfCode": "G = nx.gnm_random_graph(n, m)\n# some properties\nprint(\"node degree clustering\")\nfor v in nx.nodes(G):\n    print(f\"{v} {nx.degree(G, v)} {nx.clustering(G, v)}\")\nprint()\nprint(\"the adjacency list\")\nfor line in nx.generate_adjlist(G):\n    print(line)\nnx.draw(G)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_erdos_renyi",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "peekOfCode": "n = 500  # n nodes\np = 0.1\nw = [p * n for i in range(n)]  # w = p*n for all nodes\nG = expected_degree_graph(w)  # configuration model\nprint(\"Degree histogram\")\nprint(\"degree (#nodes) ****\")\ndh = nx.degree_histogram(G)\nfor i, d in enumerate(dh):\n    print(f\"{i:2} ({d:2}) {'*'*d}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "peekOfCode": "p = 0.1\nw = [p * n for i in range(n)]  # w = p*n for all nodes\nG = expected_degree_graph(w)  # configuration model\nprint(\"Degree histogram\")\nprint(\"degree (#nodes) ****\")\ndh = nx.degree_histogram(G)\nfor i, d in enumerate(dh):\n    print(f\"{i:2} ({d:2}) {'*'*d}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "documentation": {}
    },
    {
        "label": "w",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "peekOfCode": "w = [p * n for i in range(n)]  # w = p*n for all nodes\nG = expected_degree_graph(w)  # configuration model\nprint(\"Degree histogram\")\nprint(\"degree (#nodes) ****\")\ndh = nx.degree_histogram(G)\nfor i, d in enumerate(dh):\n    print(f\"{i:2} ({d:2}) {'*'*d}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "peekOfCode": "G = expected_degree_graph(w)  # configuration model\nprint(\"Degree histogram\")\nprint(\"degree (#nodes) ****\")\ndh = nx.degree_histogram(G)\nfor i, d in enumerate(dh):\n    print(f\"{i:2} ({d:2}) {'*'*d}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "documentation": {}
    },
    {
        "label": "dh",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "peekOfCode": "dh = nx.degree_histogram(G)\nfor i, d in enumerate(dh):\n    print(f\"{i:2} ({d:2}) {'*'*d}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_expected_degree_sequence",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "url = \"http://www-personal.umich.edu/~mejn/netdata/football.zip\"\nsock = urllib.urlopen(url)  # open URL\ns = io.BytesIO(sock.read())  # read into BytesIO \"file\"\nsock.close()\nzf = zipfile.ZipFile(s)  # zipfile object\ntxt = zf.read(\"football.txt\").decode()  # read info file\ngml = zf.read(\"football.gml\").decode()  # read gml data\n# throw away bogus first line with # from mejn files\ngml = gml.split(\"\\n\")[1:]\nG = nx.parse_gml(gml)  # parse gml data",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "sock = urllib.urlopen(url)  # open URL\ns = io.BytesIO(sock.read())  # read into BytesIO \"file\"\nsock.close()\nzf = zipfile.ZipFile(s)  # zipfile object\ntxt = zf.read(\"football.txt\").decode()  # read info file\ngml = zf.read(\"football.gml\").decode()  # read gml data\n# throw away bogus first line with # from mejn files\ngml = gml.split(\"\\n\")[1:]\nG = nx.parse_gml(gml)  # parse gml data\nprint(txt)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "s = io.BytesIO(sock.read())  # read into BytesIO \"file\"\nsock.close()\nzf = zipfile.ZipFile(s)  # zipfile object\ntxt = zf.read(\"football.txt\").decode()  # read info file\ngml = zf.read(\"football.gml\").decode()  # read gml data\n# throw away bogus first line with # from mejn files\ngml = gml.split(\"\\n\")[1:]\nG = nx.parse_gml(gml)  # parse gml data\nprint(txt)\n# print degree for each team - number of games",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "zf",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "zf = zipfile.ZipFile(s)  # zipfile object\ntxt = zf.read(\"football.txt\").decode()  # read info file\ngml = zf.read(\"football.gml\").decode()  # read gml data\n# throw away bogus first line with # from mejn files\ngml = gml.split(\"\\n\")[1:]\nG = nx.parse_gml(gml)  # parse gml data\nprint(txt)\n# print degree for each team - number of games\nfor n, d in G.degree():\n    print(f\"{n:20} {d:2}\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "txt",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "txt = zf.read(\"football.txt\").decode()  # read info file\ngml = zf.read(\"football.gml\").decode()  # read gml data\n# throw away bogus first line with # from mejn files\ngml = gml.split(\"\\n\")[1:]\nG = nx.parse_gml(gml)  # parse gml data\nprint(txt)\n# print degree for each team - number of games\nfor n, d in G.degree():\n    print(f\"{n:20} {d:2}\")\noptions = {",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "gml",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "gml = zf.read(\"football.gml\").decode()  # read gml data\n# throw away bogus first line with # from mejn files\ngml = gml.split(\"\\n\")[1:]\nG = nx.parse_gml(gml)  # parse gml data\nprint(txt)\n# print degree for each team - number of games\nfor n, d in G.degree():\n    print(f\"{n:20} {d:2}\")\noptions = {\n    \"node_color\": \"black\",",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "gml",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "gml = gml.split(\"\\n\")[1:]\nG = nx.parse_gml(gml)  # parse gml data\nprint(txt)\n# print degree for each team - number of games\nfor n, d in G.degree():\n    print(f\"{n:20} {d:2}\")\noptions = {\n    \"node_color\": \"black\",\n    \"node_size\": 50,\n    \"linewidths\": 0,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "G = nx.parse_gml(gml)  # parse gml data\nprint(txt)\n# print degree for each team - number of games\nfor n, d in G.degree():\n    print(f\"{n:20} {d:2}\")\noptions = {\n    \"node_color\": \"black\",\n    \"node_size\": 50,\n    \"linewidths\": 0,\n    \"width\": 0.1,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "peekOfCode": "options = {\n    \"node_color\": \"black\",\n    \"node_size\": 50,\n    \"linewidths\": 0,\n    \"width\": 0.1,\n}\nnx.draw(G, **options)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_football",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_karate_club",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_karate_club",
        "peekOfCode": "G = nx.karate_club_graph()\nprint(\"Node Degree\")\nfor v in G:\n    print(f\"{v:4} {G.degree(v):6}\")\nnx.draw_circular(G, with_labels=True)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_karate_club",
        "documentation": {}
    },
    {
        "label": "minard_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_napoleon_russian_campaign",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_napoleon_russian_campaign",
        "peekOfCode": "def minard_graph():\n    data1 = \"\"\"\\\n24.0,54.9,340000,A,1\n24.5,55.0,340000,A,1\n25.5,54.5,340000,A,1\n26.0,54.7,320000,A,1\n27.0,54.8,300000,A,1\n28.0,54.9,280000,A,1\n28.5,55.0,240000,A,1\n29.0,55.1,210000,A,1",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_napoleon_russian_campaign",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_napoleon_russian_campaign",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_napoleon_russian_campaign",
        "peekOfCode": "colors = [\"b\", \"g\", \"r\"]\nfor G in g:\n    c = colors.pop(0)\n    node_size = [int(G.pop[n] / 300.0) for n in G]\n    nx.draw_networkx_edges(G, G.pos, edge_color=c, width=4, alpha=0.5)\n    nx.draw_networkx_nodes(G, G.pos, node_size=node_size, node_color=c, alpha=0.5)\n    nx.draw_networkx_nodes(G, G.pos, node_size=5, node_color=\"k\")\nfor c in city:\n    x, y = city[c]\n    plt.text(x, y + 0.1, c)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_napoleon_russian_campaign",
        "documentation": {}
    },
    {
        "label": "roget_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "peekOfCode": "def roget_graph():\n    \"\"\" Return the thesaurus graph from the roget.dat example in\n    the Stanford Graph Base.\n    \"\"\"\n    # open file roget_dat.txt.gz\n    fh = gzip.open(\"roget_dat.txt.gz\", \"r\")\n    G = nx.DiGraph()\n    for line in fh.readlines():\n        line = line.decode()\n        if line.startswith(\"*\"):  # skip comments",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "peekOfCode": "G = roget_graph()\nprint(\"Loaded roget_dat.txt containing 1022 categories.\")\nprint(f\"digraph has {nx.number_of_nodes(G)} nodes with {nx.number_of_edges(G)} edges\")\nUG = G.to_undirected()\nprint(nx.number_connected_components(UG), \"connected components\")\noptions = {\n    \"node_color\": \"black\",\n    \"node_size\": 1,\n    \"edge_color\": \"gray\",\n    \"linewidths\": 0,",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "documentation": {}
    },
    {
        "label": "UG",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "peekOfCode": "UG = G.to_undirected()\nprint(nx.number_connected_components(UG), \"connected components\")\noptions = {\n    \"node_color\": \"black\",\n    \"node_size\": 1,\n    \"edge_color\": \"gray\",\n    \"linewidths\": 0,\n    \"width\": 0.1,\n}\nnx.draw_circular(UG, **options)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "peekOfCode": "options = {\n    \"node_color\": \"black\",\n    \"node_size\": 1,\n    \"edge_color\": \"gray\",\n    \"linewidths\": 0,\n    \"width\": 0.1,\n}\nnx.draw_circular(UG, **options)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_roget",
        "documentation": {}
    },
    {
        "label": "generate_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "peekOfCode": "def generate_graph(words):\n    G = nx.Graph(name=\"words\")\n    lookup = {c: lowercase.index(c) for c in lowercase}\n    def edit_distance_one(word):\n        for i in range(len(word)):\n            left, c, right = word[0:i], word[i], word[i + 1 :]\n            j = lookup[c]  # lowercase.index(c)\n            for cc in lowercase[j + 1 :]:\n                yield left + cc + right\n    candgen = (",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "documentation": {}
    },
    {
        "label": "words_graph",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "peekOfCode": "def words_graph():\n    \"\"\"Return the words example graph from the Stanford GraphBase\"\"\"\n    fh = gzip.open(\"words_dat.txt.gz\", \"r\")\n    words = set()\n    for line in fh.readlines():\n        line = line.decode()\n        if line.startswith(\"*\"):\n            continue\n        w = str(line[0:5])\n        words.add(w)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "description": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "peekOfCode": "G = words_graph()\nprint(\"Loaded words_dat.txt containing 5757 five-letter English words.\")\nprint(\"Two words are connected if they differ in one letter.\")\nprint(f\"Graph has {nx.number_of_nodes(G)} nodes with {nx.number_of_edges(G)} edges\")\nprint(f\"{nx.number_connected_components(G)} connected components\")\nfor (source, target) in [(\"chaos\", \"order\"), (\"nodes\", \"graph\"), (\"pound\", \"marks\")]:\n    print(f\"Shortest path between {source} and {target} is\")\n    try:\n        sp = nx.shortest_path(G, source, target)\n        for n in sp:",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.graph.plot_words",
        "documentation": {}
    },
    {
        "label": "static_proxy",
        "kind": 2,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "description": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "peekOfCode": "def static_proxy():\n    return app.send_static_file(\"force.html\")\nprint(\"\\nGo to http://localhost:8000 to see the example\\n\")\napp.run(port=8000)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "description": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "peekOfCode": "G = nx.barbell_graph(6, 3)\n# this d3 example uses the name attribute for the mouse-hover value,\n# so add a name to each node\nfor n in G:\n    G.nodes[n][\"name\"] = n\n# write json formatted data\nd = json_graph.node_link_data(G)  # node-link format to serialize\n# write json\njson.dump(d, open(\"force/force.json\", \"w\"))\nprint(\"Wrote node-link JSON data to force/force.json\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "description": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "peekOfCode": "d = json_graph.node_link_data(G)  # node-link format to serialize\n# write json\njson.dump(d, open(\"force/force.json\", \"w\"))\nprint(\"Wrote node-link JSON data to force/force.json\")\n# Serve the file over http to allow for cross origin requests\napp = flask.Flask(__name__, static_folder=\"force\")\n@app.route(\"/\")\ndef static_proxy():\n    return app.send_static_file(\"force.html\")\nprint(\"\\nGo to http://localhost:8000 to see the example\\n\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "description": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "peekOfCode": "app = flask.Flask(__name__, static_folder=\"force\")\n@app.route(\"/\")\ndef static_proxy():\n    return app.send_static_file(\"force.html\")\nprint(\"\\nGo to http://localhost:8000 to see the example\\n\")\napp.run(port=8000)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.javascript.force",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "peekOfCode": "G = nx.Graph()\nG.add_node(\"one\", type=\"normal\")\nG.add_node(\"two\", type=\"special\")\nG.add_node(\"solo\")\n# add edges\nG.add_edge(\"one\", \"two\")\nG.add_edge(\"two\", 3, type=\"extra special\")\n# convert to JIT JSON\njit_json = jit_data(G, indent=4)\nprint(jit_json)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "documentation": {}
    },
    {
        "label": "jit_json",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "peekOfCode": "jit_json = jit_data(G, indent=4)\nprint(jit_json)\nX = jit_graph(json.loads(jit_json))\nprint(f\"Nodes: {list(X.nodes(data=True))}\")\nprint(f\"Edges: {list(X.edges(data=True))}\")\nnx.draw(G, with_labels=True)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "peekOfCode": "X = jit_graph(json.loads(jit_json))\nprint(f\"Nodes: {list(X.nodes(data=True))}\")\nprint(f\"Edges: {list(X.edges(data=True))}\")\nnx.draw(G, with_labels=True)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.jit.plot_rgraph",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "peekOfCode": "G = nx.Graph()\n# ad edges with red color\nG.add_edge(1, 2, color=\"red\")\nG.add_edge(2, 3, color=\"red\")\n# add nodes 3 and 4\nG.add_node(3)\nG.add_node(4)\n# convert to a graphviz agraph\nA = nx.nx_agraph.to_agraph(G)\n# write to dot file",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "peekOfCode": "A = nx.nx_agraph.to_agraph(G)\n# write to dot file\nA.write(\"k5_attributes.dot\")\n# convert back to networkx Graph with attributes on edges and\n# default attributes as dictionary data\nX = nx.nx_agraph.from_agraph(A)\nprint(\"edges\")\nprint(list(X.edges(data=True)))\nprint(\"default graph attributes\")\nprint(X.graph)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "peekOfCode": "X = nx.nx_agraph.from_agraph(A)\nprint(\"edges\")\nprint(list(X.edges(data=True)))\nprint(\"default graph attributes\")\nprint(X.graph)\nprint(\"node node attributes\")\nprint(X.nodes.data(True))",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_attributes",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_draw",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_draw",
        "peekOfCode": "G = nx.complete_graph(5)  # start with K5 in networkx\nA = nx.nx_agraph.to_agraph(G)  # convert to a graphviz graph\nA.layout()  # neato layout\nA.draw(\"k5.ps\")  # write postscript in k5.ps with neato layout",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_draw",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_draw",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_draw",
        "peekOfCode": "A = nx.nx_agraph.to_agraph(G)  # convert to a graphviz graph\nA.layout()  # neato layout\nA.draw(\"k5.ps\")  # write postscript in k5.ps with neato layout",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_draw",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "peekOfCode": "G = nx.complete_graph(5)  # start with K5 in networkx\nA = nx.nx_agraph.to_agraph(G)  # convert to a graphviz graph\nX1 = nx.nx_agraph.from_agraph(A)  # convert back to networkx (but as Graph)\nX2 = nx.Graph(A)  # fancy way to do conversion\nG1 = nx.Graph(X1)  # now make it a Graph\nA.write(\"k5.dot\")  # write to dot file\nX3 = nx.nx_agraph.read_dot(\"k5.dot\")  # read from dotfile",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "peekOfCode": "A = nx.nx_agraph.to_agraph(G)  # convert to a graphviz graph\nX1 = nx.nx_agraph.from_agraph(A)  # convert back to networkx (but as Graph)\nX2 = nx.Graph(A)  # fancy way to do conversion\nG1 = nx.Graph(X1)  # now make it a Graph\nA.write(\"k5.dot\")  # write to dot file\nX3 = nx.nx_agraph.read_dot(\"k5.dot\")  # read from dotfile",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "documentation": {}
    },
    {
        "label": "X1",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "peekOfCode": "X1 = nx.nx_agraph.from_agraph(A)  # convert back to networkx (but as Graph)\nX2 = nx.Graph(A)  # fancy way to do conversion\nG1 = nx.Graph(X1)  # now make it a Graph\nA.write(\"k5.dot\")  # write to dot file\nX3 = nx.nx_agraph.read_dot(\"k5.dot\")  # read from dotfile",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "documentation": {}
    },
    {
        "label": "X2",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "peekOfCode": "X2 = nx.Graph(A)  # fancy way to do conversion\nG1 = nx.Graph(X1)  # now make it a Graph\nA.write(\"k5.dot\")  # write to dot file\nX3 = nx.nx_agraph.read_dot(\"k5.dot\")  # read from dotfile",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "documentation": {}
    },
    {
        "label": "G1",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "peekOfCode": "G1 = nx.Graph(X1)  # now make it a Graph\nA.write(\"k5.dot\")  # write to dot file\nX3 = nx.nx_agraph.read_dot(\"k5.dot\")  # read from dotfile",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "documentation": {}
    },
    {
        "label": "X3",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "peekOfCode": "X3 = nx.nx_agraph.read_dot(\"k5.dot\")  # read from dotfile",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_pygraphviz_simple",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_write_dotfile",
        "description": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_write_dotfile",
        "peekOfCode": "G = nx.grid_2d_graph(5, 5)  # 5x5 grid\nwrite_dot(G, \"grid.dot\")\nprint(\"Now run: neato -Tps grid.dot >grid.ps\")",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.pygraphviz.plot_write_dotfile",
        "documentation": {}
    },
    {
        "label": "AntiGraph",
        "kind": 6,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "peekOfCode": "class AntiGraph(nx.Graph):\n    \"\"\"\n    Class for complement graphs.\n    The main goal is to be able to work with big and dense graphs with\n    a low memory footprint.\n    In this class you add the edges that *do not exist* in the dense graph,\n    the report methods of the class return the neighbors, the edges and\n    the degree as if it was the dense graph. Thus it's possible to use\n    an instance of this class with some of NetworkX functions.\n    \"\"\"",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "documentation": {}
    },
    {
        "label": "Gnp",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "peekOfCode": "Gnp = nx.gnp_random_graph(20, 0.8, seed=42)\nAnp = AntiGraph(nx.complement(Gnp))\nGd = nx.davis_southern_women_graph()\nAd = AntiGraph(nx.complement(Gd))\nGk = nx.karate_club_graph()\nAk = AntiGraph(nx.complement(Gk))\npairs = [(Gnp, Anp), (Gd, Ad), (Gk, Ak)]\n# test connected components\nfor G, A in pairs:\n    gc = [set(c) for c in nx.connected_components(G)]",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "documentation": {}
    },
    {
        "label": "Anp",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "peekOfCode": "Anp = AntiGraph(nx.complement(Gnp))\nGd = nx.davis_southern_women_graph()\nAd = AntiGraph(nx.complement(Gd))\nGk = nx.karate_club_graph()\nAk = AntiGraph(nx.complement(Gk))\npairs = [(Gnp, Anp), (Gd, Ad), (Gk, Ak)]\n# test connected components\nfor G, A in pairs:\n    gc = [set(c) for c in nx.connected_components(G)]\n    ac = [set(c) for c in nx.connected_components(A)]",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "documentation": {}
    },
    {
        "label": "Gd",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "peekOfCode": "Gd = nx.davis_southern_women_graph()\nAd = AntiGraph(nx.complement(Gd))\nGk = nx.karate_club_graph()\nAk = AntiGraph(nx.complement(Gk))\npairs = [(Gnp, Anp), (Gd, Ad), (Gk, Ak)]\n# test connected components\nfor G, A in pairs:\n    gc = [set(c) for c in nx.connected_components(G)]\n    ac = [set(c) for c in nx.connected_components(A)]\n    for comp in ac:",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "documentation": {}
    },
    {
        "label": "Ad",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "peekOfCode": "Ad = AntiGraph(nx.complement(Gd))\nGk = nx.karate_club_graph()\nAk = AntiGraph(nx.complement(Gk))\npairs = [(Gnp, Anp), (Gd, Ad), (Gk, Ak)]\n# test connected components\nfor G, A in pairs:\n    gc = [set(c) for c in nx.connected_components(G)]\n    ac = [set(c) for c in nx.connected_components(A)]\n    for comp in ac:\n        assert comp in gc",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "documentation": {}
    },
    {
        "label": "Gk",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "peekOfCode": "Gk = nx.karate_club_graph()\nAk = AntiGraph(nx.complement(Gk))\npairs = [(Gnp, Anp), (Gd, Ad), (Gk, Ak)]\n# test connected components\nfor G, A in pairs:\n    gc = [set(c) for c in nx.connected_components(G)]\n    ac = [set(c) for c in nx.connected_components(A)]\n    for comp in ac:\n        assert comp in gc\n# test biconnected components",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "documentation": {}
    },
    {
        "label": "Ak",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "peekOfCode": "Ak = AntiGraph(nx.complement(Gk))\npairs = [(Gnp, Anp), (Gd, Ad), (Gk, Ak)]\n# test connected components\nfor G, A in pairs:\n    gc = [set(c) for c in nx.connected_components(G)]\n    ac = [set(c) for c in nx.connected_components(A)]\n    for comp in ac:\n        assert comp in gc\n# test biconnected components\nfor G, A in pairs:",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "documentation": {}
    },
    {
        "label": "pairs",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "peekOfCode": "pairs = [(Gnp, Anp), (Gd, Ad), (Gk, Ak)]\n# test connected components\nfor G, A in pairs:\n    gc = [set(c) for c in nx.connected_components(G)]\n    ac = [set(c) for c in nx.connected_components(A)]\n    for comp in ac:\n        assert comp in gc\n# test biconnected components\nfor G, A in pairs:\n    gc = [set(c) for c in nx.biconnected_components(G)]",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_antigraph",
        "documentation": {}
    },
    {
        "label": "PrintGraph",
        "kind": 6,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "peekOfCode": "class PrintGraph(Graph):\n    \"\"\"\n    Example subclass of the Graph class.\n    Prints activity log to file or standard output.\n    \"\"\"\n    def __init__(self, data=None, name=\"\", file=None, **attr):\n        Graph.__init__(self, data=data, name=name, **attr)\n        if file is None:\n            import sys\n            self.fh = sys.stdout",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "peekOfCode": "G = PrintGraph()\nG.add_node(\"foo\")\nG.add_nodes_from(\"bar\", weight=8)\nG.remove_node(\"b\")\nG.remove_nodes_from(\"ar\")\nprint(\"Nodes in G: \", G.nodes(data=True))\nG.add_edge(0, 1, weight=10)\nprint(\"Edges in G: \", G.edges(data=True))\nG.remove_edge(0, 1)\nG.add_edges_from(zip(range(0, 3), range(1, 4)), weight=10)",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "description": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "peekOfCode": "G = PrintGraph()\nnx.add_path(G, range(10))\nnx.add_star(G, range(9, 13))\nnx.draw(G)\nplt.show()",
        "detail": ".venv.share.doc.networkx-2.5.1.examples.subclass.plot_printgraph",
        "documentation": {}
    },
    {
        "label": "QuickDrawImageDataset",
        "kind": 6,
        "importPath": "apps.generative_models.data",
        "description": "apps.generative_models.data",
        "peekOfCode": "class QuickDrawImageDataset(th.utils.data.Dataset):\n    BASE_DATA_URL = \\\n        \"https://console.cloud.google.com/storage/browser/_details/quickdraw_dataset/full/numpy_bitmap/cat.npy\"\n    \"\"\"\n    Args:\n        spatial_limit(int): maximum spatial extent in pixels.\n    \"\"\"\n    def __init__(self, imsize, train=True):\n        super(QuickDrawImageDataset, self).__init__()\n        file = os.path.join(DATA, \"cat.npy\")",
        "detail": "apps.generative_models.data",
        "documentation": {}
    },
    {
        "label": "QuickDrawDataset",
        "kind": 6,
        "importPath": "apps.generative_models.data",
        "description": "apps.generative_models.data",
        "peekOfCode": "class QuickDrawDataset(th.utils.data.Dataset):\n    BASE_DATA_URL = \\\n        \"https://storage.cloud.google.com/quickdraw_dataset/sketchrnn\"\n    \"\"\"\n    Args:\n        spatial_limit(int): maximum spatial extent in pixels.\n    \"\"\"\n    def __init__(self, dataset, mode=\"train\",\n                 max_seq_length=250,\n                 spatial_limit=1000):",
        "detail": "apps.generative_models.data",
        "documentation": {}
    },
    {
        "label": "FixedLengthQuickDrawDataset",
        "kind": 6,
        "importPath": "apps.generative_models.data",
        "description": "apps.generative_models.data",
        "peekOfCode": "class FixedLengthQuickDrawDataset(QuickDrawDataset):\n    \"\"\"A variant of the QuickDraw dataset where the strokes are represented as \n    a fixed-length sequence of triplets (dx, dy, opacity), where opacity = 0, 1.\n    \"\"\"\n    def __init__(self, *args, canvas_size=64, **kwargs):\n        super(FixedLengthQuickDrawDataset, self).__init__(*args, **kwargs)\n        self.canvas_size = canvas_size\n    def __getitem__(self, idx):\n        sample = super(FixedLengthQuickDrawDataset, self).__getitem__(idx)\n        # We construct a stroke opacity variable from the pen down state, dx, dy remain unchanged",
        "detail": "apps.generative_models.data",
        "documentation": {}
    },
    {
        "label": "MNISTDataset",
        "kind": 6,
        "importPath": "apps.generative_models.data",
        "description": "apps.generative_models.data",
        "peekOfCode": "class MNISTDataset(th.utils.data.Dataset):\n    def __init__(self, imsize, train=True):\n        super(MNISTDataset, self).__init__()\n        self.mnist = dset.MNIST(root=os.path.join(DATA, \"mnist\"),\n                                train=train,\n                                download=True,\n                                transform=transforms.Compose([\n                                    transforms.Resize((imsize, imsize)),\n                                    transforms.ToTensor(),\n                                ]))",
        "detail": "apps.generative_models.data",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "apps.generative_models.data",
        "description": "apps.generative_models.data",
        "peekOfCode": "BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nDATA = os.path.join(BASE_DIR, \"data\")\nLOG = ttools.get_logger(__name__)\nclass QuickDrawImageDataset(th.utils.data.Dataset):\n    BASE_DATA_URL = \\\n        \"https://console.cloud.google.com/storage/browser/_details/quickdraw_dataset/full/numpy_bitmap/cat.npy\"\n    \"\"\"\n    Args:\n        spatial_limit(int): maximum spatial extent in pixels.\n    \"\"\"",
        "detail": "apps.generative_models.data",
        "documentation": {}
    },
    {
        "label": "DATA",
        "kind": 5,
        "importPath": "apps.generative_models.data",
        "description": "apps.generative_models.data",
        "peekOfCode": "DATA = os.path.join(BASE_DIR, \"data\")\nLOG = ttools.get_logger(__name__)\nclass QuickDrawImageDataset(th.utils.data.Dataset):\n    BASE_DATA_URL = \\\n        \"https://console.cloud.google.com/storage/browser/_details/quickdraw_dataset/full/numpy_bitmap/cat.npy\"\n    \"\"\"\n    Args:\n        spatial_limit(int): maximum spatial extent in pixels.\n    \"\"\"\n    def __init__(self, imsize, train=True):",
        "detail": "apps.generative_models.data",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "apps.generative_models.data",
        "description": "apps.generative_models.data",
        "peekOfCode": "LOG = ttools.get_logger(__name__)\nclass QuickDrawImageDataset(th.utils.data.Dataset):\n    BASE_DATA_URL = \\\n        \"https://console.cloud.google.com/storage/browser/_details/quickdraw_dataset/full/numpy_bitmap/cat.npy\"\n    \"\"\"\n    Args:\n        spatial_limit(int): maximum spatial extent in pixels.\n    \"\"\"\n    def __init__(self, imsize, train=True):\n        super(QuickDrawImageDataset, self).__init__()",
        "detail": "apps.generative_models.data",
        "documentation": {}
    },
    {
        "label": "postprocess",
        "kind": 2,
        "importPath": "apps.generative_models.eval_gan",
        "description": "apps.generative_models.eval_gan",
        "peekOfCode": "def postprocess(im, invert=False):\n    im = th.clamp((im + 1.0) / 2.0, 0, 1)\n    if invert:\n        im = (1.0 - im)\n    im = ttools.tensor2image(im)\n    return im\ndef imsave(im, path):\n    os.makedirs(os.path.dirname(path), exist_ok=True)\n    imageio.imwrite(path, im)\ndef save_scene(scn, path):",
        "detail": "apps.generative_models.eval_gan",
        "documentation": {}
    },
    {
        "label": "imsave",
        "kind": 2,
        "importPath": "apps.generative_models.eval_gan",
        "description": "apps.generative_models.eval_gan",
        "peekOfCode": "def imsave(im, path):\n    os.makedirs(os.path.dirname(path), exist_ok=True)\n    imageio.imwrite(path, im)\ndef save_scene(scn, path):\n    os.makedirs(os.path.dirname(path), exist_ok=True)\n    pydiffvg.save_svg(path, *scn, use_gamma=False)\ndef run(args):\n    th.manual_seed(0)\n    np.random.seed(0)\n    meta = ttools.Checkpointer.load_meta(args.model, \"vect_g_\")",
        "detail": "apps.generative_models.eval_gan",
        "documentation": {}
    },
    {
        "label": "save_scene",
        "kind": 2,
        "importPath": "apps.generative_models.eval_gan",
        "description": "apps.generative_models.eval_gan",
        "peekOfCode": "def save_scene(scn, path):\n    os.makedirs(os.path.dirname(path), exist_ok=True)\n    pydiffvg.save_svg(path, *scn, use_gamma=False)\ndef run(args):\n    th.manual_seed(0)\n    np.random.seed(0)\n    meta = ttools.Checkpointer.load_meta(args.model, \"vect_g_\")\n    if meta is None:\n        LOG.warning(\"Could not load metadata at %s, aborting.\", args.model)\n        return",
        "detail": "apps.generative_models.eval_gan",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "apps.generative_models.eval_gan",
        "description": "apps.generative_models.eval_gan",
        "peekOfCode": "def run(args):\n    th.manual_seed(0)\n    np.random.seed(0)\n    meta = ttools.Checkpointer.load_meta(args.model, \"vect_g_\")\n    if meta is None:\n        LOG.warning(\"Could not load metadata at %s, aborting.\", args.model)\n        return\n    LOG.info(\"Loaded model %s with metadata:\\n %s\", args.model, meta)\n    if args.output_dir is None:\n        outdir = os.path.join(args.model, \"eval\")",
        "detail": "apps.generative_models.eval_gan",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "apps.generative_models.eval_gan",
        "description": "apps.generative_models.eval_gan",
        "peekOfCode": "LOG = ttools.get_logger(__name__)\ndef postprocess(im, invert=False):\n    im = th.clamp((im + 1.0) / 2.0, 0, 1)\n    if invert:\n        im = (1.0 - im)\n    im = ttools.tensor2image(im)\n    return im\ndef imsave(im, path):\n    os.makedirs(os.path.dirname(path), exist_ok=True)\n    imageio.imwrite(path, im)",
        "detail": "apps.generative_models.eval_gan",
        "documentation": {}
    },
    {
        "label": "KLDivergence",
        "kind": 6,
        "importPath": "apps.generative_models.losses",
        "description": "apps.generative_models.losses",
        "peekOfCode": "class KLDivergence(th.nn.Module):\n    \"\"\"\n    Args:\n        min_value(float): the loss is clipped so that value below this\n            number don't affect the optimization.\n    \"\"\"\n    def __init__(self, min_value=0.2):\n        super(KLDivergence, self).__init__()\n        self.min_value = min_value\n    def forward(self, mu, log_sigma):",
        "detail": "apps.generative_models.losses",
        "documentation": {}
    },
    {
        "label": "MultiscaleMSELoss",
        "kind": 6,
        "importPath": "apps.generative_models.losses",
        "description": "apps.generative_models.losses",
        "peekOfCode": "class MultiscaleMSELoss(th.nn.Module):\n    def __init__(self, channels=3):\n        super(MultiscaleMSELoss, self).__init__()\n        self.blur = imops.GaussianBlur(1, channels=channels)\n    def forward(self, im, target):\n        bs, c, h, w = im.shape\n        num_levels = max(int(np.ceil(np.log2(h))) - 2, 1)\n        losses = []\n        for lvl in range(num_levels):\n            loss = th.nn.functional.mse_loss(im, target)",
        "detail": "apps.generative_models.losses",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureReconstructionLoss",
        "kind": 6,
        "importPath": "apps.generative_models.losses",
        "description": "apps.generative_models.losses",
        "peekOfCode": "class GaussianMixtureReconstructionLoss(th.nn.Module):\n    \"\"\"\n    Args:\n    \"\"\"\n    def __init__(self, eps=1e-5):\n        super(GaussianMixtureReconstructionLoss, self).__init__()\n        self.eps = eps\n    def forward(self, pen_logits, mixture_logits, gaussian_params, targets):\n        dx = targets[..., 0]\n        dy = targets[..., 1]",
        "detail": "apps.generative_models.losses",
        "documentation": {}
    },
    {
        "label": "gaussian_pdfs",
        "kind": 2,
        "importPath": "apps.generative_models.losses",
        "description": "apps.generative_models.losses",
        "peekOfCode": "def gaussian_pdfs(dx, dy, params):\n    \"\"\"Returns the pdf at (dx, dy) for each Gaussian in the mixture.\n    \"\"\"\n    dx = dx.unsqueeze(-1)  # replicate dx, dy to evaluate all pdfs at once\n    dy = dy.unsqueeze(-1)\n    mu_x = params[..., 0]\n    mu_y = params[..., 1]\n    sigma_x = params[..., 2].exp()\n    sigma_y = params[..., 3].exp()\n    rho_xy = th.tanh(params[..., 4])",
        "detail": "apps.generative_models.losses",
        "documentation": {}
    },
    {
        "label": "MNISTCallback",
        "kind": 6,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "class MNISTCallback(ttools.callbacks.ImageDisplayCallback):\n    \"\"\"Simple callback that visualize generated images during training.\"\"\"\n    def visualized_image(self, batch, step_data, is_val=False):\n        im = step_data[\"rendering\"].detach().cpu()\n        im = 0.5 + 0.5*im\n        ref = batch[0].cpu()\n        vizdata = [im, ref]\n        # tensor to visualize, concatenate images\n        viz = th.clamp(th.cat(vizdata, 2), 0, 1)\n        return viz",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "VAEInterface",
        "kind": 6,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "class VAEInterface(ttools.ModelInterface):\n    def __init__(self, model, lr=1e-4, cuda=True, max_grad_norm=10,\n                 variational=True, w_kld=1.0):\n        super(VAEInterface, self).__init__()\n        self.max_grad_norm = max_grad_norm\n        self.model = model\n        self.w_kld = w_kld\n        self.variational = variational\n        self.device = \"cpu\"\n        if cuda:",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "VectorMNISTVAE",
        "kind": 6,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "class VectorMNISTVAE(th.nn.Module):\n    def __init__(self, imsize=28, paths=4, segments=5, samples=2, zdim=128,\n                 conditional=False, variational=True, raster=False, fc=False,\n                 stroke_width=None):\n        super(VectorMNISTVAE, self).__init__()\n        self.samples = samples\n        self.imsize = imsize\n        self.paths = paths\n        self.segments = segments\n        self.zdim = zdim",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "kind": 6,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "class Dataset(th.utils.data.Dataset):\n    def __init__(self, data_dir, imsize):\n        super(Dataset, self).__init__()\n        self.mnist = dset.MNIST(root=data_dir, download=True,\n                                transform=transforms.Compose([\n                                    transforms.ToTensor(),\n                                ]))\n    def __len__(self):\n        return len(self.mnist)\n    def __getitem__(self, idx):",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "def render(canvas_width, canvas_height, shapes, shape_groups, samples=2):\n    _render = pydiffvg.RenderFunction.apply\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\n        canvas_width, canvas_height, shapes, shape_groups)\n    img = _render(canvas_width,\n                  canvas_height,\n                  samples,\n                  samples,\n                  0,\n                  None,",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "def train(args):\n    th.manual_seed(0)\n    np.random.seed(0)\n    pydiffvg.set_use_gpu(args.cuda)\n    # Initialize datasets\n    imsize = 28\n    dataset = Dataset(args.data_dir, imsize)\n    dataloader = DataLoader(dataset, batch_size=args.bs,\n                            num_workers=4, shuffle=True)\n    if args.generator in [\"vae\", \"ae\"]:",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "generate_samples",
        "kind": 2,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "def generate_samples(args):\n    chkpt = VAE_OUTPUT\n    if args.conditional:\n        chkpt += \"_conditional\"\n    if args.fc:\n        chkpt += \"_fc\"\n    meta = ttools.Checkpointer.load_meta(chkpt, prefix=\"g_\")\n    if meta is None:\n        LOG.info(\"No metadata in checkpoint (or no checkpoint), aborting.\")\n        return",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "interpolate",
        "kind": 2,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "def interpolate(args):\n    chkpt = VAE_OUTPUT\n    if args.conditional:\n        chkpt += \"_conditional\"\n    if args.fc:\n        chkpt += \"_fc\"\n    meta = ttools.Checkpointer.load_meta(chkpt, prefix=\"g_\")\n    if meta is None:\n        LOG.info(\"No metadata in checkpoint (or no checkpoint), aborting.\")\n        return",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "LOG = ttools.get_logger(__name__)\nBASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nVAE_OUTPUT = os.path.join(BASE_DIR, \"results\", \"mnist_vae\")\nAE_OUTPUT = os.path.join(BASE_DIR, \"results\", \"mnist_ae\")\ndef _onehot(label):\n    bs = label.shape[0]\n    label_onehot = label.new(bs, 10)\n    label_onehot = label_onehot.zero_()\n    label_onehot.scatter_(1, label.unsqueeze(1), 1)\n    return label_onehot.float()",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nVAE_OUTPUT = os.path.join(BASE_DIR, \"results\", \"mnist_vae\")\nAE_OUTPUT = os.path.join(BASE_DIR, \"results\", \"mnist_ae\")\ndef _onehot(label):\n    bs = label.shape[0]\n    label_onehot = label.new(bs, 10)\n    label_onehot = label_onehot.zero_()\n    label_onehot.scatter_(1, label.unsqueeze(1), 1)\n    return label_onehot.float()\ndef render(canvas_width, canvas_height, shapes, shape_groups, samples=2):",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "VAE_OUTPUT",
        "kind": 5,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "VAE_OUTPUT = os.path.join(BASE_DIR, \"results\", \"mnist_vae\")\nAE_OUTPUT = os.path.join(BASE_DIR, \"results\", \"mnist_ae\")\ndef _onehot(label):\n    bs = label.shape[0]\n    label_onehot = label.new(bs, 10)\n    label_onehot = label_onehot.zero_()\n    label_onehot.scatter_(1, label.unsqueeze(1), 1)\n    return label_onehot.float()\ndef render(canvas_width, canvas_height, shapes, shape_groups, samples=2):\n    _render = pydiffvg.RenderFunction.apply",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "AE_OUTPUT",
        "kind": 5,
        "importPath": "apps.generative_models.mnist_vae",
        "description": "apps.generative_models.mnist_vae",
        "peekOfCode": "AE_OUTPUT = os.path.join(BASE_DIR, \"results\", \"mnist_ae\")\ndef _onehot(label):\n    bs = label.shape[0]\n    label_onehot = label.new(bs, 10)\n    label_onehot = label_onehot.zero_()\n    label_onehot.scatter_(1, label.unsqueeze(1), 1)\n    return label_onehot.float()\ndef render(canvas_width, canvas_height, shapes, shape_groups, samples=2):\n    _render = pydiffvg.RenderFunction.apply\n    scene_args = pydiffvg.RenderFunction.serialize_scene(",
        "detail": "apps.generative_models.mnist_vae",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "kind": 6,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "class BaseModel(th.nn.Module):\n    def sample_z(self, bs, device=\"cpu\"):\n        return th.randn(bs, self.zdim).to(device)\nclass BaseVectorModel(BaseModel):\n    def get_vector(self, z):\n        _, scenes = self._forward(z)\n        return scenes\n    def _forward(self, x):\n        raise NotImplementedError()\n    def forward(self, z):",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "BaseVectorModel",
        "kind": 6,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "class BaseVectorModel(BaseModel):\n    def get_vector(self, z):\n        _, scenes = self._forward(z)\n        return scenes\n    def _forward(self, x):\n        raise NotImplementedError()\n    def forward(self, z):\n        # Only return the raster\n        return self._forward(z)[0]\nclass BezierVectorGenerator(BaseVectorModel):",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "BezierVectorGenerator",
        "kind": 6,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "class BezierVectorGenerator(BaseVectorModel):\n    NUM_SEGMENTS = 2\n    def __init__(self, num_strokes=4,\n                 zdim=128, width=32, imsize=32,\n                 color_output=False,\n                 stroke_width=None):\n        super(BezierVectorGenerator, self).__init__()\n        if stroke_width is None:\n            self.stroke_width = (0.5, 3.0)\n            LOG.warning(\"Setting default stroke with %s\", self.stroke_width)",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "VectorGenerator",
        "kind": 6,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "class VectorGenerator(BaseVectorModel):\n    def __init__(self, num_strokes=4,\n                 zdim=128, width=32, imsize=32,\n                 color_output=False,\n                 stroke_width=None):\n        super(VectorGenerator, self).__init__()\n        if stroke_width is None:\n            self.stroke_width = (0.5, 3.0)\n            LOG.warning(\"Setting default stroke with %s\", self.stroke_width)\n        else:",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "RNNVectorGenerator",
        "kind": 6,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "class RNNVectorGenerator(BaseVectorModel):\n    def __init__(self, num_strokes=64,\n                 zdim=128, width=32, imsize=32,\n                 hidden_size=512, dropout=0.9,\n                 color_output=False,\n                 num_layers=3, stroke_width=None):\n        super(RNNVectorGenerator, self).__init__()\n        if stroke_width is None:\n            self.stroke_width = (0.5, 3.0)\n            LOG.warning(\"Setting default stroke with %s\", self.stroke_width)",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "ChainRNNVectorGenerator",
        "kind": 6,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "class ChainRNNVectorGenerator(BaseVectorModel):\n    \"\"\"Strokes form a single long chain.\"\"\"\n    def __init__(self, num_strokes=64,\n                 zdim=128, width=32, imsize=32,\n                 hidden_size=512, dropout=0.9,\n                 color_output=False,\n                 num_layers=3, stroke_width=None):\n        super(ChainRNNVectorGenerator, self).__init__()\n        if stroke_width is None:\n            self.stroke_width = (0.5, 3.0)",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "Generator",
        "kind": 6,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "class Generator(BaseModel):\n    def __init__(self, width=64, imsize=32, zdim=128,\n                 stroke_width=None,\n                 color_output=False,\n                 num_strokes=4):\n        super(Generator, self).__init__()\n        assert imsize == 32\n        self.imsize = imsize\n        self.zdim = zdim\n        num_in_chans = self.zdim // (2*2)",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "Discriminator",
        "kind": 6,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "class Discriminator(th.nn.Module):\n    def __init__(self, conditional=False, width=64, color_output=False):\n        super(Discriminator, self).__init__()\n        self.conditional = conditional\n        sn = th.nn.utils.spectral_norm\n        num_chan_in = 3 if color_output else 1\n        self.net = th.nn.Sequential(\n            th.nn.Conv2d(num_chan_in, width, 3, padding=1),\n            th.nn.LeakyReLU(0.2, inplace=True),\n            th.nn.Conv2d(width, 2*width, 4, padding=1, stride=2),",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "apps.generative_models.models",
        "description": "apps.generative_models.models",
        "peekOfCode": "LOG = ttools.get_logger(__name__)\nclass BaseModel(th.nn.Module):\n    def sample_z(self, bs, device=\"cpu\"):\n        return th.randn(bs, self.zdim).to(device)\nclass BaseVectorModel(BaseModel):\n    def get_vector(self, z):\n        _, scenes = self._forward(z)\n        return scenes\n    def _forward(self, x):\n        raise NotImplementedError()",
        "detail": "apps.generative_models.models",
        "documentation": {}
    },
    {
        "label": "Flatten",
        "kind": 6,
        "importPath": "apps.generative_models.modules",
        "description": "apps.generative_models.modules",
        "peekOfCode": "class Flatten(th.nn.Module):\n    def __init__(self):\n        super(Flatten, self).__init__()\n    def forward(self, x):\n        bs = x.shape[0]\n        return x.view(bs, -1)",
        "detail": "apps.generative_models.modules",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "apps.generative_models.rendering",
        "description": "apps.generative_models.rendering",
        "peekOfCode": "def render(canvas_width, canvas_height, shapes, shape_groups, samples=2,\n           seed=None):\n    if seed is None:\n        seed = random.randint(0, 1000000)\n    _render = pydiffvg.RenderFunction.apply\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\n        canvas_width, canvas_height, shapes, shape_groups)\n    img = _render(canvas_width, canvas_height, samples, samples,\n                  seed,   # seed\n                  None,  # background image",
        "detail": "apps.generative_models.rendering",
        "documentation": {}
    },
    {
        "label": "opacityStroke2diffvg",
        "kind": 2,
        "importPath": "apps.generative_models.rendering",
        "description": "apps.generative_models.rendering",
        "peekOfCode": "def opacityStroke2diffvg(strokes, canvas_size=128, debug=False, relative=True,\n                         force_cpu=True):\n    dev = strokes.device\n    if force_cpu:\n        strokes = strokes.to(\"cpu\")\n    # pydiffvg.set_use_gpu(False)\n    # if strokes.is_cuda:\n    #     pydiffvg.set_use_gpu(True)\n    \"\"\"Rasterize strokes given in (dx, dy, opacity) sequence format.\"\"\"\n    bs, nsegs, dims = strokes.shape",
        "detail": "apps.generative_models.rendering",
        "documentation": {}
    },
    {
        "label": "stroke2diffvg",
        "kind": 2,
        "importPath": "apps.generative_models.rendering",
        "description": "apps.generative_models.rendering",
        "peekOfCode": "def stroke2diffvg(strokes, canvas_size=128):\n    \"\"\"Rasterize strokes given some sequential data.\"\"\"\n    bs, nsegs, dims = strokes.shape\n    out = []\n    for stroke_idx, stroke in enumerate(strokes):\n        end_of_stroke = stroke[:, 4] == 1\n        last = end_of_stroke.cpu().numpy().argmax()\n        stroke = stroke[:last+1, :]\n        # stroke = stroke[~end_of_stroke]\n        # TODO: stop at the first end of stroke",
        "detail": "apps.generative_models.rendering",
        "documentation": {}
    },
    {
        "label": "line_render",
        "kind": 2,
        "importPath": "apps.generative_models.rendering",
        "description": "apps.generative_models.rendering",
        "peekOfCode": "def line_render(all_points, all_widths, all_alphas, force_cpu=True,\n                canvas_size=32, colors=None):\n    dev = all_points.device\n    if force_cpu:\n        all_points = all_points.to(\"cpu\")\n        all_widths = all_widths.to(\"cpu\")\n        all_alphas = all_alphas.to(\"cpu\")\n        if colors is not None:\n            colors = colors.to(\"cpu\")\n    all_points = 0.5*(all_points + 1.0) * canvas_size",
        "detail": "apps.generative_models.rendering",
        "documentation": {}
    },
    {
        "label": "bezier_render",
        "kind": 2,
        "importPath": "apps.generative_models.rendering",
        "description": "apps.generative_models.rendering",
        "peekOfCode": "def bezier_render(all_points, all_widths, all_alphas, force_cpu=True,\n                  canvas_size=32, colors=None):\n    dev = all_points.device\n    if force_cpu:\n        all_points = all_points.to(\"cpu\")\n        all_widths = all_widths.to(\"cpu\")\n        all_alphas = all_alphas.to(\"cpu\")\n        if colors is not None:\n            colors = colors.to(\"cpu\")\n    all_points = 0.5*(all_points + 1.0) * canvas_size",
        "detail": "apps.generative_models.rendering",
        "documentation": {}
    },
    {
        "label": "SketchRNN",
        "kind": 6,
        "importPath": "apps.generative_models.sketch_rnn",
        "description": "apps.generative_models.sketch_rnn",
        "peekOfCode": "class SketchRNN(th.nn.Module):\n    class Encoder(th.nn.Module):\n        def __init__(self, hidden_size=512, dropout=0.9, zdim=128,\n                     num_layers=1):\n            super(SketchRNN.Encoder, self).__init__()\n            self.hidden_size = hidden_size\n            self.num_layers = num_layers\n            self.zdim = zdim\n            self.lstm = th.nn.LSTM(5, hidden_size, num_layers=self.num_layers,\n                                   dropout=dropout, bidirectional=True,",
        "detail": "apps.generative_models.sketch_rnn",
        "documentation": {}
    },
    {
        "label": "SketchRNNCallback",
        "kind": 6,
        "importPath": "apps.generative_models.sketch_rnn",
        "description": "apps.generative_models.sketch_rnn",
        "peekOfCode": "class SketchRNNCallback(ttools.callbacks.ImageDisplayCallback):\n    \"\"\"Simple callback that visualize images.\"\"\"\n    def visualized_image(self, batch, step_data, is_val=False):\n        if not is_val:\n            # No need to render training data\n            return None\n        with th.no_grad():\n            # only display the first n drawings\n            n = 8\n            batch = batch[:n]",
        "detail": "apps.generative_models.sketch_rnn",
        "documentation": {}
    },
    {
        "label": "Interface",
        "kind": 6,
        "importPath": "apps.generative_models.sketch_rnn",
        "description": "apps.generative_models.sketch_rnn",
        "peekOfCode": "class Interface(ttools.ModelInterface):\n    def __init__(self, model, lr=1e-3, lr_decay=0.9999,\n                 kl_weight=0.5, kl_min_weight=0.01, kl_decay=0.99995,\n                 device=\"cpu\", grad_clip=1.0, sampling_temperature=0.4):\n        super(Interface, self).__init__()\n        self.grad_clip = grad_clip\n        self.sampling_temperature = sampling_temperature\n        self.model = model\n        self.device = device\n        self.model.to(self.device)",
        "detail": "apps.generative_models.sketch_rnn",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "apps.generative_models.sketch_rnn",
        "description": "apps.generative_models.sketch_rnn",
        "peekOfCode": "def train(args):\n    th.manual_seed(0)\n    np.random.seed(0)\n    dataset = data.QuickDrawDataset(args.dataset)\n    dataloader = DataLoader(\n        dataset, batch_size=args.bs, num_workers=4, shuffle=True,\n        pin_memory=False)\n    val_dataset = [s for idx, s in enumerate(dataset) if idx < 8]\n    val_dataloader = DataLoader(\n        val_dataset, batch_size=8, num_workers=4, shuffle=False,",
        "detail": "apps.generative_models.sketch_rnn",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "apps.generative_models.sketch_rnn",
        "description": "apps.generative_models.sketch_rnn",
        "peekOfCode": "LOG = ttools.get_logger(__name__)\nBASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nOUTPUT = os.path.join(BASE_DIR, \"results\", \"sketch_rnn_diffvg\")\nOUTPUT_BASELINE = os.path.join(BASE_DIR, \"results\", \"sketch_rnn\")\nclass SketchRNN(th.nn.Module):\n    class Encoder(th.nn.Module):\n        def __init__(self, hidden_size=512, dropout=0.9, zdim=128,\n                     num_layers=1):\n            super(SketchRNN.Encoder, self).__init__()\n            self.hidden_size = hidden_size",
        "detail": "apps.generative_models.sketch_rnn",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "apps.generative_models.sketch_rnn",
        "description": "apps.generative_models.sketch_rnn",
        "peekOfCode": "BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nOUTPUT = os.path.join(BASE_DIR, \"results\", \"sketch_rnn_diffvg\")\nOUTPUT_BASELINE = os.path.join(BASE_DIR, \"results\", \"sketch_rnn\")\nclass SketchRNN(th.nn.Module):\n    class Encoder(th.nn.Module):\n        def __init__(self, hidden_size=512, dropout=0.9, zdim=128,\n                     num_layers=1):\n            super(SketchRNN.Encoder, self).__init__()\n            self.hidden_size = hidden_size\n            self.num_layers = num_layers",
        "detail": "apps.generative_models.sketch_rnn",
        "documentation": {}
    },
    {
        "label": "OUTPUT",
        "kind": 5,
        "importPath": "apps.generative_models.sketch_rnn",
        "description": "apps.generative_models.sketch_rnn",
        "peekOfCode": "OUTPUT = os.path.join(BASE_DIR, \"results\", \"sketch_rnn_diffvg\")\nOUTPUT_BASELINE = os.path.join(BASE_DIR, \"results\", \"sketch_rnn\")\nclass SketchRNN(th.nn.Module):\n    class Encoder(th.nn.Module):\n        def __init__(self, hidden_size=512, dropout=0.9, zdim=128,\n                     num_layers=1):\n            super(SketchRNN.Encoder, self).__init__()\n            self.hidden_size = hidden_size\n            self.num_layers = num_layers\n            self.zdim = zdim",
        "detail": "apps.generative_models.sketch_rnn",
        "documentation": {}
    },
    {
        "label": "OUTPUT_BASELINE",
        "kind": 5,
        "importPath": "apps.generative_models.sketch_rnn",
        "description": "apps.generative_models.sketch_rnn",
        "peekOfCode": "OUTPUT_BASELINE = os.path.join(BASE_DIR, \"results\", \"sketch_rnn\")\nclass SketchRNN(th.nn.Module):\n    class Encoder(th.nn.Module):\n        def __init__(self, hidden_size=512, dropout=0.9, zdim=128,\n                     num_layers=1):\n            super(SketchRNN.Encoder, self).__init__()\n            self.hidden_size = hidden_size\n            self.num_layers = num_layers\n            self.zdim = zdim\n            self.lstm = th.nn.LSTM(5, hidden_size, num_layers=self.num_layers,",
        "detail": "apps.generative_models.sketch_rnn",
        "documentation": {}
    },
    {
        "label": "SketchVAE",
        "kind": 6,
        "importPath": "apps.generative_models.sketch_vae",
        "description": "apps.generative_models.sketch_vae",
        "peekOfCode": "class SketchVAE(th.nn.Module):\n    class ImageEncoder(th.nn.Module):\n        def __init__(self, image_size=64, width=64, zdim=128):\n            super(SketchVAE.ImageEncoder, self).__init__()\n            self.zdim = zdim\n            self.net = th.nn.Sequential(\n                th.nn.Conv2d(4, width, 5, padding=2),\n                th.nn.InstanceNorm2d(width),\n                th.nn.ReLU(inplace=True),\n                # 64x64",
        "detail": "apps.generative_models.sketch_vae",
        "documentation": {}
    },
    {
        "label": "SketchVAECallback",
        "kind": 6,
        "importPath": "apps.generative_models.sketch_vae",
        "description": "apps.generative_models.sketch_vae",
        "peekOfCode": "class SketchVAECallback(ttools.callbacks.ImageDisplayCallback):\n    \"\"\"Simple callback that visualize images.\"\"\"\n    def visualized_image(self, batch, step_data, is_val=False):\n        if is_val:\n            return None\n        # only display the first n drawings\n        n = 8\n        gt = step_data[\"gt_image\"][:n].detach()\n        vae_im = step_data[\"vae_image\"][:n].detach()\n        sketch_im = step_data[\"sketch_image\"][:n].detach()",
        "detail": "apps.generative_models.sketch_vae",
        "documentation": {}
    },
    {
        "label": "Interface",
        "kind": 6,
        "importPath": "apps.generative_models.sketch_vae",
        "description": "apps.generative_models.sketch_vae",
        "peekOfCode": "class Interface(ttools.ModelInterface):\n    def __init__(self, model, lr=1e-4, lr_decay=0.9999,\n                 kl_weight=0.5, kl_min_weight=0.01, kl_decay=0.99995,\n                 raster_resolution=64, absolute_coords=False,\n                 device=\"cpu\", grad_clip=1.0):\n        super(Interface, self).__init__()\n        self.grad_clip = grad_clip\n        self.raster_resolution = raster_resolution\n        self.absolute_coords = absolute_coords\n        self.model = model",
        "detail": "apps.generative_models.sketch_vae",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "apps.generative_models.sketch_vae",
        "description": "apps.generative_models.sketch_vae",
        "peekOfCode": "def train(args):\n    th.manual_seed(0)\n    np.random.seed(0)\n    dataset = data.FixedLengthQuickDrawDataset(\n        args.dataset, max_seq_length=args.sequence_length,\n        canvas_size=args.raster_resolution)\n    dataloader = DataLoader(\n        dataset, batch_size=args.bs, num_workers=args.workers, shuffle=True)\n    # val_dataset = [s for idx, s in enumerate(dataset) if idx < 8]\n    # val_dataloader = DataLoader(",
        "detail": "apps.generative_models.sketch_vae",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "apps.generative_models.sketch_vae",
        "description": "apps.generative_models.sketch_vae",
        "peekOfCode": "LOG = ttools.get_logger(__name__)\nBASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nOUTPUT = os.path.join(BASE_DIR, \"results\")\nclass SketchVAE(th.nn.Module):\n    class ImageEncoder(th.nn.Module):\n        def __init__(self, image_size=64, width=64, zdim=128):\n            super(SketchVAE.ImageEncoder, self).__init__()\n            self.zdim = zdim\n            self.net = th.nn.Sequential(\n                th.nn.Conv2d(4, width, 5, padding=2),",
        "detail": "apps.generative_models.sketch_vae",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "apps.generative_models.sketch_vae",
        "description": "apps.generative_models.sketch_vae",
        "peekOfCode": "BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nOUTPUT = os.path.join(BASE_DIR, \"results\")\nclass SketchVAE(th.nn.Module):\n    class ImageEncoder(th.nn.Module):\n        def __init__(self, image_size=64, width=64, zdim=128):\n            super(SketchVAE.ImageEncoder, self).__init__()\n            self.zdim = zdim\n            self.net = th.nn.Sequential(\n                th.nn.Conv2d(4, width, 5, padding=2),\n                th.nn.InstanceNorm2d(width),",
        "detail": "apps.generative_models.sketch_vae",
        "documentation": {}
    },
    {
        "label": "OUTPUT",
        "kind": 5,
        "importPath": "apps.generative_models.sketch_vae",
        "description": "apps.generative_models.sketch_vae",
        "peekOfCode": "OUTPUT = os.path.join(BASE_DIR, \"results\")\nclass SketchVAE(th.nn.Module):\n    class ImageEncoder(th.nn.Module):\n        def __init__(self, image_size=64, width=64, zdim=128):\n            super(SketchVAE.ImageEncoder, self).__init__()\n            self.zdim = zdim\n            self.net = th.nn.Sequential(\n                th.nn.Conv2d(4, width, 5, padding=2),\n                th.nn.InstanceNorm2d(width),\n                th.nn.ReLU(inplace=True),",
        "detail": "apps.generative_models.sketch_vae",
        "documentation": {}
    },
    {
        "label": "Callback",
        "kind": 6,
        "importPath": "apps.generative_models.train_gan",
        "description": "apps.generative_models.train_gan",
        "peekOfCode": "class Callback(ttools.callbacks.ImageDisplayCallback):\n    \"\"\"Simple callback that visualize images.\"\"\"\n    def visualized_image(self, batch, step_data, is_val=False):\n        if is_val:\n            return\n        gen = step_data[\"gen_image\"][:16].detach()\n        ref = step_data[\"gt_image\"][:16].detach()\n        # tensor to visualize, concatenate images\n        vizdata = th.cat([ref, gen], 2)\n        vector = step_data[\"vector_image\"]",
        "detail": "apps.generative_models.train_gan",
        "documentation": {}
    },
    {
        "label": "Interface",
        "kind": 6,
        "importPath": "apps.generative_models.train_gan",
        "description": "apps.generative_models.train_gan",
        "peekOfCode": "class Interface(ttools.ModelInterface):\n    def __init__(self, generator, vect_generator,\n                 discriminator, vect_discriminator,\n                 lr=1e-4, lr_decay=0.9999,\n                 gradient_penalty=10,\n                 wgan_gp=False,\n                 raster_resolution=32, device=\"cpu\", grad_clip=1.0):\n        super(Interface, self).__init__()\n        self.wgan_gp = wgan_gp\n        self.w_gradient_penalty = gradient_penalty",
        "detail": "apps.generative_models.train_gan",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "apps.generative_models.train_gan",
        "description": "apps.generative_models.train_gan",
        "peekOfCode": "def train(args):\n    th.manual_seed(0)\n    np.random.seed(0)\n    color_output = False\n    if args.task == \"mnist\":\n        dataset = data.MNISTDataset(args.raster_resolution, train=True)\n    elif args.task == \"quickdraw\":\n        dataset = data.QuickDrawImageDataset(\n            args.raster_resolution, train=True)\n    else:",
        "detail": "apps.generative_models.train_gan",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "apps.generative_models.train_gan",
        "description": "apps.generative_models.train_gan",
        "peekOfCode": "LOG = ttools.get_logger(__name__)\nBASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nOUTPUT = os.path.join(BASE_DIR, \"results\")\nclass Callback(ttools.callbacks.ImageDisplayCallback):\n    \"\"\"Simple callback that visualize images.\"\"\"\n    def visualized_image(self, batch, step_data, is_val=False):\n        if is_val:\n            return\n        gen = step_data[\"gen_image\"][:16].detach()\n        ref = step_data[\"gt_image\"][:16].detach()",
        "detail": "apps.generative_models.train_gan",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "apps.generative_models.train_gan",
        "description": "apps.generative_models.train_gan",
        "peekOfCode": "BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)\nOUTPUT = os.path.join(BASE_DIR, \"results\")\nclass Callback(ttools.callbacks.ImageDisplayCallback):\n    \"\"\"Simple callback that visualize images.\"\"\"\n    def visualized_image(self, batch, step_data, is_val=False):\n        if is_val:\n            return\n        gen = step_data[\"gen_image\"][:16].detach()\n        ref = step_data[\"gt_image\"][:16].detach()\n        # tensor to visualize, concatenate images",
        "detail": "apps.generative_models.train_gan",
        "documentation": {}
    },
    {
        "label": "OUTPUT",
        "kind": 5,
        "importPath": "apps.generative_models.train_gan",
        "description": "apps.generative_models.train_gan",
        "peekOfCode": "OUTPUT = os.path.join(BASE_DIR, \"results\")\nclass Callback(ttools.callbacks.ImageDisplayCallback):\n    \"\"\"Simple callback that visualize images.\"\"\"\n    def visualized_image(self, batch, step_data, is_val=False):\n        if is_val:\n            return\n        gen = step_data[\"gen_image\"][:16].detach()\n        ref = step_data[\"gt_image\"][:16].detach()\n        # tensor to visualize, concatenate images\n        vizdata = th.cat([ref, gen], 2)",
        "detail": "apps.generative_models.train_gan",
        "documentation": {}
    },
    {
        "label": "make_gif",
        "kind": 2,
        "importPath": "apps.textureSyn.make_gif",
        "description": "apps.textureSyn.make_gif",
        "peekOfCode": "def make_gif(savePath, outputPath, frame_every_X_steps=15, repeat_ending=15, total_iter=200):\n    number_files = len(os.listdir(savePath)) - 2\n    frame_every_X_steps = frame_every_X_steps\n    repeat_ending = repeat_ending\n    steps = np.arange(floor(number_files / frame_every_X_steps)) * frame_every_X_steps\n    steps = steps + (number_files - np.max(steps))\n    images = []\n    for f in range(total_iter-1):\n    # for f in steps:\n        filename = savePath + 'iter_' + str(f+1) + '.png'",
        "detail": "apps.textureSyn.make_gif",
        "documentation": {}
    },
    {
        "label": "patchBasedTextureSynthesis",
        "kind": 6,
        "importPath": "apps.textureSyn.patchBasedTextureSynthesis",
        "description": "apps.textureSyn.patchBasedTextureSynthesis",
        "peekOfCode": "class patchBasedTextureSynthesis:\n    def __init__(self, exampleMapPath, in_outputPath, in_outputSize, in_patchSize, in_overlapSize, in_windowStep = 5, in_mirror_hor = True, in_mirror_vert = True, in_shapshots = True):\n        self.exampleMap = self.loadExampleMap(exampleMapPath)\n        self.snapshots = in_shapshots\n        self.outputPath = in_outputPath\n        self.outputSize = in_outputSize\n        self.patchSize = in_patchSize\n        self.overlapSize = in_overlapSize\n        self.mirror_hor = in_mirror_hor\n        self.mirror_vert = in_mirror_vert",
        "detail": "apps.textureSyn.patchBasedTextureSynthesis",
        "documentation": {}
    },
    {
        "label": "split_cubic",
        "kind": 2,
        "importPath": "apps.curve_subdivision",
        "description": "apps.curve_subdivision",
        "peekOfCode": "def split_cubic(c, t):\n    c0, c1 = svgpathtools.split_bezier(c, t)\n    return svgpathtools.CubicBezier(c0[0], c0[1], c0[2], c0[3]), svgpathtools.CubicBezier(c1[0], c1[1], c1[2], c1[3])\ndef cubic_to_quadratic(curve):\n    # Best L2 approximation\n    m = (-curve.start + 3 * curve.control1 + 3 * curve.control2 - curve.end) / 4.0\n    return svgpathtools.QuadraticBezier(curve.start, m, curve.end)\ndef convert_and_write_svg(cubic, filename):\n    cubic_path = svgpathtools.Path(cubic)\n    cubic_ctrl = svgpathtools.Path(svgpathtools.Line(cubic.start, cubic.control1),",
        "detail": "apps.curve_subdivision",
        "documentation": {}
    },
    {
        "label": "cubic_to_quadratic",
        "kind": 2,
        "importPath": "apps.curve_subdivision",
        "description": "apps.curve_subdivision",
        "peekOfCode": "def cubic_to_quadratic(curve):\n    # Best L2 approximation\n    m = (-curve.start + 3 * curve.control1 + 3 * curve.control2 - curve.end) / 4.0\n    return svgpathtools.QuadraticBezier(curve.start, m, curve.end)\ndef convert_and_write_svg(cubic, filename):\n    cubic_path = svgpathtools.Path(cubic)\n    cubic_ctrl = svgpathtools.Path(svgpathtools.Line(cubic.start, cubic.control1),\n                                   svgpathtools.Line(cubic.control1, cubic.control2),\n                                   svgpathtools.Line(cubic.control2, cubic.end))\n    cubic_color = (50, 50, 200)",
        "detail": "apps.curve_subdivision",
        "documentation": {}
    },
    {
        "label": "convert_and_write_svg",
        "kind": 2,
        "importPath": "apps.curve_subdivision",
        "description": "apps.curve_subdivision",
        "peekOfCode": "def convert_and_write_svg(cubic, filename):\n    cubic_path = svgpathtools.Path(cubic)\n    cubic_ctrl = svgpathtools.Path(svgpathtools.Line(cubic.start, cubic.control1),\n                                   svgpathtools.Line(cubic.control1, cubic.control2),\n                                   svgpathtools.Line(cubic.control2, cubic.end))\n    cubic_color = (50, 50, 200)\n    cubic_ctrl_color = (150, 150, 150)\n    r = 4.0\n    paths = [cubic_path, cubic_ctrl]\n    colors = [cubic_color, cubic_ctrl_color]",
        "detail": "apps.curve_subdivision",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "apps.finite_difference_comp",
        "description": "apps.finite_difference_comp",
        "peekOfCode": "def normalize(x, min_, max_):\n    range = max(abs(min_), abs(max_))\n    return (x + range) / (2 * range)\ndef main(args):\n    canvas_width, canvas_height, shapes, shape_groups = \\\n        pydiffvg.svg_to_scene(args.svg_file)\n    w = int(canvas_width * args.size_scale)\n    h = int(canvas_height * args.size_scale)\n    print(w, h)\n    curve_counts = 0",
        "detail": "apps.finite_difference_comp",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.finite_difference_comp",
        "description": "apps.finite_difference_comp",
        "peekOfCode": "def main(args):\n    canvas_width, canvas_height, shapes, shape_groups = \\\n        pydiffvg.svg_to_scene(args.svg_file)\n    w = int(canvas_width * args.size_scale)\n    h = int(canvas_height * args.size_scale)\n    print(w, h)\n    curve_counts = 0\n    for s in shapes:\n        if isinstance(s, pydiffvg.Circle):\n            curve_counts += 1",
        "detail": "apps.finite_difference_comp",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "apps.gaussian_blur",
        "description": "apps.gaussian_blur",
        "peekOfCode": "def render(canvas_width, canvas_height, shapes, shape_groups):\n    _render = pydiffvg.RenderFunction.apply\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)\n    img = _render(canvas_width, # width\n                 canvas_height, # height\n                 2,   # num_samples_x\n                 2,   # num_samples_y\n                 0,   # seed\n                 None,",
        "detail": "apps.gaussian_blur",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.gaussian_blur",
        "description": "apps.gaussian_blur",
        "peekOfCode": "def main():\n    pydiffvg.set_device(th.device('cuda:1'))\n    # Load SVG\n    svg = os.path.join(\"imgs\", \"peppers.svg\")\n    canvas_width, canvas_height, shapes, shape_groups = \\\n        pydiffvg.svg_to_scene(svg)\n    # Save initial state\n    ref = render(canvas_width, canvas_height, shapes, shape_groups)\n    pydiffvg.imwrite(ref.cpu(), 'results/gaussian_blur/init.png', gamma=2.2)\n    target = F.gaussian_filter(ref.cpu().numpy(), [10, 10, 0])",
        "detail": "apps.gaussian_blur",
        "documentation": {}
    },
    {
        "label": "GeometryLoss",
        "kind": 6,
        "importPath": "apps.geometry",
        "description": "apps.geometry",
        "peekOfCode": "class GeometryLoss:\n    def __init__(self, pathObj, xyalign=True, parallel=True, smooth_node=True):\n        self.pathObj=pathObj\n        self.pathId=pathObj.id\n        self.get_segments(pathObj)\n        if xyalign:\n            self.make_hor_ver_constraints(pathObj)\n        self.xyalign=xyalign\n        self.parallel=parallel\n        self.smooth_node=smooth_node",
        "detail": "apps.geometry",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "apps.image_compare",
        "description": "apps.image_compare",
        "peekOfCode": "def normalize(x, min_, max_):\n    return (x - min_) / (max_ - min_)\ndef main(args):\n    img1 = skimage.img_as_float(skimage.io.imread(args.img1)).astype(np.float32)\n    img2 = skimage.img_as_float(skimage.io.imread(args.img2)).astype(np.float32)\n    ref = skimage.img_as_float(skimage.io.imread(args.ref)).astype(np.float32)\n    img1 = img1[:, :, :3]\n    img2 = img2[:, :, :3]\n    ref = ref[:, :, :3]\n    diff1 = np.sum(np.abs(img1 - ref), axis = 2)",
        "detail": "apps.image_compare",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.image_compare",
        "description": "apps.image_compare",
        "peekOfCode": "def main(args):\n    img1 = skimage.img_as_float(skimage.io.imread(args.img1)).astype(np.float32)\n    img2 = skimage.img_as_float(skimage.io.imread(args.img2)).astype(np.float32)\n    ref = skimage.img_as_float(skimage.io.imread(args.ref)).astype(np.float32)\n    img1 = img1[:, :, :3]\n    img2 = img2[:, :, :3]\n    ref = ref[:, :, :3]\n    diff1 = np.sum(np.abs(img1 - ref), axis = 2)\n    diff2 = np.sum(np.abs(img2 - ref), axis = 2)\n    min_ = min(np.min(diff1), np.min(diff2))",
        "detail": "apps.image_compare",
        "documentation": {}
    },
    {
        "label": "canvas_width",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "canvas_width = 256\ncanvas_height = 256\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "canvas_height",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "canvas_height = 256\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "circle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "shapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,\n    shape_groups=shape_groups,\n    filter=pydiffvg.PixelFilter(type = diffvg.FilterType.hann,",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "circle_group",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "circle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,\n    shape_groups=shape_groups,\n    filter=pydiffvg.PixelFilter(type = diffvg.FilterType.hann,\n                                radius = torch.tensor(8.0)))",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "shape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,\n    shape_groups=shape_groups,\n    filter=pydiffvg.PixelFilter(type = diffvg.FilterType.hann,\n                                radius = torch.tensor(8.0)))\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,\n    shape_groups=shape_groups,\n    filter=pydiffvg.PixelFilter(type = diffvg.FilterType.hann,\n                                radius = torch.tensor(8.0)))\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/optimize_pixel_filter/target.png', gamma=2.2)",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/optimize_pixel_filter/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "target = img.clone()\n# Change the pixel filter radius\nradius = torch.tensor(1.0, requires_grad = True)\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,\n    shape_groups=shape_groups,\n    filter=pydiffvg.PixelFilter(type = diffvg.FilterType.hann,\n                                radius = radius))",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "radius",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "radius = torch.tensor(1.0, requires_grad = True)\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,\n    shape_groups=shape_groups,\n    filter=pydiffvg.PixelFilter(type = diffvg.FilterType.hann,\n                                radius = radius))\nimg = render(256, # width\n             256, # height",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,\n    shape_groups=shape_groups,\n    filter=pydiffvg.PixelFilter(type = diffvg.FilterType.hann,\n                                radius = radius))\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/optimize_pixel_filter/init.png', gamma=2.2)\n# Optimize for radius & center\noptimizer = torch.optim.Adam([radius], lr=1.0)",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "optimizer = torch.optim.Adam([radius], lr=1.0)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width=canvas_width,\n        canvas_height=canvas_height,\n        shapes=shapes,",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width=canvas_width,\n    canvas_height=canvas_height,\n    shapes=shapes,\n    shape_groups=shape_groups,\n    filter=pydiffvg.PixelFilter(type = diffvg.FilterType.hann,\n                                radius = radius))\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.optimize_pixel_filter",
        "description": "apps.optimize_pixel_filter",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None,\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/optimize_pixel_filter/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.optimize_pixel_filter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.painterly_rendering",
        "description": "apps.painterly_rendering",
        "peekOfCode": "def main(args):\n    # Use GPU if available\n    pydiffvg.set_use_gpu(torch.cuda.is_available())\n    perception_loss = ttools.modules.LPIPS().to(pydiffvg.get_device())\n    #target = torch.from_numpy(skimage.io.imread('imgs/lena.png')).to(torch.float32) / 255.0\n    target = torch.from_numpy(skimage.io.imread(args.target)).to(torch.float32) / 255.0\n    target = target.pow(gamma)\n    target = target.to(pydiffvg.get_device())\n    target = target.unsqueeze(0)\n    target = target.permute(0, 3, 1, 2) # NHWC -> NCHW",
        "detail": "apps.painterly_rendering",
        "documentation": {}
    },
    {
        "label": "gamma",
        "kind": 5,
        "importPath": "apps.painterly_rendering",
        "description": "apps.painterly_rendering",
        "peekOfCode": "gamma = 1.0\ndef main(args):\n    # Use GPU if available\n    pydiffvg.set_use_gpu(torch.cuda.is_available())\n    perception_loss = ttools.modules.LPIPS().to(pydiffvg.get_device())\n    #target = torch.from_numpy(skimage.io.imread('imgs/lena.png')).to(torch.float32) / 255.0\n    target = torch.from_numpy(skimage.io.imread(args.target)).to(torch.float32) / 255.0\n    target = target.pow(gamma)\n    target = target.to(pydiffvg.get_device())\n    target = target.unsqueeze(0)",
        "detail": "apps.painterly_rendering",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "num_control_points = torch.tensor([1])\npoints = torch.tensor([[ 50.0,  30.0], # base\n                       [125.0, 400.0], # control point\n                       [170.0,  30.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     stroke_width = torch.tensor([30.0]),\n                     is_closed = False,\n                     use_distance_approx = False)\nshapes = [path]",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "points = torch.tensor([[ 50.0,  30.0], # base\n                       [125.0, 400.0], # control point\n                       [170.0,  30.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     stroke_width = torch.tensor([30.0]),\n                     is_closed = False,\n                     use_distance_approx = False)\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     stroke_width = torch.tensor([30.0]),\n                     is_closed = False,\n                     use_distance_approx = False)\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.5, 0.5, 0.5, 0.5]))\nshape_groups = [path_group]",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.5, 0.5, 0.5, 0.5]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.5, 0.5, 0.5, 0.5]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg /= 256.0\ncm = plt.get_cmap('viridis')",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg /= 256.0\ncm = plt.get_cmap('viridis')\nimg = cm(img.squeeze())",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "cm",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "cm = plt.get_cmap('viridis')\nimg = cm(img.squeeze())\npydiffvg.imwrite(img, 'results/quadratic_distance_approx/ref_sdf.png')\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "img = cm(img.squeeze())\npydiffvg.imwrite(img, 'results/quadratic_distance_approx/ref_sdf.png')\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img, 'results/quadratic_distance_approx/ref_color.png')",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img, 'results/quadratic_distance_approx/ref_color.png')\nshapes[0].use_distance_approx = True\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "shapes[0].use_distance_approx",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "shapes[0].use_distance_approx = True\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg /= 256.0\nimg = cm(img.squeeze())\npydiffvg.imwrite(img, 'results/quadratic_distance_approx/approx_sdf.png')",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "img = cm(img.squeeze())\npydiffvg.imwrite(img, 'results/quadratic_distance_approx/approx_sdf.png')\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img, 'results/quadratic_distance_approx/approx_color.png')",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.quadratic_distance_approx",
        "description": "apps.quadratic_distance_approx",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img, 'results/quadratic_distance_approx/approx_color.png')",
        "detail": "apps.quadratic_distance_approx",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.refine_svg",
        "description": "apps.refine_svg",
        "peekOfCode": "def main(args):\n    perception_loss = ttools.modules.LPIPS().to(pydiffvg.get_device())\n    target = torch.from_numpy(skimage.io.imread(args.target)).to(torch.float32) / 255.0\n    target = target.pow(gamma)\n    target = target.to(pydiffvg.get_device())\n    target = target.unsqueeze(0)\n    target = target.permute(0, 3, 1, 2) # NHWC -> NCHW\n    canvas_width, canvas_height, shapes, shape_groups = \\\n        pydiffvg.svg_to_scene(args.svg)\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.refine_svg",
        "documentation": {}
    },
    {
        "label": "gamma",
        "kind": 5,
        "importPath": "apps.refine_svg",
        "description": "apps.refine_svg",
        "peekOfCode": "gamma = 1.0\ndef main(args):\n    perception_loss = ttools.modules.LPIPS().to(pydiffvg.get_device())\n    target = torch.from_numpy(skimage.io.imread(args.target)).to(torch.float32) / 255.0\n    target = target.pow(gamma)\n    target = target.to(pydiffvg.get_device())\n    target = target.unsqueeze(0)\n    target = target.permute(0, 3, 1, 2) # NHWC -> NCHW\n    canvas_width, canvas_height, shapes, shape_groups = \\\n        pydiffvg.svg_to_scene(args.svg)",
        "detail": "apps.refine_svg",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "apps.render_svg",
        "description": "apps.render_svg",
        "peekOfCode": "def render(canvas_width, canvas_height, shapes, shape_groups):\n    _render = pydiffvg.RenderFunction.apply\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)\n    img = _render(canvas_width, # width\n                 canvas_height, # height\n                 2,   # num_samples_x\n                 2,   # num_samples_y\n                 0,   # seed\n                 None,",
        "detail": "apps.render_svg",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.render_svg",
        "description": "apps.render_svg",
        "peekOfCode": "def main(args):\n    pydiffvg.set_device(th.device('cuda:1'))\n    # Load SVG\n    svg = os.path.join(args.svg)\n    canvas_width, canvas_height, shapes, shape_groups = \\\n        pydiffvg.svg_to_scene(svg)\n    # Save initial state\n    ref = render(canvas_width, canvas_height, shapes, shape_groups)\n    pydiffvg.imwrite(ref.cpu(), args.out, gamma=2.2)\nif __name__ == \"__main__\":",
        "detail": "apps.render_svg",
        "documentation": {}
    },
    {
        "label": "energy",
        "kind": 2,
        "importPath": "apps.seam_carving",
        "description": "apps.seam_carving",
        "peekOfCode": "def energy(im):\n    \"\"\"Compute image energy.\n    Args:\n        im(np.ndarray) with shape [h, w, 3]: input image.\n    Returns:\n        (np.ndarray) with shape [h, w]: energy map.\n    \"\"\"\n    f_dx = np.array([\n        [-1, 0, 1 ],\n        [-2, 0, 2 ],",
        "detail": "apps.seam_carving",
        "documentation": {}
    },
    {
        "label": "min_seam",
        "kind": 2,
        "importPath": "apps.seam_carving",
        "description": "apps.seam_carving",
        "peekOfCode": "def min_seam(e):\n    \"\"\"Finds the seam with minimal cost in an energy map.\n    Args:\n        e(np.ndarray) with shape [h, w]: energy map.\n    Returns:\n        min_e(np.ndarray) with shape [h, w]: for all (y,x) min_e[y, x]\n            is the cost of the minimal seam from 0 to y (top to bottom).\n            The minimal seam can be found by looking at the last row of min_e.\n            This is computed by dynamic programming.\n        argmin_e(np.ndarray) with shape [h, w]: for all (y,x) argmin_e[y, x]",
        "detail": "apps.seam_carving",
        "documentation": {}
    },
    {
        "label": "carve_seam",
        "kind": 2,
        "importPath": "apps.seam_carving",
        "description": "apps.seam_carving",
        "peekOfCode": "def carve_seam(im):\n    \"\"\"Carves a vertical seam in an image, reducing it's horizontal size by 1.\n    Args:\n        im(np.ndarray) with shape [h, w, 3]: input image.\n    Returns:\n        (np.ndarray) with shape [h, w-1, 1]: the image with one seam removed.\n    \"\"\"\n    e = energy(im)\n    min_e, argmin_e = min_seam(e)\n    h, w =  im.shape[:2]",
        "detail": "apps.seam_carving",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "apps.seam_carving",
        "description": "apps.seam_carving",
        "peekOfCode": "def render(canvas_width, canvas_height, shapes, shape_groups, samples=2):\n    _render = pydiffvg.RenderFunction.apply\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)\n    img = _render(canvas_width, # width\n                 canvas_height, # height\n                 samples,   # num_samples_x\n                 samples,   # num_samples_y\n                 0,   # seed\n                 None,",
        "detail": "apps.seam_carving",
        "documentation": {}
    },
    {
        "label": "vector_rescale",
        "kind": 2,
        "importPath": "apps.seam_carving",
        "description": "apps.seam_carving",
        "peekOfCode": "def vector_rescale(shapes, scale_x=1.00, scale_y=1.00):\n    new_shapes = []\n    for path in shapes:\n        path.points[..., 0] *= scale_x\n        path.points[..., 1] *= scale_y\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--svg\", default=os.path.join(\"imgs\", \"hokusai.svg\"))\n    parser.add_argument(\"--optim_steps\", default=10, type=int)\n    parser.add_argument(\"--lr\", default=1e-1, type=int)",
        "detail": "apps.seam_carving",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.seam_carving",
        "description": "apps.seam_carving",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--svg\", default=os.path.join(\"imgs\", \"hokusai.svg\"))\n    parser.add_argument(\"--optim_steps\", default=10, type=int)\n    parser.add_argument(\"--lr\", default=1e-1, type=int)\n    args = parser.parse_args()\n    name = os.path.splitext(os.path.basename(args.svg))[0]\n    root = os.path.join(\"results\", \"seam_carving\", name)\n    svg_root = os.path.join(root, \"svg\")\n    os.makedirs(root, exist_ok=True)",
        "detail": "apps.seam_carving",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "apps.shared_edge_compare",
        "description": "apps.shared_edge_compare",
        "peekOfCode": "def normalize(x, min_, max_):\n    range = max(abs(min_), abs(max_))\n    return (x + range) / (2 * range)\ndef main(args):\n    canvas_width, canvas_height, shapes, shape_groups = \\\n        pydiffvg.svg_to_scene(args.svg_file)\n    w = int(canvas_width * args.size_scale)\n    h = int(canvas_height * args.size_scale)\n    pfilter = pydiffvg.PixelFilter(type = diffvg.FilterType.box,\n                                   radius = torch.tensor(0.5))",
        "detail": "apps.shared_edge_compare",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.shared_edge_compare",
        "description": "apps.shared_edge_compare",
        "peekOfCode": "def main(args):\n    canvas_width, canvas_height, shapes, shape_groups = \\\n        pydiffvg.svg_to_scene(args.svg_file)\n    w = int(canvas_width * args.size_scale)\n    h = int(canvas_height * args.size_scale)\n    pfilter = pydiffvg.PixelFilter(type = diffvg.FilterType.box,\n                                   radius = torch.tensor(0.5))\n    use_prefiltering = False\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups,",
        "detail": "apps.shared_edge_compare",
        "documentation": {}
    },
    {
        "label": "GaussianSmoothing",
        "kind": 6,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "class GaussianSmoothing(nn.Module):\n    \"\"\"\n    Apply gaussian smoothing on a\n    1d, 2d or 3d tensor. Filtering is performed seperately for each channel\n    in the input using a depthwise convolution.\n    Arguments:\n        channels (int, sequence): Number of channels of the input tensors. Output will\n            have this number of channels as well.\n        kernel_size (int, sequence): Size of the gaussian kernel.\n        sigma (float, sequence): Standard deviation of the gaussian kernel.",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "inv_exp",
        "kind": 2,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "def inv_exp(a,x,xpow=1):\n    return pow(a,pow(1.-x,xpow))\nimport math\nimport numbers\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nimport visdom\nclass GaussianSmoothing(nn.Module):\n    \"\"\"",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "smooth",
        "kind": 2,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "def smooth(input, kernel):\n    input=torch.nn.functional.pad(input.permute(2,0,1).unsqueeze(0), (2, 2, 2, 2), mode='reflect')\n    output=kernel(input)\n    return output\ndef printimg(optim):\n    img=optim.render()\n    comp = img.clone().detach()\n    bg = torch.tensor([[[1., 1., 1.]]])\n    comprgb = comp[:, :, 0:3]\n    compalpha = comp[:, :, 3].unsqueeze(2)",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "printimg",
        "kind": 2,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "def printimg(optim):\n    img=optim.render()\n    comp = img.clone().detach()\n    bg = torch.tensor([[[1., 1., 1.]]])\n    comprgb = comp[:, :, 0:3]\n    compalpha = comp[:, :, 3].unsqueeze(2)\n    comp = comprgb * compalpha \\\n           + bg * (1 - compalpha)\n    return comp\ndef comp_loss_and_grad(img, tgt, it, sz):",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "comp_loss_and_grad",
        "kind": 2,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "def comp_loss_and_grad(img, tgt, it, sz):\n    dif=img-tgt\n    loss=dif.pow(2).mean()\n    dif=dif.detach()\n    cdif=dif.clone().abs()\n    cdif[:,:,3]=1.\n    resdif=torch.nn.functional.interpolate(cdif.permute(2,0,1).unsqueeze(0),sz,mode='bilinear').squeeze().permute(1,2,0).abs()\n    pydiffvg.imwrite(resdif[:,:,0:4], 'results/simple_transform_svg/dif_{:04}.png'.format(it))\n    dif=dif.numpy()\n    padded=np.pad(dif,[(1,1),(1,1),(0,0)],mode='edge')",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "print_gradimg",
        "kind": 2,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "def print_gradimg(gradimg,it,shape=None):\n    out=torch.zeros((gradimg.shape[0],gradimg.shape[1],3),requires_grad=False,dtype=torch.float32)\n    for x in range(gradimg.shape[0]):\n        for y in range(gradimg.shape[1]):\n            h=math.atan2(gradimg[x,y,1],gradimg[x,y,0])\n            s=math.tanh(np.linalg.norm(gradimg[x,y,:]))\n            v=1.\n            vec=(gradimg[x,y,:].clip(min=-1,max=1)/2)+.5\n            #out[x,y,:]=torch.tensor(colorsys.hsv_to_rgb(h,s,v),dtype=torch.float32)\n            out[x,y,:]=torch.tensor([vec[0],vec[1],0])",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "smoothing",
        "kind": 5,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "smoothing = GaussianSmoothing(4, 5, 1)\nsettings=pydiffvg.SvgOptimizationSettings()\nsettings.global_override([\"optimize_color\"],False)\nsettings.global_override([\"optimize_alpha\"],False)\nsettings.global_override([\"gradients\",\"optimize_color\"],False)\nsettings.global_override([\"gradients\",\"optimize_alpha\"],False)\nsettings.global_override([\"gradients\",\"optimize_stops\"],False)\nsettings.global_override([\"gradients\",\"optimize_location\"],False)\nsettings.global_override([\"optimizer\"],\"Adam\")\nsettings.global_override([\"paths\",\"optimize_points\"],False)",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "target = img.clone().detach().requires_grad_(False)\nimg=optim.render()\npydiffvg.imwrite(img.cpu(), 'results/simple_transform_svg/init.png')\ndef smooth(input, kernel):\n    input=torch.nn.functional.pad(input.permute(2,0,1).unsqueeze(0), (2, 2, 2, 2), mode='reflect')\n    output=kernel(input)\n    return output\ndef printimg(optim):\n    img=optim.render()\n    comp = img.clone().detach()",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.simple_transform_svg",
        "description": "apps.simple_transform_svg",
        "peekOfCode": "img = optim.render()\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/simple_transform_svg/final.png')\nwith open('results/simple_transform_svg/final.svg', \"w\") as f:\n    f.write(optim.write_xml())\n# Convert the intermediate renderings to a video.\nfrom subprocess import call\ncall([\"ffmpeg\", \"-framerate\", \"24\", \"-i\",\n    \"results/simple_transform_svg/iter_%04d.png\", \"-vb\", \"20M\",\n    \"results/simple_transform_svg/out.mp4\"])",
        "detail": "apps.simple_transform_svg",
        "documentation": {}
    },
    {
        "label": "canvas_width",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "canvas_width = 256\ncanvas_height = 256\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "canvas_height",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "canvas_height = 256\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "circle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "shapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "circle_group",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "circle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "shape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_circle/target.png', gamma=2.2)",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_circle/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "target = img.clone()\n# Move the circle to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "radius_n",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "radius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "center_n",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "center_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "circle.radius",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "circle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "circle.center",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "circle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "circle_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "circle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_circle/init.png', gamma=2.2)",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_circle/init.png', gamma=2.2)\n# Optimize for radius & center\noptimizer = torch.optim.Adam([radius_n, center_n, color], lr=1e-2)",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "optimizer = torch.optim.Adam([radius_n, center_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    circle.radius = radius_n * 256\n    circle.center = center_n * 256\n    circle_group.fill_color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None,\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle",
        "description": "apps.single_circle",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None,\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_circle/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_circle",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "circle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]),\n                         stroke_width = torch.tensor(5.0))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n    stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "shapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n    stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "circle_group",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "circle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n    stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "shape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_circle_outline/target.png', gamma=2.2)",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_circle_outline/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "target = img.clone()\n# Move the circle to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\nfill_color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "radius_n",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "radius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\nfill_color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle.stroke_width = stroke_width_n * 100\ncircle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "center_n",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "center_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\nfill_color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle.stroke_width = stroke_width_n * 100\ncircle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "fill_color",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "fill_color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle.stroke_width = stroke_width_n * 100\ncircle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "stroke_color",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "stroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle.stroke_width = stroke_width_n * 100\ncircle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "stroke_width_n",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "stroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle.stroke_width = stroke_width_n * 100\ncircle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "circle.radius",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "circle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle.stroke_width = stroke_width_n * 100\ncircle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "circle.center",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "circle.center = center_n * 256\ncircle.stroke_width = stroke_width_n * 100\ncircle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "circle.stroke_width",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "circle.stroke_width = stroke_width_n * 100\ncircle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "circle_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "circle_group.fill_color = fill_color\ncircle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "circle_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "circle_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_circle_outline/init.png', gamma=2.2)",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_circle_outline/init.png', gamma=2.2)\n# Optimize for radius & center\noptimizer = torch.optim.Adam([radius_n, center_n, fill_color, stroke_color, stroke_width_n], lr=1e-2)",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "optimizer = torch.optim.Adam([radius_n, center_n, fill_color, stroke_color, stroke_width_n], lr=1e-2)\n# Run 200 Adam iterations.\nfor t in range(200):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    circle.radius = radius_n * 256\n    circle.center = center_n * 256\n    circle.stroke_width = stroke_width_n * 100\n    circle_group.fill_color = fill_color",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None,\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_outline",
        "description": "apps.single_circle_outline",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None,\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_circle_outline/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_circle_outline",
        "documentation": {}
    },
    {
        "label": "canvas_width",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "canvas_width = 256\ncanvas_height = 256\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "canvas_height",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "canvas_height = 256\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "circle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "shapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "circle_group",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "circle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "shape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\nimg = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_circle_sdf/target.png')",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\nimg = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_circle_sdf/target.png')\ntarget = img.clone()",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "img = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_circle_sdf/target.png')\ntarget = img.clone()\n# Move the circle to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "target = img.clone()\n# Move the circle to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "radius_n",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "radius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "center_n",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "center_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "circle.radius",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "circle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "circle.center",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "circle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "circle_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "circle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)\nimg = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_circle_sdf/init.png')\n# Optimize for radius & center",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "img = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_circle_sdf/init.png')\n# Optimize for radius & center\noptimizer = torch.optim.Adam([radius_n, center_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    circle.radius = radius_n * 256",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "optimizer = torch.optim.Adam([radius_n, center_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    circle.radius = radius_n * 256\n    circle.center = center_n * 256\n    circle_group.fill_color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None,\n             *scene_args)",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None,\n             *scene_args)\nimg = img / 256 # Normalize SDF to [0, 1]\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_circle_sdf/final.png')",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_sdf",
        "description": "apps.single_circle_sdf",
        "peekOfCode": "img = img / 256 # Normalize SDF to [0, 1]\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_circle_sdf/final.png')\n# Convert the intermediate renderings to a video.\nfrom subprocess import call\ncall([\"ffmpeg\", \"-framerate\", \"24\", \"-i\",\n    \"results/single_circle_sdf/iter_%d.png\", \"-vb\", \"20M\",\n    \"results/single_circle_sdf/out.mp4\"])",
        "detail": "apps.single_circle_sdf",
        "documentation": {}
    },
    {
        "label": "canvas_width",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "canvas_width = 256\ncanvas_height = 256\ncircle = pydiffvg.Circle(radius = tf.constant(40.0),\n                         center = tf.constant([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = tf.constant([0], dtype = tf.int32),\n    fill_color = tf.constant([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "canvas_height",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "canvas_height = 256\ncircle = pydiffvg.Circle(radius = tf.constant(40.0),\n                         center = tf.constant([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = tf.constant([0], dtype = tf.int32),\n    fill_color = tf.constant([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "circle = pydiffvg.Circle(radius = tf.constant(40.0),\n                         center = tf.constant([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = tf.constant([0], dtype = tf.int32),\n    fill_color = tf.constant([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "shapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = tf.constant([0], dtype = tf.int32),\n    fill_color = tf.constant([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "circle_group",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "circle_group = pydiffvg.ShapeGroup(shape_ids = tf.constant([0], dtype = tf.int32),\n    fill_color = tf.constant([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "shape_groups = [circle_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "render = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img, 'results/single_circle_tf/target.png', gamma=2.2)\ntarget = tf.identity(img)",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img, 'results/single_circle_tf/target.png', gamma=2.2)\ntarget = tf.identity(img)\n# Move the circle to produce initial guess",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "target = tf.identity(img)\n# Move the circle to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = tf.Variable(20.0 / 256.0)\ncenter_n = tf.Variable([108.0 / 256.0, 138.0 / 256.0])\ncolor = tf.Variable([0.3, 0.2, 0.8, 1.0])\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "radius_n",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "radius_n = tf.Variable(20.0 / 256.0)\ncenter_n = tf.Variable([108.0 / 256.0, 138.0 / 256.0])\ncolor = tf.Variable([0.3, 0.2, 0.8, 1.0])\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "center_n",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "center_n = tf.Variable([108.0 / 256.0, 138.0 / 256.0])\ncolor = tf.Variable([0.3, 0.2, 0.8, 1.0])\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "color = tf.Variable([0.3, 0.2, 0.8, 1.0])\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "circle.radius",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "circle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "circle.center",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "circle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "circle_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "circle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_circle_tf/init.png', gamma=2.2)",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_circle_tf/init.png', gamma=2.2)\noptimizer = tf.compat.v1.train.AdamOptimizer(1e-2)",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_circle_tf/init.png', gamma=2.2)\noptimizer = tf.compat.v1.train.AdamOptimizer(1e-2)\nfor t in range(100):\n    print('iteration:', t)",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "optimizer = tf.compat.v1.train.AdamOptimizer(1e-2)\nfor t in range(100):\n    print('iteration:', t)\n    with tf.GradientTape() as tape:\n        # Forward pass: render the image.\n        circle.radius = radius_n * 256\n        circle.center = center_n * 256\n        circle_group.fill_color = color\n        # Important to use a different seed every iteration, otherwise the result\n        # would be biased.",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "circle.radius",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "circle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "circle.center",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "circle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "circle_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "circle_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_circle_tf/final.png')",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_circle_tf",
        "description": "apps.single_circle_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_circle_tf/final.png')\n# Convert the intermediate renderings to a video.\nfrom subprocess import call",
        "detail": "apps.single_circle_tf",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "num_control_points = torch.tensor([2, 2, 2])\npoints = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0], # base\n                       [ 90.0, 180.0], # control point\n                       [200.0,  65.0], # control point\n                       [210.0,  98.0], # base\n                       [220.0,  70.0], # control point\n                       [130.0,  55.0]]) # control point",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "points = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0], # base\n                       [ 90.0, 180.0], # control point\n                       [200.0,  65.0], # control point\n                       [210.0,  98.0], # base\n                       [220.0,  70.0], # control point\n                       [130.0,  55.0]]) # control point\npath = pydiffvg.Path(num_control_points = num_control_points,",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = True)\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_curve/target.png', gamma=2.2)",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None,\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_curve/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "target = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\npoints_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0], # base\n                         [100.0/256.0, 200.0/256.0], # control point\n                         [170.0/256.0,  55.0/256.0], # control point\n                         [220.0/256.0, 100.0/256.0], # base",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "points_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0], # base\n                         [100.0/256.0, 200.0/256.0], # control point\n                         [170.0/256.0,  55.0/256.0], # control point\n                         [220.0/256.0, 100.0/256.0], # base\n                         [210.0/256.0,  80.0/256.0], # control point\n                         [140.0/256.0,  60.0/256.0]], # control point\n                        requires_grad = True) ",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\npath.points = points_n * 256\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "path.points = points_n * 256\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "path_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_curve/init.png', gamma=2.2)",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None,\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_curve/init.png', gamma=2.2)\n# Optimize\noptimizer = torch.optim.Adam([points_n, color], lr=1e-2)",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    path.points = points_n * 256\n    path_group.fill_color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None,\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve",
        "description": "apps.single_curve",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None,\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_curve/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_curve",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "num_control_points = torch.tensor([2, 2, 2])\npoints = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0], # base\n                       [ 90.0, 180.0], # control point\n                       [200.0,  65.0], # control point\n                       [210.0,  98.0], # base\n                       [220.0,  70.0], # control point\n                       [130.0,  55.0]]) # control point",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "points = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0], # base\n                       [ 90.0, 180.0], # control point\n                       [200.0,  65.0], # control point\n                       [210.0,  98.0], # base\n                       [220.0,  70.0], # control point\n                       [130.0,  55.0]]) # control point\npath = pydiffvg.Path(num_control_points = num_control_points,",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = True,\n                     stroke_width = torch.tensor(5.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_curve_outline/target.png', gamma=2.2)",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_curve_outline/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "target = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\npoints_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0], # base\n                         [100.0/256.0, 200.0/256.0], # control point\n                         [170.0/256.0,  55.0/256.0], # control point\n                         [220.0/256.0, 100.0/256.0], # base",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "points_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0], # base\n                         [100.0/256.0, 200.0/256.0], # control point\n                         [170.0/256.0,  55.0/256.0], # control point\n                         [220.0/256.0, 100.0/256.0], # base\n                         [210.0/256.0,  80.0/256.0], # control point\n                         [140.0/256.0,  60.0/256.0]], # control point\n                        requires_grad = True) ",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "fill_color",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "fill_color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "stroke_color",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "stroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "stroke_width_n",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "stroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path.stroke_width = stroke_width_n * 100\npath_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_curve_outline/init.png', gamma=2.2)",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_curve_outline/init.png', gamma=2.2)\n# Optimize\noptimizer = torch.optim.Adam([points_n, fill_color, stroke_color, stroke_width_n], lr=1e-2)",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, fill_color, stroke_color, stroke_width_n], lr=1e-2)\n# Run 200 Adam iterations.\nfor t in range(200):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    path.points = points_n * 256\n    path.stroke_width = stroke_width_n * 100\n    path_group.fill_color = fill_color\n    path_group.stroke_color = stroke_color",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path.stroke_width = stroke_width_n * 100\npath_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path_group.fill_color = fill_color\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_outline",
        "description": "apps.single_curve_outline",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_curve_outline/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_curve_outline",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "num_control_points = torch.tensor([2, 2, 2])\npoints = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0], # base\n                       [ 90.0, 180.0], # control point\n                       [200.0,  65.0], # control point\n                       [210.0,  98.0], # base\n                       [220.0,  70.0], # control point\n                       [130.0,  55.0]]) # control point",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "points = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0], # base\n                       [ 90.0, 180.0], # control point\n                       [200.0,  65.0], # control point\n                       [210.0,  98.0], # base\n                       [220.0,  70.0], # control point\n                       [130.0,  55.0]]) # control point\npath = pydiffvg.Path(num_control_points = num_control_points,",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = True)\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg /= 256.0\n# The output image is in linear RGB space. Do Gamma correction before saving the image.",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg /= 256.0\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_curve_sdf/target.png', gamma=1.0)",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "target = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\npoints_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0], # base\n                         [100.0/256.0, 200.0/256.0], # control point\n                         [170.0/256.0,  55.0/256.0], # control point\n                         [220.0/256.0, 100.0/256.0], # base",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "points_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0], # base\n                         [100.0/256.0, 200.0/256.0], # control point\n                         [170.0/256.0,  55.0/256.0], # control point\n                         [220.0/256.0, 100.0/256.0], # base\n                         [210.0/256.0,  80.0/256.0], # control point\n                         [140.0/256.0,  60.0/256.0]], # control point\n                        requires_grad = True) ",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\npath.points = points_n * 256\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "path.points = points_n * 256\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "path_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\nimg /= 256.0\npydiffvg.imwrite(img.cpu(), 'results/single_curve_sdf/init.png', gamma=1.0)\n# Optimize",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    path.points = points_n * 256\n    path_group.fill_color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups,",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256,   # width\n             256,   # height\n             1,     # num_samples_x\n             1,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_sdf",
        "description": "apps.single_curve_sdf",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             1,     # num_samples_x\n             1,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\nimg /= 256.0\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_curve_sdf/final.png', gamma=1.0)",
        "detail": "apps.single_curve_sdf",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "num_control_points = torch.tensor([2])\n# points = torch.tensor([[120.0,  30.0], # base\n#                        [150.0,  60.0], # control point\n#                        [ 90.0, 198.0], # control point\n#                        [ 60.0, 218.0], # base\n#                        [ 90.0, 180.0], # control point\n#                        [200.0,  65.0], # control point\n#                        [210.0,  98.0], # base\n#                        [220.0,  70.0], # control point\n#                        [130.0,  55.0]]) # control point",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "points = torch.tensor([[ 20.0, 128.0], # base\n                       [ 50.0, 128.0], # control point\n                       [170.0, 128.0], # control point\n                       [200.0, 128.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = torch.tensor(10.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = torch.tensor(10.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\npath.points[:, 1] += 1e-3\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\npath.points[:, 1] += 1e-3\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg2 = render(256, # width\n              256, # height\n              1,   # num_samples_x\n              1,   # num_samples_y\n              0,   # seed\n              None, # background_image\n              *scene_args)",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "img2",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "img2 = render(256, # width\n              256, # height\n              1,   # num_samples_x\n              1,   # num_samples_y\n              0,   # seed\n              None, # background_image\n              *scene_args)\n# diff = img2 - img\n# diff = diff[:, :, 0] / 1e-3\n# import matplotlib.pyplot as plt",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "render_grad",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "render_grad = pydiffvg.RenderFunction.render_grad\nimg = render_grad(torch.ones(256, 256, 1), # grad_img\n                  256, # width\n                  256, # height\n                  1,   # num_samples_x\n                  1,   # num_samples_y\n                  0,   # seed\n                  None, # background_image\n                  *scene_args)\nimg = img[:, :, 0]",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "img = render_grad(torch.ones(256, 256, 1), # grad_img\n                  256, # width\n                  256, # height\n                  1,   # num_samples_x\n                  1,   # num_samples_y\n                  0,   # seed\n                  None, # background_image\n                  *scene_args)\nimg = img[:, :, 0]\nimport matplotlib.pyplot as plt",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_sdf_trans",
        "description": "apps.single_curve_sdf_trans",
        "peekOfCode": "img = img[:, :, 0]\nimport matplotlib.pyplot as plt\nplt.imshow(img)\nplt.show()\n# # Move the path to produce initial guess\n# # normalize points for easier learning rate\n# # points_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n# #                          [155.0/256.0,  65.0/256.0], # control point\n# #                          [100.0/256.0, 180.0/256.0], # control point\n# #                          [ 65.0/256.0, 238.0/256.0], # base",
        "detail": "apps.single_curve_sdf_trans",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "num_control_points = tf.constant([2, 2, 2])\npoints = tf.constant([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0], # base\n                       [ 90.0, 180.0], # control point\n                       [200.0,  65.0], # control point\n                       [210.0,  98.0], # base\n                       [220.0,  70.0], # control point\n                       [130.0,  55.0]]) # control point",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "points = tf.constant([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0], # base\n                       [ 90.0, 180.0], # control point\n                       [200.0,  65.0], # control point\n                       [210.0,  98.0], # base\n                       [220.0,  70.0], # control point\n                       [130.0,  55.0]]) # control point\npath = pydiffvg.Path(num_control_points = num_control_points,",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = True)\nshapes = [path]\npath_group = pydiffvg.ShapeGroup( shape_ids = tf.constant([0], dtype=tf.int32),\n    fill_color = tf.constant([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup( shape_ids = tf.constant([0], dtype=tf.int32),\n    fill_color = tf.constant([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup( shape_ids = tf.constant([0], dtype=tf.int32),\n    fill_color = tf.constant([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "render = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img, 'results/single_curve_tf/target.png', gamma=2.2)\ntarget = tf.identity(img)",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img, 'results/single_curve_tf/target.png', gamma=2.2)\ntarget = tf.identity(img)\n# Move the path to produce initial guess",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "target = tf.identity(img)\n# Move the path to produce initial guess\n# normalize points for easier learning rate\npoints_n = tf.Variable([[100.0/256.0,  40.0/256.0],  # base\n                        [155.0/256.0,  65.0/256.0],  # control point\n                        [100.0/256.0, 180.0/256.0],  # control point\n                        [ 65.0/256.0, 238.0/256.0],  # base\n                        [100.0/256.0, 200.0/256.0],  # control point\n                        [170.0/256.0,  55.0/256.0],  # control point\n                        [220.0/256.0, 100.0/256.0],  # base",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "points_n = tf.Variable([[100.0/256.0,  40.0/256.0],  # base\n                        [155.0/256.0,  65.0/256.0],  # control point\n                        [100.0/256.0, 180.0/256.0],  # control point\n                        [ 65.0/256.0, 238.0/256.0],  # base\n                        [100.0/256.0, 200.0/256.0],  # control point\n                        [170.0/256.0,  55.0/256.0],  # control point\n                        [220.0/256.0, 100.0/256.0],  # base\n                        [210.0/256.0,  80.0/256.0],  # control point\n                        [140.0/256.0,  60.0/256.0]]) # control point\ncolor = tf.Variable([0.3, 0.2, 0.5, 1.0])",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "color = tf.Variable([0.3, 0.2, 0.5, 1.0])\npath.points = points_n * 256\npath_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "path.points = points_n * 256\npath_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "path_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_curve_tf/init.png', gamma=2.2)",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_curve_tf/init.png', gamma=2.2)\noptimizer = tf.compat.v1.train.AdamOptimizer(1e-2)",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_curve_tf/init.png', gamma=2.2)\noptimizer = tf.compat.v1.train.AdamOptimizer(1e-2)\nfor t in range(100):\n    print('iteration:', t)",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "optimizer = tf.compat.v1.train.AdamOptimizer(1e-2)\nfor t in range(100):\n    print('iteration:', t)\n    with tf.GradientTape() as tape:\n        # Forward pass: render the image.\n        path.points = points_n * 256\n        path_group.fill_color = color\n        # Important to use a different seed every iteration, otherwise the result\n        # would be biased.\n        scene_args = pydiffvg.serialize_scene(\\",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "path.points = points_n * 256\npath_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "path_group.fill_color = color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img, 'results/single_curve_tf/final.png')",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_curve_tf",
        "description": "apps.single_curve_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img, 'results/single_curve_tf/final.png')\n# Convert the intermediate renderings to a video.\nfrom subprocess import call",
        "detail": "apps.single_curve_tf",
        "documentation": {}
    },
    {
        "label": "ellipse",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "ellipse = pydiffvg.Ellipse(radius = torch.tensor([60.0, 30.0]),\n                           center = torch.tensor([128.0, 128.0]))\nshapes = [ellipse]\nellipse_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [ellipse_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "shapes = [ellipse]\nellipse_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [ellipse_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "ellipse_group",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "ellipse_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [ellipse_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "shape_groups = [ellipse_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse/target.png', gamma=2.2)",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "target = img.clone()\n# Move the ellipse to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = torch.tensor([20.0 / 256.0, 40.0 / 256.0], requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nellipse.radius = radius_n * 256\nellipse.center = center_n * 256\nellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "radius_n",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "radius_n = torch.tensor([20.0 / 256.0, 40.0 / 256.0], requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nellipse.radius = radius_n * 256\nellipse.center = center_n * 256\nellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "center_n",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "center_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nellipse.radius = radius_n * 256\nellipse.center = center_n * 256\nellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\nellipse.radius = radius_n * 256\nellipse.center = center_n * 256\nellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "ellipse.radius",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "ellipse.radius = radius_n * 256\nellipse.center = center_n * 256\nellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "ellipse.center",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "ellipse.center = center_n * 256\nellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "ellipse_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "ellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse/init.png', gamma=2.2)",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse/init.png', gamma=2.2)\n# Optimize for radius & center\noptimizer = torch.optim.Adam([radius_n, center_n, color], lr=1e-2)",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "optimizer = torch.optim.Adam([radius_n, center_n, color], lr=1e-2)\n# Run 50 Adam iterations.\nfor t in range(50):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    ellipse.radius = radius_n * 256\n    ellipse.center = center_n * 256\n    ellipse_group.fill_color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "ellipse.radius",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "ellipse.radius = radius_n * 256\nellipse.center = center_n * 256\nellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "ellipse.center",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "ellipse.center = center_n * 256\nellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "ellipse_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "ellipse_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_ellipse",
        "description": "apps.single_ellipse",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_ellipse",
        "documentation": {}
    },
    {
        "label": "ellipse",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "ellipse = pydiffvg.Ellipse(radius = torch.tensor([60.0, 30.0]),\n                           center = torch.tensor([128.0, 128.0]))\nshapes = [ellipse]\nellipse_group = pydiffvg.ShapeGroup(\\\n    shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n    shape_to_canvas = torch.eye(3, 3))\nshape_groups = [ellipse_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "shapes = [ellipse]\nellipse_group = pydiffvg.ShapeGroup(\\\n    shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n    shape_to_canvas = torch.eye(3, 3))\nshape_groups = [ellipse_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "ellipse_group",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "ellipse_group = pydiffvg.ShapeGroup(\\\n    shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]),\n    shape_to_canvas = torch.eye(3, 3))\nshape_groups = [ellipse_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "shape_groups = [ellipse_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse_transform/target.png', gamma=2.2)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse_transform/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "target = img.clone()\n# Affine transform the ellipse to produce initial guess\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\naffine = torch.zeros(2, 3)\naffine[0, 0] = 1.3\naffine[0, 1] = 0.2\naffine[0, 2] = 0.1\naffine[1, 0] = 0.2\naffine[1, 1] = 0.6\naffine[1, 2] = 0.3",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\naffine = torch.zeros(2, 3)\naffine[0, 0] = 1.3\naffine[0, 1] = 0.2\naffine[0, 2] = 0.1\naffine[1, 0] = 0.2\naffine[1, 1] = 0.6\naffine[1, 2] = 0.3\naffine.requires_grad = True\nshape_to_canvas = torch.cat((affine, torch.tensor([[0.0, 0.0, 1.0]])), axis=0)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "affine",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "affine = torch.zeros(2, 3)\naffine[0, 0] = 1.3\naffine[0, 1] = 0.2\naffine[0, 2] = 0.1\naffine[1, 0] = 0.2\naffine[1, 1] = 0.6\naffine[1, 2] = 0.3\naffine.requires_grad = True\nshape_to_canvas = torch.cat((affine, torch.tensor([[0.0, 0.0, 1.0]])), axis=0)\nellipse_group.fill_color = color",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "affine.requires_grad",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "affine.requires_grad = True\nshape_to_canvas = torch.cat((affine, torch.tensor([[0.0, 0.0, 1.0]])), axis=0)\nellipse_group.fill_color = color\nellipse_group.shape_to_canvas = shape_to_canvas\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "shape_to_canvas",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "shape_to_canvas = torch.cat((affine, torch.tensor([[0.0, 0.0, 1.0]])), axis=0)\nellipse_group.fill_color = color\nellipse_group.shape_to_canvas = shape_to_canvas\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "ellipse_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "ellipse_group.fill_color = color\nellipse_group.shape_to_canvas = shape_to_canvas\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "ellipse_group.shape_to_canvas",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "ellipse_group.shape_to_canvas = shape_to_canvas\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse_transform/init.png', gamma=2.2)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse_transform/init.png', gamma=2.2)\n# Optimize for radius & center\noptimizer = torch.optim.Adam([color, affine], lr=1e-2)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "optimizer = torch.optim.Adam([color, affine], lr=1e-2)\n# Run 150 Adam iterations.\nfor t in range(150):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    ellipse_group.fill_color = color\n    ellipse_group.shape_to_canvas = torch.cat((affine, torch.tensor([[0.0, 0.0, 1.0]])), axis=0)\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "ellipse_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "ellipse_group.fill_color = color\nellipse_group.shape_to_canvas = torch.cat((affine, torch.tensor([[0.0, 0.0, 1.0]])), axis=0)\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "ellipse_group.shape_to_canvas",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "ellipse_group.shape_to_canvas = torch.cat((affine, torch.tensor([[0.0, 0.0, 1.0]])), axis=0)\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_ellipse_transform",
        "description": "apps.single_ellipse_transform",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_ellipse_transform/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_ellipse_transform",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "color = pydiffvg.LinearGradient(\\\n    begin = torch.tensor([50.0, 50.0]),\n    end = torch.tensor([200.0, 200.0]),\n    offsets = torch.tensor([0.0, 1.0]),\n    stop_colors = torch.tensor([[0.2, 0.5, 0.7, 1.0],\n                                [0.7, 0.2, 0.5, 1.0]]))\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]), fill_color = color)",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "circle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]), fill_color = color)\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "shapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]), fill_color = color)\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "circle_group",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "circle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]), fill_color = color)\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "shape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_gradient/target.png', gamma=2.2)",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_gradient/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "target = img.clone()\n# Move the circle to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\nbegin_n = torch.tensor([100.0 / 256.0, 100.0 / 256.0], requires_grad=True)\nend_n = torch.tensor([150.0 / 256.0, 150.0 / 256.0], requires_grad=True)\nstop_colors = torch.tensor([[0.1, 0.9, 0.2, 1.0],\n                            [0.5, 0.3, 0.6, 1.0]], requires_grad=True)\ncolor.begin = begin_n * 256",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "radius_n",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "radius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\nbegin_n = torch.tensor([100.0 / 256.0, 100.0 / 256.0], requires_grad=True)\nend_n = torch.tensor([150.0 / 256.0, 150.0 / 256.0], requires_grad=True)\nstop_colors = torch.tensor([[0.1, 0.9, 0.2, 1.0],\n                            [0.5, 0.3, 0.6, 1.0]], requires_grad=True)\ncolor.begin = begin_n * 256\ncolor.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "center_n",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "center_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\nbegin_n = torch.tensor([100.0 / 256.0, 100.0 / 256.0], requires_grad=True)\nend_n = torch.tensor([150.0 / 256.0, 150.0 / 256.0], requires_grad=True)\nstop_colors = torch.tensor([[0.1, 0.9, 0.2, 1.0],\n                            [0.5, 0.3, 0.6, 1.0]], requires_grad=True)\ncolor.begin = begin_n * 256\ncolor.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "begin_n",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "begin_n = torch.tensor([100.0 / 256.0, 100.0 / 256.0], requires_grad=True)\nend_n = torch.tensor([150.0 / 256.0, 150.0 / 256.0], requires_grad=True)\nstop_colors = torch.tensor([[0.1, 0.9, 0.2, 1.0],\n                            [0.5, 0.3, 0.6, 1.0]], requires_grad=True)\ncolor.begin = begin_n * 256\ncolor.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "end_n",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "end_n = torch.tensor([150.0 / 256.0, 150.0 / 256.0], requires_grad=True)\nstop_colors = torch.tensor([[0.1, 0.9, 0.2, 1.0],\n                            [0.5, 0.3, 0.6, 1.0]], requires_grad=True)\ncolor.begin = begin_n * 256\ncolor.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nshapes = [circle]",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "stop_colors",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "stop_colors = torch.tensor([[0.1, 0.9, 0.2, 1.0],\n                            [0.5, 0.3, 0.6, 1.0]], requires_grad=True)\ncolor.begin = begin_n * 256\ncolor.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nshapes = [circle]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "color.begin",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "color.begin = begin_n * 256\ncolor.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nshapes = [circle]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "color.end",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "color.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nshapes = [circle]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "color.stop_colors",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "color.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nshapes = [circle]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "circle.radius",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "circle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nshapes = [circle]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "circle.center",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "circle.center = center_n * 256\ncircle_group.fill_color = color\nshapes = [circle]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "circle_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "circle_group.fill_color = color\nshapes = [circle]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "shapes = [circle]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_gradient/init.png', gamma=2.2)",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_gradient/init.png', gamma=2.2)\n# Optimize for radius & center\noptimizer = torch.optim.Adam([radius_n, center_n, begin_n, end_n, stop_colors], lr=1e-2)",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "optimizer = torch.optim.Adam([radius_n, center_n, begin_n, end_n, stop_colors], lr=1e-2)\n# Run 50 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    color.begin = begin_n * 256\n    color.end = end_n * 256\n    color.stop_colors = stop_colors\n    circle.radius = radius_n * 256",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "color.begin",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "color.begin = begin_n * 256\ncolor.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "color.end",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "color.end = end_n * 256\ncolor.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "color.stop_colors",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "color.stop_colors = stop_colors\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "circle.radius",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "circle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "circle.center",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "circle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "circle_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "circle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_gradient",
        "description": "apps.single_gradient",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             52,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_gradient/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_gradient",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "num_control_points = torch.tensor([2])\npoints = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = torch.tensor(5.0))\nshapes = [path]",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "points = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = torch.tensor(5.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = torch.tensor(5.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve/target.png', gamma=2.2)",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "target = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\npoints_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0]], # base\n                        requires_grad = True) \nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "points_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0]], # base\n                        requires_grad = True) \nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "stroke_color",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "stroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "stroke_width_n",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "stroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "path.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve/init.png', gamma=2.2)",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve/init.png', gamma=2.2)\n# Optimize\noptimizer = torch.optim.Adam([points_n, stroke_color, stroke_width_n], lr=1e-2)",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, stroke_color, stroke_width_n], lr=1e-2)\n# Run 200 Adam iterations.\nfor t in range(200):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    path.points = points_n * 256\n    path.stroke_width = stroke_width_n * 100\n    path_group.stroke_color = stroke_color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "path.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_open_curve",
        "description": "apps.single_open_curve",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_open_curve",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "num_control_points = torch.tensor([2])\npoints = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0]]) # base\nthickness = torch.tensor([10.0, 5.0, 4.0, 20.0])\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = thickness)",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "points = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0]]) # base\nthickness = torch.tensor([10.0, 5.0, 4.0, 20.0])\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = thickness)\nshapes = [path]",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "thickness",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "thickness = torch.tensor([10.0, 5.0, 4.0, 20.0])\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = thickness)\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = thickness)\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = None,\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve_thickness/target.png', gamma=2.2)",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve_thickness/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "target = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\npoints_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0]], # base\n                        requires_grad = True) \nthickness_n = torch.tensor([10.0 / 100.0, 10.0 / 100.0, 10.0 / 100.0, 10.0 / 100.0],\n                         requires_grad = True)",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "points_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0]], # base\n                        requires_grad = True) \nthickness_n = torch.tensor([10.0 / 100.0, 10.0 / 100.0, 10.0 / 100.0, 10.0 / 100.0],\n                         requires_grad = True)\nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = thickness_n * 100",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "thickness_n",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "thickness_n = torch.tensor([10.0 / 100.0, 10.0 / 100.0, 10.0 / 100.0, 10.0 / 100.0],\n                         requires_grad = True)\nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = thickness_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "stroke_color",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "stroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = thickness_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = thickness_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "path.stroke_width = thickness_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve_thickness/init.png', gamma=2.2)",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve_thickness/init.png', gamma=2.2)\n# Optimize\noptimizer = torch.optim.Adam([points_n, thickness_n, stroke_color], lr=1e-2)",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, thickness_n, stroke_color], lr=1e-2)\n# Run 200 Adam iterations.\nfor t in range(200):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    path.points = points_n * 256\n    path.stroke_width = thickness_n * 100\n    path_group.stroke_color = stroke_color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = thickness_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "path.stroke_width = thickness_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_open_curve_thickness",
        "description": "apps.single_open_curve_thickness",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_open_curve_thickness/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_open_curve_thickness",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "shapes = pydiffvg.from_svg_path('M510,255c0-20.4-17.85-38.25-38.25-38.25H331.5L204,12.75h-51l63.75,204H76.5l-38.25-51H0L25.5,255L0,344.25h38.25l38.25-51h140.25l-63.75,204h51l127.5-204h140.25C492.15,293.25,510,275.4,510,255z')\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_path/target.png', gamma=2.2)",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "img = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_path/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "target = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\nnoise = torch.FloatTensor(shapes[0].points.shape).uniform_(0.0, 1.0)\npoints_n = (shapes[0].points.clone() + (noise * 60 - 30)) / 510.0\npoints_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "noise",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "noise = torch.FloatTensor(shapes[0].points.shape).uniform_(0.0, 1.0)\npoints_n = (shapes[0].points.clone() + (noise * 60 - 30)) / 510.0\npoints_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510, # width\n             510, # height",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "points_n = (shapes[0].points.clone() + (noise * 60 - 30)) / 510.0\npoints_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "points_n.requires_grad",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "points_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "shapes[0].points",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "shapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "path_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_path/init.png', gamma=2.2)",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "img = render(510, # width\n             510, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_path/init.png', gamma=2.2)\n# Optimize\noptimizer = torch.optim.Adam([points_n, color], lr=1e-2)",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    shapes[0].points = points_n * 510\n    path_group.fill_color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "shapes[0].points",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "shapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510,   # width\n             510,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "path_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510,   # width\n             510,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(510,   # width\n             510,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_path",
        "description": "apps.single_path",
        "peekOfCode": "img = render(510,   # width\n             510,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_path/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_path",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "shapes = pydiffvg.from_svg_path('M510,255c0-20.4-17.85-38.25-38.25-38.25H331.5L204,12.75h-51l63.75,204H76.5l-38.25-51H0L25.5,255L0,344.25h38.25l38.25-51h140.25l-63.75,204h51l127.5-204h140.25C492.15,293.25,510,275.4,510,255z')\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg = img / 510 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_path_sdf/target.png', gamma=1.0)",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "img = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg = img / 510 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_path_sdf/target.png', gamma=1.0)\ntarget = img.clone()",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "img = img / 510 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_path_sdf/target.png', gamma=1.0)\ntarget = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\nnoise = torch.FloatTensor(shapes[0].points.shape).uniform_(0.0, 1.0)\npoints_n = (shapes[0].points.clone() + (noise * 60 - 30)) / 510.0\npoints_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "target = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\nnoise = torch.FloatTensor(shapes[0].points.shape).uniform_(0.0, 1.0)\npoints_n = (shapes[0].points.clone() + (noise * 60 - 30)) / 510.0\npoints_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "noise",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "noise = torch.FloatTensor(shapes[0].points.shape).uniform_(0.0, 1.0)\npoints_n = (shapes[0].points.clone() + (noise * 60 - 30)) / 510.0\npoints_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510, # width",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "points_n = (shapes[0].points.clone() + (noise * 60 - 30)) / 510.0\npoints_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510, # width\n             510, # height",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "points_n.requires_grad",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "points_n.requires_grad = True\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nshapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "shapes[0].points",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "shapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "path_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "img = render(510, # width\n             510, # height\n             1,   # num_samples_x\n             1,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\nimg = img / 510 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_path_sdf/init.png', gamma=1.0)\n# Optimize",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "img = img / 510 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/single_path_sdf/init.png', gamma=1.0)\n# Optimize\noptimizer = torch.optim.Adam([points_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    shapes[0].points = points_n * 510",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    shapes[0].points = points_n * 510\n    path_group.fill_color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups,",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "shapes[0].points",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "shapes[0].points = points_n * 510\npath_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510,   # width\n             510,   # height\n             1,     # num_samples_x\n             1,     # num_samples_y\n             102,    # seed",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "path_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "path_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510,   # width\n             510,   # height\n             1,     # num_samples_x\n             1,     # num_samples_y\n             102,    # seed\n             None, # background_image",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(510,   # width\n             510,   # height\n             1,     # num_samples_x\n             1,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_path_sdf",
        "description": "apps.single_path_sdf",
        "peekOfCode": "img = render(510,   # width\n             510,   # height\n             1,     # num_samples_x\n             1,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_path_sdf/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_path_sdf",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "points = torch.tensor([[120.0,  30.0],\n                       [ 60.0, 218.0],\n                       [210.0,  98.0],\n                       [ 30.0,  98.0],\n                       [180.0, 218.0]])\npolygon = pydiffvg.Polygon(points = points, is_closed = True)\nshapes = [polygon]\npolygon_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [polygon_group]",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "polygon",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "polygon = pydiffvg.Polygon(points = points, is_closed = True)\nshapes = [polygon]\npolygon_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [polygon_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "shapes = [polygon]\npolygon_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [polygon_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "polygon_group",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "polygon_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [polygon_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "shape_groups = [polygon_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_polygon/target.png', gamma=2.2)",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_polygon/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "target = img.clone()\n# Move the polygon to produce initial guess\n# normalize points for easier learning rate\npoints_n = torch.tensor([[140.0 / 256.0,  20.0 / 256.0],\n                         [ 65.0 / 256.0, 228.0 / 256.0],\n                         [215.0 / 256.0, 100.0 / 256.0],\n                         [ 35.0 / 256.0,  90.0 / 256.0],\n                         [160.0 / 256.0, 208.0 / 256.0]], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\npolygon.points = points_n * 256",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "points_n = torch.tensor([[140.0 / 256.0,  20.0 / 256.0],\n                         [ 65.0 / 256.0, 228.0 / 256.0],\n                         [215.0 / 256.0, 100.0 / 256.0],\n                         [ 35.0 / 256.0,  90.0 / 256.0],\n                         [160.0 / 256.0, 208.0 / 256.0]], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\npolygon.points = points_n * 256\npolygon_group.color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\npolygon.points = points_n * 256\npolygon_group.color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "polygon.points",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "polygon.points = points_n * 256\npolygon_group.color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "polygon_group.color",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "polygon_group.color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_polygon/init.png', gamma=2.2)",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_polygon/init.png', gamma=2.2)\n# Optimize for radius & center\noptimizer = torch.optim.Adam([points_n, color], lr=1e-2)",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    polygon.points = points_n * 256\n    polygon_group.color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "polygon.points",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "polygon.points = points_n * 256\npolygon_group.color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "polygon_group.color",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "polygon_group.color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_polygon",
        "description": "apps.single_polygon",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_polygon/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_polygon",
        "documentation": {}
    },
    {
        "label": "rect",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "rect = pydiffvg.Rect(p_min = torch.tensor([40.0, 40.0]),\n                     p_max = torch.tensor([160.0, 160.0]))\nshapes = [rect]\nrect_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [rect_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "shapes = [rect]\nrect_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [rect_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "rect_group",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "rect_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [rect_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "shape_groups = [rect_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_rect/target.png', gamma=2.2)",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_rect/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "target = img.clone()\n# Move the rect to produce initial guess\n# normalize p_min & p_max for easier learning rate\np_min_n = torch.tensor([80.0 / 256.0, 20.0 / 256.0], requires_grad=True)\np_max_n = torch.tensor([100.0 / 256.0, 60.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nrect.p_min = p_min_n * 256\nrect.p_max = p_max_n * 256\nrect_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "p_min_n",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "p_min_n = torch.tensor([80.0 / 256.0, 20.0 / 256.0], requires_grad=True)\np_max_n = torch.tensor([100.0 / 256.0, 60.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nrect.p_min = p_min_n * 256\nrect.p_max = p_max_n * 256\nrect_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "p_max_n",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "p_max_n = torch.tensor([100.0 / 256.0, 60.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nrect.p_min = p_min_n * 256\nrect.p_max = p_max_n * 256\nrect_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.5, 1.0], requires_grad=True)\nrect.p_min = p_min_n * 256\nrect.p_max = p_max_n * 256\nrect_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "rect.p_min",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "rect.p_min = p_min_n * 256\nrect.p_max = p_max_n * 256\nrect_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "rect.p_max",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "rect.p_max = p_max_n * 256\nrect_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "rect_group.fill_color",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "rect_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_rect/init.png', gamma=2.2)",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_rect/init.png', gamma=2.2)\n# Optimize for radius & center\noptimizer = torch.optim.Adam([p_min_n, p_max_n, color], lr=1e-2)",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "optimizer = torch.optim.Adam([p_min_n, p_max_n, color], lr=1e-2)\n# Run 100 Adam iterations.\nfor t in range(100):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    rect.p_min = p_min_n * 256\n    rect.p_max = p_max_n * 256\n    rect_group.fill_color = color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_rect",
        "description": "apps.single_rect",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_rect/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_rect",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "num_control_points = torch.tensor([2])\npoints = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = torch.tensor(5.0))\nshapes = [path]",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "points = torch.tensor([[120.0,  30.0], # base\n                       [150.0,  60.0], # control point\n                       [ 90.0, 198.0], # control point\n                       [ 60.0, 218.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = torch.tensor(5.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = torch.tensor(5.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.0, 0.0, 0.0, 0.0]),\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.0, 0.0, 0.0, 0.0]),\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n                                 fill_color = torch.tensor([0.0, 0.0, 0.0, 0.0]),\n                                 stroke_color = torch.tensor([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_stroke/target.png', gamma=2.2)",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'results/single_stroke/target.png', gamma=2.2)\ntarget = img.clone()",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "target = img.clone()\n# Move the path to produce initial guess\n# normalize points for easier learning rate\npoints_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0]], # base\n                        requires_grad = True) \nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "points_n = torch.tensor([[100.0/256.0,  40.0/256.0], # base\n                         [155.0/256.0,  65.0/256.0], # control point\n                         [100.0/256.0, 180.0/256.0], # control point\n                         [ 65.0/256.0, 238.0/256.0]], # base\n                        requires_grad = True) \nstroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "stroke_color",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "stroke_color = torch.tensor([0.4, 0.7, 0.5, 0.5], requires_grad=True)\nstroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "stroke_width_n",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "stroke_width_n = torch.tensor(10.0 / 100.0, requires_grad=True)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "path.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_stroke/init.png', gamma=2.2)",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\npydiffvg.imwrite(img.cpu(), 'results/single_stroke/init.png', gamma=2.2)\n# Optimize\noptimizer = torch.optim.Adam([points_n, stroke_color, stroke_width_n], lr=1e-2)",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "optimizer = torch.optim.Adam([points_n, stroke_color, stroke_width_n], lr=1e-2)\n# Run 200 Adam iterations.\nfor t in range(200):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    path.points = points_n * 256\n    path.stroke_width = stroke_width_n * 100\n    path_group.stroke_color = stroke_color\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "path.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_stroke",
        "description": "apps.single_stroke",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             202,    # seed\n             None, # background_image\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/single_stroke/final.png')\n# Convert the intermediate renderings to a video.",
        "detail": "apps.single_stroke",
        "documentation": {}
    },
    {
        "label": "num_control_points",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "num_control_points = tf.constant([2])\npoints = tf.constant([[120.0,  30.0], # base\n                      [150.0,  60.0], # control point\n                      [ 90.0, 198.0], # control point\n                      [ 60.0, 218.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = tf.constant(15.0))\nshapes = [path]",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "points = tf.constant([[120.0,  30.0], # base\n                      [150.0,  60.0], # control point\n                      [ 90.0, 198.0], # control point\n                      [ 60.0, 218.0]]) # base\npath = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = tf.constant(15.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup( shape_ids = tf.constant([0], dtype=tf.int32),",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "path = pydiffvg.Path(num_control_points = num_control_points,\n                     points = points,\n                     is_closed = False,\n                     stroke_width = tf.constant(15.0))\nshapes = [path]\npath_group = pydiffvg.ShapeGroup( shape_ids = tf.constant([0], dtype=tf.int32),\n                                  fill_color = tf.constant([0.0, 0.0, 0.0, 0.0]),\n                                  stroke_color = tf.constant([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.serialize_scene(\\",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "shapes = [path]\npath_group = pydiffvg.ShapeGroup( shape_ids = tf.constant([0], dtype=tf.int32),\n                                  fill_color = tf.constant([0.0, 0.0, 0.0, 0.0]),\n                                  stroke_color = tf.constant([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "path_group",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "path_group = pydiffvg.ShapeGroup( shape_ids = tf.constant([0], dtype=tf.int32),\n                                  fill_color = tf.constant([0.0, 0.0, 0.0, 0.0]),\n                                  stroke_color = tf.constant([0.6, 0.3, 0.6, 0.8]))\nshape_groups = [path_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "shape_groups = [path_group]\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "render = pydiffvg.render\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img, 'results/single_stroke_tf/target.png', gamma=2.2)\ntarget = tf.identity(img)",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(0),   # seed\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img, 'results/single_stroke_tf/target.png', gamma=2.2)\ntarget = tf.identity(img)\n# Move the path to produce initial guess",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "target = tf.identity(img)\n# Move the path to produce initial guess\n# normalize points for easier learning rate\npoints_n = tf.Variable([[100.0/256.0,  40.0/256.0], # base\n                        [155.0/256.0,  65.0/256.0], # control point\n                        [100.0/256.0, 180.0/256.0], # control point\n                        [ 65.0/256.0, 238.0/256.0]] # base\n                       ) \nstroke_color = tf.Variable([0.4, 0.7, 0.5, 0.5])\nstroke_width_n = tf.Variable(5.0 / 100.0)",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "points_n",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "points_n = tf.Variable([[100.0/256.0,  40.0/256.0], # base\n                        [155.0/256.0,  65.0/256.0], # control point\n                        [100.0/256.0, 180.0/256.0], # control point\n                        [ 65.0/256.0, 238.0/256.0]] # base\n                       ) \nstroke_color = tf.Variable([0.4, 0.7, 0.5, 0.5])\nstroke_width_n = tf.Variable(5.0 / 100.0)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "stroke_color",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "stroke_color = tf.Variable([0.4, 0.7, 0.5, 0.5])\nstroke_width_n = tf.Variable(5.0 / 100.0)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "stroke_width_n",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "stroke_width_n = tf.Variable(5.0 / 100.0)\npath.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "path.points = points_n * 256\npath.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "path.stroke_width",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "path.stroke_width = stroke_width_n * 100\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_stroke_tf/init.png', gamma=2.2)",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_stroke_tf/init.png', gamma=2.2)\noptimizer = tf.compat.v1.train.AdamOptimizer(1e-2)",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(1),   # seed\n             *scene_args)\npydiffvg.imwrite(img, 'results/single_stroke_tf/init.png', gamma=2.2)\noptimizer = tf.compat.v1.train.AdamOptimizer(1e-2)\nfor t in range(100):\n    print('iteration:', t)",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "optimizer = tf.compat.v1.train.AdamOptimizer(1e-2)\nfor t in range(100):\n    print('iteration:', t)\n    with tf.GradientTape() as tape:\n        # Forward pass: render the image.\n        path.points = points_n * 256\n        path.stroke_width = stroke_width_n * 100\n        path_group.stroke_color = stroke_color\n        # Important to use a different seed every iteration, otherwise the result\n        # would be biased.",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "path.points",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "path.points = points_n * 256\npath_group.stroke_color = stroke_color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "path_group.stroke_color",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "path_group.stroke_color = stroke_color\nscene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "scene_args = pydiffvg.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups)\nimg = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img, 'results/single_stroke_tf/final.png')",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.single_stroke_tf",
        "description": "apps.single_stroke_tf",
        "peekOfCode": "img = render(tf.constant(256), # width\n             tf.constant(256), # height\n             tf.constant(2),   # num_samples_x\n             tf.constant(2),   # num_samples_y\n             tf.constant(101),   # seed\n             *scene_args)\n# Save the images and differences.\npydiffvg.imwrite(img, 'results/single_stroke_tf/final.png')\n# Convert the intermediate renderings to a video.\nfrom subprocess import call",
        "detail": "apps.single_stroke_tf",
        "documentation": {}
    },
    {
        "label": "VisdomImageCallback",
        "kind": 6,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "class VisdomImageCallback(ttools.callbacks.ImageDisplayCallback):\n    def visualized_image(self, batch, fwd_result):\n        return torch.cat([batch[0], fwd_result.cpu()], dim = 2)\n# From https://github.com/eriklindernoren/PyTorch-GAN/blob/master/implementations/dcgan/dcgan.py\nclass Generator(torch.nn.Module):\n    def __init__(self):\n        super(Generator, self).__init__()\n        self.fc = torch.nn.Sequential(\n            torch.nn.Linear(latent_dim, 128),\n            torch.nn.LeakyReLU(0.2, inplace=True),",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "Generator",
        "kind": 6,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "class Generator(torch.nn.Module):\n    def __init__(self):\n        super(Generator, self).__init__()\n        self.fc = torch.nn.Sequential(\n            torch.nn.Linear(latent_dim, 128),\n            torch.nn.LeakyReLU(0.2, inplace=True),\n            torch.nn.Linear(128, 256),\n            torch.nn.LeakyReLU(0.2, inplace=True),\n            torch.nn.Linear(256, 512),\n            torch.nn.LeakyReLU(0.2, inplace=True),",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "Discriminator",
        "kind": 6,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "class Discriminator(torch.nn.Module):\n    def __init__(self):\n        super(Discriminator, self).__init__()\n        def discriminator_block(in_filters, out_filters, bn=True):\n            block = [torch.nn.Conv2d(in_filters, out_filters, 3, 2, 1),\n                     torch.nn.LeakyReLU(0.2, inplace=True),\n                     torch.nn.Dropout2d(0.25)]\n            if bn:\n                block.append(torch.nn.BatchNorm2d(out_filters, 0.8))\n            return block",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "MNISTInterface",
        "kind": 6,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "class MNISTInterface(ttools.interfaces.SGANInterface):\n    \"\"\"An adapter to run or train a model.\"\"\"\n    def __init__(self, gen, discrim, lr=2e-4):\n        super(MNISTInterface, self).__init__(gen, discrim, lr, opt = 'adam')\n    def forward(self, batch):\n        return self.gen(torch.zeros([batch[0].shape[0], latent_dim], device = self.device).normal_())\n    def _discriminator_input(self, batch, fwd_data, fake=False):\n        if fake:\n            return fwd_data\n        else:",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "weights_init_normal",
        "kind": 2,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "def weights_init_normal(m):\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        torch.nn.init.normal_(m.weight.data, 0.0, 0.02)\n    elif classname.find(\"BatchNorm2d\") != -1:\n        torch.nn.init.normal_(m.weight.data, 1.0, 0.02)\n        torch.nn.init.constant_(m.bias.data, 0.0)\nclass VisdomImageCallback(ttools.callbacks.ImageDisplayCallback):\n    def visualized_image(self, batch, fwd_result):\n        return torch.cat([batch[0], fwd_result.cpu()], dim = 2)",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "def train(args):\n    \"\"\"Train a MNIST classifier.\"\"\"\n    # Setup train and val data\n    _xform = xforms.Compose([xforms.Resize([32, 32]), xforms.ToTensor()])\n    data = MNIST(\"data/mnist\", train=True, download=True, transform=_xform)\n    # Initialize asynchronous dataloaders\n    loader = DataLoader(data, batch_size=args.bs, num_workers=2)\n    # Instantiate the models\n    gen = Generator()\n    discrim = Discriminator()",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "LOG = ttools.get_logger(__name__)\npydiffvg.render_pytorch.print_timing = False\ntorch.manual_seed(123)\nnp.random.seed(123)\ntorch.backends.cudnn.deterministic = True\nlatent_dim = 100\nimg_size = 32\nnum_paths = 8\nnum_segments = 8\ndef weights_init_normal(m):",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "pydiffvg.render_pytorch.print_timing",
        "kind": 5,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "pydiffvg.render_pytorch.print_timing = False\ntorch.manual_seed(123)\nnp.random.seed(123)\ntorch.backends.cudnn.deterministic = True\nlatent_dim = 100\nimg_size = 32\nnum_paths = 8\nnum_segments = 8\ndef weights_init_normal(m):\n    classname = m.__class__.__name__",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "torch.backends.cudnn.deterministic",
        "kind": 5,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "torch.backends.cudnn.deterministic = True\nlatent_dim = 100\nimg_size = 32\nnum_paths = 8\nnum_segments = 8\ndef weights_init_normal(m):\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        torch.nn.init.normal_(m.weight.data, 0.0, 0.02)\n    elif classname.find(\"BatchNorm2d\") != -1:",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "latent_dim",
        "kind": 5,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "latent_dim = 100\nimg_size = 32\nnum_paths = 8\nnum_segments = 8\ndef weights_init_normal(m):\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        torch.nn.init.normal_(m.weight.data, 0.0, 0.02)\n    elif classname.find(\"BatchNorm2d\") != -1:\n        torch.nn.init.normal_(m.weight.data, 1.0, 0.02)",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "img_size",
        "kind": 5,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "img_size = 32\nnum_paths = 8\nnum_segments = 8\ndef weights_init_normal(m):\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        torch.nn.init.normal_(m.weight.data, 0.0, 0.02)\n    elif classname.find(\"BatchNorm2d\") != -1:\n        torch.nn.init.normal_(m.weight.data, 1.0, 0.02)\n        torch.nn.init.constant_(m.bias.data, 0.0)",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "num_paths",
        "kind": 5,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "num_paths = 8\nnum_segments = 8\ndef weights_init_normal(m):\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        torch.nn.init.normal_(m.weight.data, 0.0, 0.02)\n    elif classname.find(\"BatchNorm2d\") != -1:\n        torch.nn.init.normal_(m.weight.data, 1.0, 0.02)\n        torch.nn.init.constant_(m.bias.data, 0.0)\nclass VisdomImageCallback(ttools.callbacks.ImageDisplayCallback):",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "num_segments",
        "kind": 5,
        "importPath": "apps.sketch_gan",
        "description": "apps.sketch_gan",
        "peekOfCode": "num_segments = 8\ndef weights_init_normal(m):\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        torch.nn.init.normal_(m.weight.data, 0.0, 0.02)\n    elif classname.find(\"BatchNorm2d\") != -1:\n        torch.nn.init.normal_(m.weight.data, 1.0, 0.02)\n        torch.nn.init.constant_(m.bias.data, 0.0)\nclass VisdomImageCallback(ttools.callbacks.ImageDisplayCallback):\n    def visualized_image(self, batch, fwd_result):",
        "detail": "apps.sketch_gan",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.style_transfer",
        "description": "apps.style_transfer",
        "peekOfCode": "def main(args):\n    pydiffvg.set_use_gpu(torch.cuda.is_available())\n    canvas_width, canvas_height, shapes, shape_groups = pydiffvg.svg_to_scene(args.content_file)\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)\n    render = pydiffvg.RenderFunction.apply\n    img = render(canvas_width, # width\n                 canvas_height, # height\n                 2,   # num_samples_x\n                 2,   # num_samples_y",
        "detail": "apps.style_transfer",
        "documentation": {}
    },
    {
        "label": "box_kernel",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def box_kernel(val):\n    return np.heaviside(-val+1,0)\ndef cone_kernel(val):\n    return np.maximum(0,1-val)\ndef nptosurf(arr):\n    if arr.shape[2]==1:\n        #greyscale\n        shape=arr.shape\n        shape=(shape[0],shape[1],3)\n        arr=np.broadcast_to(arr,shape)",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "cone_kernel",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def cone_kernel(val):\n    return np.maximum(0,1-val)\ndef nptosurf(arr):\n    if arr.shape[2]==1:\n        #greyscale\n        shape=arr.shape\n        shape=(shape[0],shape[1],3)\n        arr=np.broadcast_to(arr,shape)\n    return pg.surfarray.make_surface(arr*255)\ndef brush_tensor(screen_size,coords,radius,kernel):",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "nptosurf",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def nptosurf(arr):\n    if arr.shape[2]==1:\n        #greyscale\n        shape=arr.shape\n        shape=(shape[0],shape[1],3)\n        arr=np.broadcast_to(arr,shape)\n    return pg.surfarray.make_surface(arr*255)\ndef brush_tensor(screen_size,coords,radius,kernel):\n    coordarr=np.stack(np.meshgrid(np.linspace(0,screen_size[0]-1,screen_size[0]),np.linspace(0,screen_size[1]-1,screen_size[1]),indexing='ij'),axis=2)\n    ctrarr = np.reshape(np.array(coords), [1, 1, 2])",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "brush_tensor",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def brush_tensor(screen_size,coords,radius,kernel):\n    coordarr=np.stack(np.meshgrid(np.linspace(0,screen_size[0]-1,screen_size[0]),np.linspace(0,screen_size[1]-1,screen_size[1]),indexing='ij'),axis=2)\n    ctrarr = np.reshape(np.array(coords), [1, 1, 2])\n    distarr=np.sqrt(np.sum(np.power(coordarr-ctrarr,2),axis=2))\n    valarr=kernel(distarr/radius)\n    return torch.tensor(valarr,requires_grad=False,dtype=torch.float32)\ndef checkerboard(shape, square_size=2):\n    xv,yv=np.meshgrid(np.floor(np.linspace(0,shape[1]-1,shape[1])/square_size),np.floor(np.linspace(0,shape[0]-1,shape[0])/square_size))\n    bin=np.expand_dims(((xv+yv)%2),axis=2)\n    res=bin*np.array([[[1., 1., 1.,]]])+(1-bin)*np.array([[[.75, .75, .75,]]])",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "checkerboard",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def checkerboard(shape, square_size=2):\n    xv,yv=np.meshgrid(np.floor(np.linspace(0,shape[1]-1,shape[1])/square_size),np.floor(np.linspace(0,shape[0]-1,shape[0])/square_size))\n    bin=np.expand_dims(((xv+yv)%2),axis=2)\n    res=bin*np.array([[[1., 1., 1.,]]])+(1-bin)*np.array([[[.75, .75, .75,]]])\n    return torch.tensor(res,requires_grad=False,dtype=torch.float32)\ndef render(optim, viewport):\n    scene_args = pydiffvg.RenderFunction.serialize_scene(*optim.build_scene())\n    render = pydiffvg.RenderFunction.apply\n    img = render(viewport[0],  # width\n                 viewport[1],  # height",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def render(optim, viewport):\n    scene_args = pydiffvg.RenderFunction.serialize_scene(*optim.build_scene())\n    render = pydiffvg.RenderFunction.apply\n    img = render(viewport[0],  # width\n                 viewport[1],  # height\n                 2,  # num_samples_x\n                 2,  # num_samples_y\n                 0,  # seed\n                 None,\n                 *scene_args)",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "optimize",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def optimize(optim, viewport, brush_kernel, increase=True, strength=0.1):\n    optim.zero_grad()\n    geomLoss=torch.tensor(0.)\n    for shape, gloss in zip(optim.scene[2],geometryLosses):\n        geomLoss+=gloss.compute(shape)\n    img=render(optim,viewport)\n    imalpha=img[:,:,3]\n    multiplied=imalpha*brush_kernel\n    loss=((1-multiplied).mean() if increase else multiplied.mean())*strength\n    loss+=geomLoss",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "get_infile",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def get_infile():\n    pydiffvg.set_use_gpu(False)\n    root = tk.Tk()\n    #root.withdraw()\n    file_path = filedialog.askopenfilename(initialdir = \".\",title = \"Select graphic to optimize\",filetypes = ((\"SVG files\",\"*.svg\"),(\"all files\",\"*.*\")))\n    root.destroy()\n    return file_path\ndef compositebg(img):\n    bg=checkerboard(img.shape,2)\n    color=img[:,:,0:3]",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "compositebg",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def compositebg(img):\n    bg=checkerboard(img.shape,2)\n    color=img[:,:,0:3]\n    alpha=img[:,:,3]\n    composite=alpha.unsqueeze(2)*color+(1-alpha).unsqueeze(2)*bg\n    return composite\ndef main():\n    infile=get_infile()\n    settings=pydiffvg.SvgOptimizationSettings()\n    settings.global_override([\"optimize_color\"],False)",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.svg_brush",
        "description": "apps.svg_brush",
        "peekOfCode": "def main():\n    infile=get_infile()\n    settings=pydiffvg.SvgOptimizationSettings()\n    settings.global_override([\"optimize_color\"],False)\n    settings.global_override([\"transforms\",\"optimize_transforms\"], False)\n    settings.global_override([\"optimizer\"], \"SGD\")\n    settings.global_override([\"paths\",\"shape_lr\"], 1e-1)\n    optim=pydiffvg.OptimizableSvg(infile,settings)\n    global geometryLosses\n    geometryLosses = []",
        "detail": "apps.svg_brush",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.svg_parse_test",
        "description": "apps.svg_parse_test",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n\tcanvas_width, canvas_height, shapes, shape_groups)\nrender = pydiffvg.RenderFunction.apply\nimg = render(canvas_width, # width\n             canvas_height, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.svg_parse_test",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.svg_parse_test",
        "description": "apps.svg_parse_test",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(canvas_width, # width\n             canvas_height, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'test_old.png', gamma=1.0)",
        "detail": "apps.svg_parse_test",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.svg_parse_test",
        "description": "apps.svg_parse_test",
        "peekOfCode": "img = render(canvas_width, # width\n             canvas_height, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\n# The output image is in linear RGB space. Do Gamma correction before saving the image.\npydiffvg.imwrite(img.cpu(), 'test_old.png', gamma=1.0)\n#optim=OptimizableSvg('linux.svg',verbose=True)",
        "detail": "apps.svg_parse_test",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.svg_parse_test",
        "description": "apps.svg_parse_test",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(*scene)\nrender = pydiffvg.RenderFunction.apply\nimg = render(scene[0], # width\n             scene[1], # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nwith open(\"resaved.svg\",\"w\") as f:",
        "detail": "apps.svg_parse_test",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.svg_parse_test",
        "description": "apps.svg_parse_test",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(scene[0], # width\n             scene[1], # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nwith open(\"resaved.svg\",\"w\") as f:\n    f.write(optim.write_xml())",
        "detail": "apps.svg_parse_test",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.svg_parse_test",
        "description": "apps.svg_parse_test",
        "peekOfCode": "img = render(scene[0], # width\n             scene[1], # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nwith open(\"resaved.svg\",\"w\") as f:\n    f.write(optim.write_xml())\n# The output image is in linear RGB space. Do Gamma correction before saving the image.",
        "detail": "apps.svg_parse_test",
        "documentation": {}
    },
    {
        "label": "canvas_width",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "canvas_width = 256\ncanvas_height = 256\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "canvas_height",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "canvas_height = 256\ncircle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "circle = pydiffvg.Circle(radius = torch.tensor(40.0),\n                         center = torch.tensor([128.0, 128.0]))\nshapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "shapes = [circle]\ncircle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "circle_group",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "circle_group = pydiffvg.ShapeGroup(shape_ids = torch.tensor([0]),\n    fill_color = torch.tensor([0.3, 0.6, 0.3, 1.0]))\nshape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "shape_groups",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "shape_groups = [circle_group]\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nrender = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "render = pydiffvg.RenderFunction.apply\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/test_eval_positions/target.png')",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             0,   # seed\n             None, # background_image\n             *scene_args)\nimg = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/test_eval_positions/target.png')\ntarget = img.clone()",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "img = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/test_eval_positions/target.png')\ntarget = img.clone()\n# Move the circle to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "target = img.clone()\n# Move the circle to produce initial guess\n# normalize radius & center for easier learning rate\nradius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "radius_n",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "radius_n = torch.tensor(20.0 / 256.0, requires_grad=True)\ncenter_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "center_n",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "center_n = torch.tensor([108.0 / 256.0, 138.0 / 256.0], requires_grad=True)\ncolor = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "color = torch.tensor([0.3, 0.2, 0.8, 1.0], requires_grad=True)\ncircle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "circle.radius",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "circle.radius = radius_n * 256\ncircle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "circle.center",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "circle.center = center_n * 256\ncircle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "circle_group.fill_color",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "circle_group.fill_color = color\nscene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "img = render(256, # width\n             256, # height\n             2,   # num_samples_x\n             2,   # num_samples_y\n             1,   # seed\n             None, # background_image\n             *scene_args)\nimg = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/test_eval_positions/init.png')\n# Optimize for radius & center",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "img = img / 256 # Normalize SDF to [0, 1]\npydiffvg.imwrite(img.cpu(), 'results/test_eval_positions/init.png')\n# Optimize for radius & center\noptimizer = torch.optim.Adam([radius_n, center_n, color], lr=1e-2)\n# Run 200 Adam iterations.\nfor t in range(200):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    circle.radius = radius_n * 256",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "optimizer = torch.optim.Adam([radius_n, center_n, color], lr=1e-2)\n# Run 200 Adam iterations.\nfor t in range(200):\n    print('iteration:', t)\n    optimizer.zero_grad()\n    # Forward pass: render the image.\n    circle.radius = radius_n * 256\n    circle.center = center_n * 256\n    circle_group.fill_color = color\n    # Evaluate 1000 positions",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "scene_args",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n    canvas_width, canvas_height, shapes, shape_groups,\n    output_type = pydiffvg.OutputType.sdf)\nimg = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "img = render(256,   # width\n             256,   # height\n             2,     # num_samples_x\n             2,     # num_samples_y\n             102,    # seed\n             None, # background_image\n             *scene_args)\nimg = img / 256 # Normalize SDF to [0, 1]\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/test_eval_positions/final.png')",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "apps.test_eval_positions",
        "description": "apps.test_eval_positions",
        "peekOfCode": "img = img / 256 # Normalize SDF to [0, 1]\n# Save the images and differences.\npydiffvg.imwrite(img.cpu(), 'results/test_eval_positions/final.png')",
        "detail": "apps.test_eval_positions",
        "documentation": {}
    },
    {
        "label": "texture_syn",
        "kind": 2,
        "importPath": "apps.texture_synthesis",
        "description": "apps.texture_synthesis",
        "peekOfCode": "def texture_syn(img_path):\n    ## get the width and height first\n    # input_img = io.imread(img_path)  # returns an MxNx3 array\n    # output_size = [input_img.shape[1], input_img.shape[0]]\n    # output_path = \"textureSyn/1/\"\n    output_path = \"results/texture_synthesis/%d\"%(args.case)\n    patch_size = 40  # size of the patch (without the overlap)\n    overlap_size = 10  # the width of the overlap region\n    output_size = [300, 300]\n    pbts = patchBasedTextureSynthesis(img_path, output_path, output_size, patch_size, overlap_size, in_windowStep=5,",
        "detail": "apps.texture_synthesis",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "apps.texture_synthesis",
        "description": "apps.texture_synthesis",
        "peekOfCode": "def render(canvas_width, canvas_height, shapes, shape_groups, samples=2):\n    _render = pydiffvg.RenderFunction.apply\n    scene_args = pydiffvg.RenderFunction.serialize_scene(\\\n        canvas_width, canvas_height, shapes, shape_groups)\n    img = _render(canvas_width, # width\n                 canvas_height, # height\n                 samples,   # num_samples_x\n                 samples,   # num_samples_y\n                 0,   # seed\n                 None,",
        "detail": "apps.texture_synthesis",
        "documentation": {}
    },
    {
        "label": "big_bounding_box",
        "kind": 2,
        "importPath": "apps.texture_synthesis",
        "description": "apps.texture_synthesis",
        "peekOfCode": "def big_bounding_box(paths_n_stuff):\n    \"\"\"Finds a BB containing a collection of paths, Bezier path segments, and\n    points (given as complex numbers).\"\"\"\n    bbs = []\n    for thing in paths_n_stuff:\n        if is_path_segment(thing) or isinstance(thing, Path):\n            bbs.append(thing.bbox())\n        elif isinstance(thing, complex):\n            bbs.append((thing.real, thing.real, thing.imag, thing.imag))\n        else:",
        "detail": "apps.texture_synthesis",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apps.texture_synthesis",
        "description": "apps.texture_synthesis",
        "peekOfCode": "def main(args):\n    ## set device -> use cpu now since I haven't solved the nvcc issue\n    pydiffvg.set_use_gpu(False)\n    # pydiffvg.set_device(torch.device('cuda:1'))\n    ## use L2 for now\n    # perception_loss = ttools.modules.LPIPS().to(pydiffvg.get_device())\n    ## generate a texture synthesized\n    target_img = texture_syn(args.target)\n    tar_h, tar_w = target_img.shape[1], target_img.shape[0]\n    canvas_width, canvas_height, shapes, shape_groups = \\",
        "detail": "apps.texture_synthesis",
        "documentation": {}
    },
    {
        "label": "LinearGradient",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.color",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.color",
        "peekOfCode": "class LinearGradient:\n    def __init__(self,\n                 begin = torch.tensor([0.0, 0.0]),\n                 end = torch.tensor([0.0, 0.0]),\n                 offsets = torch.tensor([0.0]),\n                 stop_colors = torch.tensor([0.0, 0.0, 0.0, 0.0])):\n        self.begin = begin\n        self.end = end\n        self.offsets = offsets\n        self.stop_colors = stop_colors",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.color",
        "documentation": {}
    },
    {
        "label": "RadialGradient",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.color",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.color",
        "peekOfCode": "class RadialGradient:\n    def __init__(self,\n                 center = torch.tensor([0.0, 0.0]),\n                 radius = torch.tensor([0.0, 0.0]),\n                 offsets = torch.tensor([0.0]),\n                 stop_colors = torch.tensor([0.0, 0.0, 0.0, 0.0])):\n        self.center = center\n        self.radius = radius\n        self.offsets = offsets\n        self.stop_colors = stop_colors",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.color",
        "documentation": {}
    },
    {
        "label": "set_use_gpu",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "peekOfCode": "def set_use_gpu(v):\n    global use_gpu\n    global device\n    use_gpu = v\n    if not use_gpu:\n        device = torch.device('cpu')\ndef get_use_gpu():\n    global use_gpu\n    return use_gpu\ndef set_device(d):",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "get_use_gpu",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "peekOfCode": "def get_use_gpu():\n    global use_gpu\n    return use_gpu\ndef set_device(d):\n    global device\n    global use_gpu\n    device = d\n    use_gpu = device.type == 'cuda'\ndef get_device():\n    global device",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "set_device",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "peekOfCode": "def set_device(d):\n    global device\n    global use_gpu\n    device = d\n    use_gpu = device.type == 'cuda'\ndef get_device():\n    global device\n    return device",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "get_device",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "peekOfCode": "def get_device():\n    global device\n    return device",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "use_gpu",
        "kind": 5,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "peekOfCode": "use_gpu = torch.cuda.is_available()\ndevice = torch.device('cuda') if use_gpu else torch.device('cpu')\ndef set_use_gpu(v):\n    global use_gpu\n    global device\n    use_gpu = v\n    if not use_gpu:\n        device = torch.device('cpu')\ndef get_use_gpu():\n    global use_gpu",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "peekOfCode": "device = torch.device('cuda') if use_gpu else torch.device('cpu')\ndef set_use_gpu(v):\n    global use_gpu\n    global device\n    use_gpu = v\n    if not use_gpu:\n        device = torch.device('cpu')\ndef get_use_gpu():\n    global use_gpu\n    return use_gpu",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "imwrite",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.image",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.image",
        "peekOfCode": "def imwrite(img, filename, gamma = 2.2, normalize = False):\n    directory = os.path.dirname(filename)\n    if directory != '' and not os.path.exists(directory):\n        os.makedirs(directory)\n    if not isinstance(img, np.ndarray):\n        img = img.data.numpy()\n    if normalize:\n        img_rng = np.max(img) - np.min(img)\n        if img_rng > 0:\n            img = (img - np.min(img)) / img_rng",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.image",
        "documentation": {}
    },
    {
        "label": "SvgOptimizationSettings",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.optimize_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.optimize_svg",
        "peekOfCode": "class SvgOptimizationSettings:\n    default_params = {\n        \"optimize_color\": True,\n        \"color_lr\": 2e-3,\n        \"optimize_alpha\": False,\n        \"alpha_lr\": 2e-3,\n        \"optimizer\": \"Adam\",\n        \"transforms\": {\n            \"optimize_transforms\":True,\n            \"transform_mode\":\"rigid\",",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.optimize_svg",
        "documentation": {}
    },
    {
        "label": "OptimizableSvg",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.optimize_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.optimize_svg",
        "peekOfCode": "class OptimizableSvg:\n    class TransformTools:\n        @staticmethod\n        def parse_matrix(vals):\n            assert(len(vals)==6)\n            return np.array([[vals[0],vals[2],vals[4]],[vals[1], vals[3], vals[5]],[0,0,1]])\n        @staticmethod\n        def parse_translate(vals):\n            assert(len(vals)>=1 and len(vals)<=2)\n            mat=np.eye(3)",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.optimize_svg",
        "documentation": {}
    },
    {
        "label": "remove_namespaces",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def remove_namespaces(s):\n    \"\"\"\n        {...} ... -> ...\n    \"\"\"\n    return re.sub('{.*}', '', s)\ndef parse_style(s, defs):\n    style_dict = {}\n    for e in s.split(';'):\n        key_value = e.split(':')\n        if len(key_value) == 2:",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_style",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_style(s, defs):\n    style_dict = {}\n    for e in s.split(';'):\n        key_value = e.split(':')\n        if len(key_value) == 2:\n            key = key_value[0].strip()\n            value = key_value[1].strip()\n            if key == 'fill' or key == 'stroke':\n                # Special case: convert colors into tensor in definitions so\n                # that different shapes can share the same color",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_hex",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_hex(s):\n    \"\"\"\n        Hex to tuple\n    \"\"\"\n    s = s.lstrip('#')\n    if len(s) == 3:\n        s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2]\n    rgb = tuple(int(s[i:i+2], 16) for i in (0, 2, 4))\n    # sRGB to RGB\n    # return torch.pow(torch.tensor([rgb[0] / 255.0, rgb[1] / 255.0, rgb[2] / 255.0]), 2.2)",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_int",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_int(s):\n    \"\"\"\n        trim alphabets\n    \"\"\"\n    return int(float(''.join(i for i in s if (not i.isalpha()))))\ndef parse_color(s, defs):\n    if s is None:\n        return None\n    if isinstance(s, torch.Tensor):\n        return s",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_color",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_color(s, defs):\n    if s is None:\n        return None\n    if isinstance(s, torch.Tensor):\n        return s\n    s = s.lstrip(' ')\n    color = torch.tensor([0.0, 0.0, 0.0, 1.0])\n    if s[0] == '#':\n        color[:3] = parse_hex(s)\n    elif s[:3] == 'url':",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_transform",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_transform(transform_str):\n    \"\"\"\n        Converts a valid SVG transformation string into a 3x3 matrix.\n        If the string is empty or null, this returns a 3x3 identity matrix\n    \"\"\"\n    if not transform_str:\n        return np.identity(3)\n    elif not isinstance(transform_str, str):\n        raise TypeError('Must provide a string to parse')\n    total_transform = np.identity(3)",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_linear_gradient",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_linear_gradient(node, transform, defs):\n    begin = torch.tensor([0.0, 0.0])\n    end = torch.tensor([0.0, 0.0])\n    offsets = []\n    stop_colors = []\n    # Inherit from parent\n    for key in node.attrib:\n        if remove_namespaces(key) == 'href':\n            value = node.attrib[key]\n            parent = defs[value.lstrip('#')]",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_radial_gradient",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_radial_gradient(node, transform, defs):\n    begin = torch.tensor([0.0, 0.0])\n    end = torch.tensor([0.0, 0.0])\n    center = torch.tensor([0.0, 0.0])\n    radius = torch.tensor([0.0, 0.0])\n    offsets = []\n    stop_colors = []\n    # Inherit from parent\n    for key in node.attrib:\n        if remove_namespaces(key) == 'href':",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_stylesheet",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_stylesheet(node, transform, defs):\n    # collect CSS classes\n    sheet = cssutils.parseString(node.text)\n    for rule in sheet:\n        if hasattr(rule, 'selectorText') and hasattr(rule, 'style'):\n            name = rule.selectorText\n            if len(name) >= 2 and name[0] == '.':\n                defs[name[1:]] = parse_style(rule.style.getCssText(), defs)\n    return defs\ndef parse_defs(node, transform, defs):",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_defs",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_defs(node, transform, defs):\n    for child in node:\n        tag = remove_namespaces(child.tag)\n        if tag == 'linearGradient':\n            if 'id' in child.attrib:\n                defs[child.attrib['id']] = parse_linear_gradient(child, transform, defs)\n        elif tag == 'radialGradient':\n            if 'id' in child.attrib:\n                defs[child.attrib['id']] = parse_radial_gradient(child, transform, defs)\n        elif tag == 'style':",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_common_attrib",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_common_attrib(node, transform, fill_color, defs):\n    attribs = {}\n    if 'class' in node.attrib:\n        attribs.update(defs[node.attrib['class']])\n    attribs.update(node.attrib)\n    name = ''\n    if 'id' in node.attrib:\n        name = node.attrib['id']\n    stroke_color = None\n    stroke_width = torch.tensor(0.5)",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "is_shape",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def is_shape(tag):\n    return tag == 'path' or tag == 'polygon' or tag == 'line' or tag == 'circle' or tag == 'rect'\ndef parse_shape(node, transform, fill_color, shapes, shape_groups, defs):\n    tag = remove_namespaces(node.tag)\n    new_transform, new_fill_color, stroke_color, stroke_width, use_even_odd_rule = \\\n        parse_common_attrib(node, transform, fill_color, defs)\n    if tag == 'path':\n        d = node.attrib['d']\n        name = ''\n        if 'id' in node.attrib:",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_shape",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_shape(node, transform, fill_color, shapes, shape_groups, defs):\n    tag = remove_namespaces(node.tag)\n    new_transform, new_fill_color, stroke_color, stroke_width, use_even_odd_rule = \\\n        parse_common_attrib(node, transform, fill_color, defs)\n    if tag == 'path':\n        d = node.attrib['d']\n        name = ''\n        if 'id' in node.attrib:\n            name = node.attrib['id']\n        force_closing = new_fill_color is not None",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_group",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_group(node, transform, fill_color, shapes, shape_groups, defs):\n    if 'transform' in node.attrib:\n        transform = transform @ parse_transform(node.attrib['transform'])\n    if 'fill' in node.attrib:\n        fill_color = parse_color(node.attrib['fill'], defs)\n    for child in node:\n        tag = remove_namespaces(child.tag)\n        if is_shape(tag):\n            shapes, shape_groups = parse_shape(\\\n                child, transform, fill_color, shapes, shape_groups, defs)",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_scene",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def parse_scene(node):\n    canvas_width = -1\n    canvas_height = -1\n    defs = {}\n    shapes = []\n    shape_groups = []\n    fill_color = torch.tensor([0.0, 0.0, 0.0, 1.0])\n    transform = torch.eye(3)\n    if 'viewBox' in node.attrib:\n        view_box_array = node.attrib['viewBox'].split()",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "svg_to_scene",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "peekOfCode": "def svg_to_scene(filename):\n    \"\"\"\n        Load from a SVG file and convert to PyTorch tensors.\n    \"\"\"\n    tree = etree.parse(filename)\n    root = tree.getroot()\n    cwd = os.getcwd()\n    if (os.path.dirname(filename) != ''):\n        os.chdir(os.path.dirname(filename))\n    ret = parse_scene(root)",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "PixelFilter",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.pixel_filter",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.pixel_filter",
        "peekOfCode": "class PixelFilter:\n    def __init__(self,\n                 type,\n                 radius = torch.tensor(0.5)):\n        self.type = type\n        self.radius = radius",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.pixel_filter",
        "documentation": {}
    },
    {
        "label": "OutputType",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "peekOfCode": "class OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass RenderFunction(torch.autograd.Function):\n    \"\"\"\n        The PyTorch interface of diffvg.\n    \"\"\"\n    @staticmethod\n    def serialize_scene(canvas_width,\n                        canvas_height,",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "documentation": {}
    },
    {
        "label": "RenderFunction",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "peekOfCode": "class RenderFunction(torch.autograd.Function):\n    \"\"\"\n        The PyTorch interface of diffvg.\n    \"\"\"\n    @staticmethod\n    def serialize_scene(canvas_width,\n                        canvas_height,\n                        shapes,\n                        shape_groups,\n                        filter = pydiffvg.PixelFilter(type = diffvg.FilterType.box,",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "documentation": {}
    },
    {
        "label": "set_print_timing",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "peekOfCode": "def set_print_timing(val):\n    global print_timing\n    print_timing=val\nclass OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass RenderFunction(torch.autograd.Function):\n    \"\"\"\n        The PyTorch interface of diffvg.\n    \"\"\"",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "documentation": {}
    },
    {
        "label": "print_timing",
        "kind": 5,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "peekOfCode": "print_timing = False\ndef set_print_timing(val):\n    global print_timing\n    print_timing=val\nclass OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass RenderFunction(torch.autograd.Function):\n    \"\"\"\n        The PyTorch interface of diffvg.",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.render_pytorch",
        "documentation": {}
    },
    {
        "label": "prettify",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.save_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.save_svg",
        "peekOfCode": "def prettify(elem):\n    \"\"\"Return a pretty-printed XML string for the Element.\n    \"\"\"\n    rough_string = etree.tostring(elem, 'utf-8')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent=\"  \")\ndef save_svg(filename, width, height, shapes, shape_groups, use_gamma = False):\n    root = etree.Element('svg')\n    root.set('version', '1.1')\n    root.set('xmlns', 'http://www.w3.org/2000/svg')",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.save_svg",
        "documentation": {}
    },
    {
        "label": "save_svg",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.save_svg",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.save_svg",
        "peekOfCode": "def save_svg(filename, width, height, shapes, shape_groups, use_gamma = False):\n    root = etree.Element('svg')\n    root.set('version', '1.1')\n    root.set('xmlns', 'http://www.w3.org/2000/svg')\n    root.set('width', str(width))\n    root.set('height', str(height))\n    defs = etree.SubElement(root, 'defs')\n    g = etree.SubElement(root, 'g')\n    if use_gamma:\n        f = etree.SubElement(defs, 'filter')",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.save_svg",
        "documentation": {}
    },
    {
        "label": "Circle",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "peekOfCode": "class Circle:\n    def __init__(self, radius, center, stroke_width = torch.tensor(1.0), id = ''):\n        self.radius = radius\n        self.center = center\n        self.stroke_width = stroke_width\n        self.id = id\nclass Ellipse:\n    def __init__(self, radius, center, stroke_width = torch.tensor(1.0), id = ''):\n        self.radius = radius\n        self.center = center",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "Ellipse",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "peekOfCode": "class Ellipse:\n    def __init__(self, radius, center, stroke_width = torch.tensor(1.0), id = ''):\n        self.radius = radius\n        self.center = center\n        self.stroke_width = stroke_width\n        self.id = id\nclass Path:\n    def __init__(self,\n                 num_control_points,\n                 points,",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "Path",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "peekOfCode": "class Path:\n    def __init__(self,\n                 num_control_points,\n                 points,\n                 is_closed,\n                 stroke_width = torch.tensor(1.0),\n                 id = '',\n                 use_distance_approx = False):\n        self.num_control_points = num_control_points\n        self.points = points",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "peekOfCode": "class Polygon:\n    def __init__(self, points, is_closed, stroke_width = torch.tensor(1.0), id = ''):\n        self.points = points\n        self.is_closed = is_closed\n        self.stroke_width = stroke_width\n        self.id = id\nclass Rect:\n    def __init__(self, p_min, p_max, stroke_width = torch.tensor(1.0), id = ''):\n        self.p_min = p_min\n        self.p_max = p_max",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "Rect",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "peekOfCode": "class Rect:\n    def __init__(self, p_min, p_max, stroke_width = torch.tensor(1.0), id = ''):\n        self.p_min = p_min\n        self.p_max = p_max\n        self.stroke_width = stroke_width\n        self.id = id\nclass ShapeGroup:\n    def __init__(self,\n                 shape_ids,\n                 fill_color,",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "ShapeGroup",
        "kind": 6,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "peekOfCode": "class ShapeGroup:\n    def __init__(self,\n                 shape_ids,\n                 fill_color,\n                 use_even_odd_rule = True,\n                 stroke_color = None,\n                 shape_to_canvas = torch.eye(3),\n                 id = ''):\n        self.shape_ids = shape_ids\n        self.fill_color = fill_color",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "from_svg_path",
        "kind": 2,
        "importPath": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "description": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "peekOfCode": "def from_svg_path(path_str, shape_to_canvas = torch.eye(3), force_close = False):\n    path = svgpathtools.parse_path(path_str)\n    if len(path) == 0:\n        return []\n    ret_paths = []\n    subpaths = path.continuous_subpaths()\n    for subpath in subpaths:\n        if subpath.isclosed():\n            if len(subpath) > 1 and isinstance(subpath[-1], svgpathtools.Line) and subpath[-1].length() < 1e-5:\n                subpath.remove(subpath[-1])",
        "detail": "build.lib.linux-x86_64-cpython-38.pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "generate_dummy_code_pybind11",
        "kind": 2,
        "importPath": "pybind11.docs.benchmark",
        "description": "pybind11.docs.benchmark",
        "peekOfCode": "def generate_dummy_code_pybind11(nclasses=10):\n    decl = \"\"\n    bindings = \"\"\n    for cl in range(nclasses):\n        decl += \"class cl%03i;\\n\" % cl\n    decl += '\\n'\n    for cl in range(nclasses):\n        decl += \"class cl%03i {\\n\" % cl\n        decl += \"public:\\n\"\n        bindings += '    py::class_<cl%03i>(m, \"cl%03i\")\\n' % (cl, cl)",
        "detail": "pybind11.docs.benchmark",
        "documentation": {}
    },
    {
        "label": "generate_dummy_code_boost",
        "kind": 2,
        "importPath": "pybind11.docs.benchmark",
        "description": "pybind11.docs.benchmark",
        "peekOfCode": "def generate_dummy_code_boost(nclasses=10):\n    decl = \"\"\n    bindings = \"\"\n    for cl in range(nclasses):\n        decl += \"class cl%03i;\\n\" % cl\n    decl += '\\n'\n    for cl in range(nclasses):\n        decl += \"class cl%03i {\\n\" % cl\n        decl += \"public:\\n\"\n        bindings += '    py::class_<cl%03i>(\"cl%03i\")\\n' % (cl, cl)",
        "detail": "pybind11.docs.benchmark",
        "documentation": {}
    },
    {
        "label": "nfns",
        "kind": 5,
        "importPath": "pybind11.docs.benchmark",
        "description": "pybind11.docs.benchmark",
        "peekOfCode": "nfns = 4  # Functions per class\nnargs = 4  # Arguments per function\ndef generate_dummy_code_pybind11(nclasses=10):\n    decl = \"\"\n    bindings = \"\"\n    for cl in range(nclasses):\n        decl += \"class cl%03i;\\n\" % cl\n    decl += '\\n'\n    for cl in range(nclasses):\n        decl += \"class cl%03i {\\n\" % cl",
        "detail": "pybind11.docs.benchmark",
        "documentation": {}
    },
    {
        "label": "nargs",
        "kind": 5,
        "importPath": "pybind11.docs.benchmark",
        "description": "pybind11.docs.benchmark",
        "peekOfCode": "nargs = 4  # Arguments per function\ndef generate_dummy_code_pybind11(nclasses=10):\n    decl = \"\"\n    bindings = \"\"\n    for cl in range(nclasses):\n        decl += \"class cl%03i;\\n\" % cl\n    decl += '\\n'\n    for cl in range(nclasses):\n        decl += \"class cl%03i {\\n\" % cl\n        decl += \"public:\\n\"",
        "detail": "pybind11.docs.benchmark",
        "documentation": {}
    },
    {
        "label": "generate_doxygen_xml",
        "kind": 2,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "def generate_doxygen_xml(app):\n    build_dir = os.path.join(app.confdir, '.build')\n    if not os.path.exists(build_dir):\n        os.mkdir(build_dir)\n    try:\n        subprocess.call(['doxygen', '--version'])\n        retcode = subprocess.call(['doxygen'], cwd=app.confdir)\n        if retcode < 0:\n            sys.stderr.write(\"doxygen error code: {}\\n\".format(-retcode))\n    except OSError as e:",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "def setup(app):\n    \"\"\"Add hook for building doxygen xml when needed\"\"\"\n    app.connect(\"builder-inited\", generate_doxygen_xml)",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#needs_sphinx",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = ['breathe']\nbreathe_projects = {'pybind11': '.build/doxygenxml/'}\nbreathe_default_project = 'pybind11'\nbreathe_domain_by_extension = {'h': 'cpp'}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['.templates']",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "extensions = ['breathe']\nbreathe_projects = {'pybind11': '.build/doxygenxml/'}\nbreathe_default_project = 'pybind11'\nbreathe_domain_by_extension = {'h': 'cpp'}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['.templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "breathe_projects",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "breathe_projects = {'pybind11': '.build/doxygenxml/'}\nbreathe_default_project = 'pybind11'\nbreathe_domain_by_extension = {'h': 'cpp'}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['.templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The encoding of source files.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "breathe_default_project",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "breathe_default_project = 'pybind11'\nbreathe_domain_by_extension = {'h': 'cpp'}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['.templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "breathe_domain_by_extension",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "breathe_domain_by_extension = {'h': 'cpp'}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['.templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "templates_path = ['.templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "source_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = 'pybind11'\ncopyright = '2017, Wenzel Jakob'\nauthor = 'Wenzel Jakob'\n# The version info for the project you're documenting, acts as replacement for",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#source_encoding",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = 'pybind11'\ncopyright = '2017, Wenzel Jakob'\nauthor = 'Wenzel Jakob'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "master_doc = 'index'\n# General information about the project.\nproject = 'pybind11'\ncopyright = '2017, Wenzel Jakob'\nauthor = 'Wenzel Jakob'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "project = 'pybind11'\ncopyright = '2017, Wenzel Jakob'\nauthor = 'Wenzel Jakob'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '2.5'\n# The full version, including alpha/beta/rc tags.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "copyright = '2017, Wenzel Jakob'\nauthor = 'Wenzel Jakob'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '2.5'\n# The full version, including alpha/beta/rc tags.\nrelease = '2.5.dev1'",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "author = 'Wenzel Jakob'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '2.5'\n# The full version, including alpha/beta/rc tags.\nrelease = '2.5.dev1'\n# The language for content autogenerated by Sphinx. Refer to documentation",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "version = '2.5'\n# The full version, including alpha/beta/rc tags.\nrelease = '2.5.dev1'\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# There are two options for replacing |today|: either, you set today to some",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "release = '2.5.dev1'\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "language",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['.build', 'release.rst']\n# The reST default role (used for this markup: `text`) to use for all",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#today",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['.build', 'release.rst']\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\ndefault_role = 'any'\n# If true, '()' will be appended to :func: etc. cross-reference text.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#today_fmt",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['.build', 'release.rst']\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\ndefault_role = 'any'\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "exclude_patterns = ['.build', 'release.rst']\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\ndefault_role = 'any'\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "default_role",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "default_role = 'any'\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#add_function_parentheses",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\n#pygments_style = 'monokai'\n# A list of ignored prefixes for module index sorting.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#add_module_names",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\n#pygments_style = 'monokai'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#show_authors",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\n#pygments_style = 'monokai'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#pygments_style",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#pygments_style = 'monokai'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#modindex_common_prefix",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#modindex_common_prefix = []\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\non_rtd = os.environ.get('READTHEDOCS', None) == 'True'\nif not on_rtd:  # only import and set the theme if we're building docs locally",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#keep_warnings",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#keep_warnings = False\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\non_rtd = os.environ.get('READTHEDOCS', None) == 'True'\nif not on_rtd:  # only import and set the theme if we're building docs locally\n    import sphinx_rtd_theme\n    html_theme = 'sphinx_rtd_theme'",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "todo_include_todos",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "todo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\non_rtd = os.environ.get('READTHEDOCS', None) == 'True'\nif not on_rtd:  # only import and set the theme if we're building docs locally\n    import sphinx_rtd_theme\n    html_theme = 'sphinx_rtd_theme'\n    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n    html_context = {",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "on_rtd",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "on_rtd = os.environ.get('READTHEDOCS', None) == 'True'\nif not on_rtd:  # only import and set the theme if we're building docs locally\n    import sphinx_rtd_theme\n    html_theme = 'sphinx_rtd_theme'\n    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n    html_context = {\n        'css_files': [\n            '_static/theme_overrides.css'\n        ]\n    }",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_options",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_path",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_title",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_short_title",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_logo",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n# Add any extra paths that contain custom files (such as robots.txt or",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_favicon",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "html_static_path = ['_static']\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_extra_path",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_extra_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_last_updated_fmt",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_smartypants",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_sidebars",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_additional_pages",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_domain_indices",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_index",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_split_index",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sourcelink",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sphinx",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Language to be used for generating the HTML full-text search index.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_copyright",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_opensearch",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'\n#html_search_language = 'en'\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_file_suffix",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_file_suffix = None\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'\n#html_search_language = 'en'\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value\n#html_search_options = {'type': 'default'}\n# The name of a javascript file (relative to the configuration directory) that",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_search_language",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_search_language = 'en'\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value\n#html_search_options = {'type': 'default'}\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = 'scorer.js'\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'pybind11doc'\n# -- Options for LaTeX output ---------------------------------------------",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_search_options",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_search_options = {'type': 'default'}\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = 'scorer.js'\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'pybind11doc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_search_scorer",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#html_search_scorer = 'scorer.js'\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'pybind11doc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "htmlhelp_basename = 'pybind11doc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.\n'preamble': r'\\DeclareUnicodeCharacter{00A0}{}',\n# Latex figure (float) alignment",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "latex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.\n'preamble': r'\\DeclareUnicodeCharacter{00A0}{}',\n# Latex figure (float) alignment\n#'figure_align': 'htbp',\n}",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "latex_documents = [\n  (master_doc, 'pybind11.tex', 'pybind11 Documentation',\n   'Wenzel Jakob', 'manual'),\n]\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = 'pybind11-logo.png'\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_use_parts",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#latex_use_parts = False\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_show_pagerefs",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_show_urls",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'pybind11', 'pybind11 Documentation',",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_appendices",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'pybind11', 'pybind11 Documentation',\n     [author], 1)\n]",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_domain_indices",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#latex_domain_indices = True\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'pybind11', 'pybind11 Documentation',\n     [author], 1)\n]\n# If true, show URL addresses after external links.\n#man_show_urls = False",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "man_pages = [\n    (master_doc, 'pybind11', 'pybind11 Documentation',\n     [author], 1)\n]\n# If true, show URL addresses after external links.\n#man_show_urls = False\n# -- Options for Texinfo output -------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#man_show_urls",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#man_show_urls = False\n# -- Options for Texinfo output -------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  (master_doc, 'pybind11', 'pybind11 Documentation',\n   author, 'pybind11', 'One line description of project.',\n   'Miscellaneous'),\n]",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "texinfo_documents = [\n  (master_doc, 'pybind11', 'pybind11 Documentation',\n   author, 'pybind11', 'One line description of project.',\n   'Miscellaneous'),\n]\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_appendices",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#texinfo_appendices = []\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\nprimary_domain = 'cpp'\nhighlight_language = 'cpp'\ndef generate_doxygen_xml(app):",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_domain_indices",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\nprimary_domain = 'cpp'\nhighlight_language = 'cpp'\ndef generate_doxygen_xml(app):\n    build_dir = os.path.join(app.confdir, '.build')\n    if not os.path.exists(build_dir):",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_show_urls",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#texinfo_show_urls = 'footnote'\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\nprimary_domain = 'cpp'\nhighlight_language = 'cpp'\ndef generate_doxygen_xml(app):\n    build_dir = os.path.join(app.confdir, '.build')\n    if not os.path.exists(build_dir):\n        os.mkdir(build_dir)\n    try:",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_no_detailmenu",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "#texinfo_no_detailmenu = False\nprimary_domain = 'cpp'\nhighlight_language = 'cpp'\ndef generate_doxygen_xml(app):\n    build_dir = os.path.join(app.confdir, '.build')\n    if not os.path.exists(build_dir):\n        os.mkdir(build_dir)\n    try:\n        subprocess.call(['doxygen', '--version'])\n        retcode = subprocess.call(['doxygen'], cwd=app.confdir)",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "primary_domain",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "primary_domain = 'cpp'\nhighlight_language = 'cpp'\ndef generate_doxygen_xml(app):\n    build_dir = os.path.join(app.confdir, '.build')\n    if not os.path.exists(build_dir):\n        os.mkdir(build_dir)\n    try:\n        subprocess.call(['doxygen', '--version'])\n        retcode = subprocess.call(['doxygen'], cwd=app.confdir)\n        if retcode < 0:",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "highlight_language",
        "kind": 5,
        "importPath": "pybind11.docs.conf",
        "description": "pybind11.docs.conf",
        "peekOfCode": "highlight_language = 'cpp'\ndef generate_doxygen_xml(app):\n    build_dir = os.path.join(app.confdir, '.build')\n    if not os.path.exists(build_dir):\n        os.mkdir(build_dir)\n    try:\n        subprocess.call(['doxygen', '--version'])\n        retcode = subprocess.call(['doxygen'], cwd=app.confdir)\n        if retcode < 0:\n            sys.stderr.write(\"doxygen error code: {}\\n\".format(-retcode))",
        "detail": "pybind11.docs.conf",
        "documentation": {}
    },
    {
        "label": "version_info",
        "kind": 5,
        "importPath": "pybind11.pybind11._version",
        "description": "pybind11.pybind11._version",
        "peekOfCode": "version_info = (2, 5, 'dev1')\n__version__ = '.'.join(map(str, version_info))",
        "detail": "pybind11.pybind11._version",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "pybind11.pybind11._version",
        "description": "pybind11.pybind11._version",
        "peekOfCode": "__version__ = '.'.join(map(str, version_info))",
        "detail": "pybind11.pybind11._version",
        "documentation": {}
    },
    {
        "label": "DerivedWidget",
        "kind": 6,
        "importPath": "pybind11.tests.test_embed.test_interpreter",
        "description": "pybind11.tests.test_embed.test_interpreter",
        "peekOfCode": "class DerivedWidget(Widget):\n    def __init__(self, message):\n        super(DerivedWidget, self).__init__(message)\n    def the_answer(self):\n        return 42",
        "detail": "pybind11.tests.test_embed.test_interpreter",
        "documentation": {}
    },
    {
        "label": "Output",
        "kind": 6,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "class Output(object):\n    \"\"\"Basic output post-processing and comparison\"\"\"\n    def __init__(self, string):\n        self.string = string\n        self.explanation = []\n    def __str__(self):\n        return self.string\n    def __eq__(self, other):\n        # Ignore constructor/destructor output which is prefixed with \"###\"\n        a = [line for line in self.string.strip().splitlines() if not line.startswith(\"###\")]",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "Unordered",
        "kind": 6,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "class Unordered(Output):\n    \"\"\"Custom comparison for output without strict line ordering\"\"\"\n    def __eq__(self, other):\n        a = _split_and_sort(self.string)\n        b = _split_and_sort(other)\n        if a == b:\n            return True\n        else:\n            self.explanation = _make_explanation(a, b)\n            return False",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "Capture",
        "kind": 6,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "class Capture(object):\n    def __init__(self, capfd):\n        self.capfd = capfd\n        self.out = \"\"\n        self.err = \"\"\n    def __enter__(self):\n        self.capfd.readouterr()\n        return self\n    def __exit__(self, *args):\n        self.out, self.err = self.capfd.readouterr()",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "SanitizedString",
        "kind": 6,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "class SanitizedString(object):\n    def __init__(self, sanitizer):\n        self.sanitizer = sanitizer\n        self.string = \"\"\n        self.explanation = []\n    def __call__(self, thing):\n        self.string = self.sanitizer(thing)\n        return self\n    def __eq__(self, other):\n        a = self.string",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "capture",
        "kind": 2,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "def capture(capsys):\n    \"\"\"Extended `capsys` with context manager and custom equality operators\"\"\"\n    return Capture(capsys)\nclass SanitizedString(object):\n    def __init__(self, sanitizer):\n        self.sanitizer = sanitizer\n        self.string = \"\"\n        self.explanation = []\n    def __call__(self, thing):\n        self.string = self.sanitizer(thing)",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "doc",
        "kind": 2,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "def doc():\n    \"\"\"Sanitize docstrings and add custom failure explanation\"\"\"\n    return SanitizedString(_sanitize_docstring)\ndef _sanitize_message(thing):\n    s = str(thing)\n    s = _sanitize_general(s)\n    s = _hexadecimal.sub(\"0\", s)\n    return s\n@pytest.fixture\ndef msg():",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "msg",
        "kind": 2,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "def msg():\n    \"\"\"Sanitize messages and add custom failure explanation\"\"\"\n    return SanitizedString(_sanitize_message)\n# noinspection PyUnusedLocal\ndef pytest_assertrepr_compare(op, left, right):\n    \"\"\"Hook to insert custom failure explanation\"\"\"\n    if hasattr(left, 'explanation'):\n        return left.explanation\n@contextlib.contextmanager\ndef suppress(exception):",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_assertrepr_compare",
        "kind": 2,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "def pytest_assertrepr_compare(op, left, right):\n    \"\"\"Hook to insert custom failure explanation\"\"\"\n    if hasattr(left, 'explanation'):\n        return left.explanation\n@contextlib.contextmanager\ndef suppress(exception):\n    \"\"\"Suppress the desired exception\"\"\"\n    try:\n        yield\n    except exception:",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "suppress",
        "kind": 2,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "def suppress(exception):\n    \"\"\"Suppress the desired exception\"\"\"\n    try:\n        yield\n    except exception:\n        pass\ndef gc_collect():\n    ''' Run the garbage collector twice (needed when running\n    reference counting tests with PyPy) '''\n    gc.collect()",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "gc_collect",
        "kind": 2,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "def gc_collect():\n    ''' Run the garbage collector twice (needed when running\n    reference counting tests with PyPy) '''\n    gc.collect()\n    gc.collect()\ndef pytest_configure():\n    pytest.suppress = suppress\n    pytest.gc_collect = gc_collect",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "def pytest_configure():\n    pytest.suppress = suppress\n    pytest.gc_collect = gc_collect",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "_unicode_marker",
        "kind": 5,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "_unicode_marker = re.compile(r'u(\\'[^\\']*\\')')\n_long_marker = re.compile(r'([0-9])L')\n_hexadecimal = re.compile(r'0x[0-9a-fA-F]+')\n# Avoid collecting Python3 only files\ncollect_ignore = []\nif env.PY2:\n    collect_ignore.append(\"test_async.py\")\ndef _strip_and_dedent(s):\n    \"\"\"For triple-quote strings\"\"\"\n    return textwrap.dedent(s.lstrip('\\n').rstrip())",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "_long_marker",
        "kind": 5,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "_long_marker = re.compile(r'([0-9])L')\n_hexadecimal = re.compile(r'0x[0-9a-fA-F]+')\n# Avoid collecting Python3 only files\ncollect_ignore = []\nif env.PY2:\n    collect_ignore.append(\"test_async.py\")\ndef _strip_and_dedent(s):\n    \"\"\"For triple-quote strings\"\"\"\n    return textwrap.dedent(s.lstrip('\\n').rstrip())\ndef _split_and_sort(s):",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "_hexadecimal",
        "kind": 5,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "_hexadecimal = re.compile(r'0x[0-9a-fA-F]+')\n# Avoid collecting Python3 only files\ncollect_ignore = []\nif env.PY2:\n    collect_ignore.append(\"test_async.py\")\ndef _strip_and_dedent(s):\n    \"\"\"For triple-quote strings\"\"\"\n    return textwrap.dedent(s.lstrip('\\n').rstrip())\ndef _split_and_sort(s):\n    \"\"\"For output which does not require specific line order\"\"\"",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "collect_ignore",
        "kind": 5,
        "importPath": "pybind11.tests.conftest",
        "description": "pybind11.tests.conftest",
        "peekOfCode": "collect_ignore = []\nif env.PY2:\n    collect_ignore.append(\"test_async.py\")\ndef _strip_and_dedent(s):\n    \"\"\"For triple-quote strings\"\"\"\n    return textwrap.dedent(s.lstrip('\\n').rstrip())\ndef _split_and_sort(s):\n    \"\"\"For output which does not require specific line order\"\"\"\n    return sorted(_strip_and_dedent(s).splitlines())\ndef _make_explanation(a, b):",
        "detail": "pybind11.tests.conftest",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "kind": 5,
        "importPath": "pybind11.tests.env",
        "description": "pybind11.tests.env",
        "peekOfCode": "LINUX = sys.platform.startswith(\"linux\")\nMACOS = sys.platform.startswith(\"darwin\")\nWIN = sys.platform.startswith(\"win32\") or sys.platform.startswith(\"cygwin\")\nCPYTHON = platform.python_implementation() == \"CPython\"\nPYPY = platform.python_implementation() == \"PyPy\"\nPY2 = sys.version_info.major == 2\nPY = sys.version_info",
        "detail": "pybind11.tests.env",
        "documentation": {}
    },
    {
        "label": "MACOS",
        "kind": 5,
        "importPath": "pybind11.tests.env",
        "description": "pybind11.tests.env",
        "peekOfCode": "MACOS = sys.platform.startswith(\"darwin\")\nWIN = sys.platform.startswith(\"win32\") or sys.platform.startswith(\"cygwin\")\nCPYTHON = platform.python_implementation() == \"CPython\"\nPYPY = platform.python_implementation() == \"PyPy\"\nPY2 = sys.version_info.major == 2\nPY = sys.version_info",
        "detail": "pybind11.tests.env",
        "documentation": {}
    },
    {
        "label": "WIN",
        "kind": 5,
        "importPath": "pybind11.tests.env",
        "description": "pybind11.tests.env",
        "peekOfCode": "WIN = sys.platform.startswith(\"win32\") or sys.platform.startswith(\"cygwin\")\nCPYTHON = platform.python_implementation() == \"CPython\"\nPYPY = platform.python_implementation() == \"PyPy\"\nPY2 = sys.version_info.major == 2\nPY = sys.version_info",
        "detail": "pybind11.tests.env",
        "documentation": {}
    },
    {
        "label": "CPYTHON",
        "kind": 5,
        "importPath": "pybind11.tests.env",
        "description": "pybind11.tests.env",
        "peekOfCode": "CPYTHON = platform.python_implementation() == \"CPython\"\nPYPY = platform.python_implementation() == \"PyPy\"\nPY2 = sys.version_info.major == 2\nPY = sys.version_info",
        "detail": "pybind11.tests.env",
        "documentation": {}
    },
    {
        "label": "PYPY",
        "kind": 5,
        "importPath": "pybind11.tests.env",
        "description": "pybind11.tests.env",
        "peekOfCode": "PYPY = platform.python_implementation() == \"PyPy\"\nPY2 = sys.version_info.major == 2\nPY = sys.version_info",
        "detail": "pybind11.tests.env",
        "documentation": {}
    },
    {
        "label": "PY2",
        "kind": 5,
        "importPath": "pybind11.tests.env",
        "description": "pybind11.tests.env",
        "peekOfCode": "PY2 = sys.version_info.major == 2\nPY = sys.version_info",
        "detail": "pybind11.tests.env",
        "documentation": {}
    },
    {
        "label": "PY",
        "kind": 5,
        "importPath": "pybind11.tests.env",
        "description": "pybind11.tests.env",
        "peekOfCode": "PY = sys.version_info",
        "detail": "pybind11.tests.env",
        "documentation": {}
    },
    {
        "label": "event_loop",
        "kind": 2,
        "importPath": "pybind11.tests.test_async",
        "description": "pybind11.tests.test_async",
        "peekOfCode": "def event_loop():\n    loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()\nasync def get_await_result(x):\n    return await x\ndef test_await(event_loop):\n    assert 5 == event_loop.run_until_complete(get_await_result(m.SupportsAsync()))\ndef test_await_missing(event_loop):\n    with pytest.raises(TypeError):",
        "detail": "pybind11.tests.test_async",
        "documentation": {}
    },
    {
        "label": "test_await",
        "kind": 2,
        "importPath": "pybind11.tests.test_async",
        "description": "pybind11.tests.test_async",
        "peekOfCode": "def test_await(event_loop):\n    assert 5 == event_loop.run_until_complete(get_await_result(m.SupportsAsync()))\ndef test_await_missing(event_loop):\n    with pytest.raises(TypeError):\n        event_loop.run_until_complete(get_await_result(m.DoesNotSupportAsync()))",
        "detail": "pybind11.tests.test_async",
        "documentation": {}
    },
    {
        "label": "test_await_missing",
        "kind": 2,
        "importPath": "pybind11.tests.test_async",
        "description": "pybind11.tests.test_async",
        "peekOfCode": "def test_await_missing(event_loop):\n    with pytest.raises(TypeError):\n        event_loop.run_until_complete(get_await_result(m.DoesNotSupportAsync()))",
        "detail": "pybind11.tests.test_async",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 5,
        "importPath": "pybind11.tests.test_async",
        "description": "pybind11.tests.test_async",
        "peekOfCode": "asyncio = pytest.importorskip(\"asyncio\")\nm = pytest.importorskip(\"pybind11_tests.async_module\")\n@pytest.fixture\ndef event_loop():\n    loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()\nasync def get_await_result(x):\n    return await x\ndef test_await(event_loop):",
        "detail": "pybind11.tests.test_async",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "pybind11.tests.test_async",
        "description": "pybind11.tests.test_async",
        "peekOfCode": "m = pytest.importorskip(\"pybind11_tests.async_module\")\n@pytest.fixture\ndef event_loop():\n    loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()\nasync def get_await_result(x):\n    return await x\ndef test_await(event_loop):\n    assert 5 == event_loop.run_until_complete(get_await_result(m.SupportsAsync()))",
        "detail": "pybind11.tests.test_async",
        "documentation": {}
    },
    {
        "label": "test_from_python",
        "kind": 2,
        "importPath": "pybind11.tests.test_buffers",
        "description": "pybind11.tests.test_buffers",
        "peekOfCode": "def test_from_python():\n    with pytest.raises(RuntimeError) as excinfo:\n        m.Matrix(np.array([1, 2, 3]))  # trying to assign a 1D array\n    assert str(excinfo.value) == \"Incompatible buffer format!\"\n    m3 = np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)\n    m4 = m.Matrix(m3)\n    for i in range(m4.rows()):\n        for j in range(m4.cols()):\n            assert m3[i, j] == m4[i, j]\n    cstats = ConstructorStats.get(m.Matrix)",
        "detail": "pybind11.tests.test_buffers",
        "documentation": {}
    },
    {
        "label": "test_to_python",
        "kind": 2,
        "importPath": "pybind11.tests.test_buffers",
        "description": "pybind11.tests.test_buffers",
        "peekOfCode": "def test_to_python():\n    mat = m.Matrix(5, 4)\n    assert memoryview(mat).shape == (5, 4)\n    assert mat[2, 3] == 0\n    mat[2, 3] = 4.0\n    mat[3, 2] = 7.0\n    assert mat[2, 3] == 4\n    assert mat[3, 2] == 7\n    assert struct.unpack_from('f', mat, (3 * 4 + 2) * 4) == (7, )\n    assert struct.unpack_from('f', mat, (2 * 4 + 3) * 4) == (4, )",
        "detail": "pybind11.tests.test_buffers",
        "documentation": {}
    },
    {
        "label": "test_inherited_protocol",
        "kind": 2,
        "importPath": "pybind11.tests.test_buffers",
        "description": "pybind11.tests.test_buffers",
        "peekOfCode": "def test_inherited_protocol():\n    \"\"\"SquareMatrix is derived from Matrix and inherits the buffer protocol\"\"\"\n    matrix = m.SquareMatrix(5)\n    assert memoryview(matrix).shape == (5, 5)\n    assert np.asarray(matrix).shape == (5, 5)\ndef test_pointer_to_member_fn():\n    for cls in [m.Buffer, m.ConstBuffer, m.DerivedBuffer]:\n        buf = cls()\n        buf.value = 0x12345678\n        value = struct.unpack('i', bytearray(buf))[0]",
        "detail": "pybind11.tests.test_buffers",
        "documentation": {}
    },
    {
        "label": "test_pointer_to_member_fn",
        "kind": 2,
        "importPath": "pybind11.tests.test_buffers",
        "description": "pybind11.tests.test_buffers",
        "peekOfCode": "def test_pointer_to_member_fn():\n    for cls in [m.Buffer, m.ConstBuffer, m.DerivedBuffer]:\n        buf = cls()\n        buf.value = 0x12345678\n        value = struct.unpack('i', bytearray(buf))[0]\n        assert value == 0x12345678\ndef test_readonly_buffer():\n    buf = m.BufferReadOnly(0x64)\n    view = memoryview(buf)\n    assert view[0] == b'd' if env.PY2 else 0x64",
        "detail": "pybind11.tests.test_buffers",
        "documentation": {}
    },
    {
        "label": "test_readonly_buffer",
        "kind": 2,
        "importPath": "pybind11.tests.test_buffers",
        "description": "pybind11.tests.test_buffers",
        "peekOfCode": "def test_readonly_buffer():\n    buf = m.BufferReadOnly(0x64)\n    view = memoryview(buf)\n    assert view[0] == b'd' if env.PY2 else 0x64\n    assert view.readonly\ndef test_selective_readonly_buffer():\n    buf = m.BufferReadOnlySelect()\n    memoryview(buf)[0] = b'd' if env.PY2 else 0x64\n    assert buf.value == 0x64\n    io.BytesIO(b'A').readinto(buf)",
        "detail": "pybind11.tests.test_buffers",
        "documentation": {}
    },
    {
        "label": "test_selective_readonly_buffer",
        "kind": 2,
        "importPath": "pybind11.tests.test_buffers",
        "description": "pybind11.tests.test_buffers",
        "peekOfCode": "def test_selective_readonly_buffer():\n    buf = m.BufferReadOnlySelect()\n    memoryview(buf)[0] = b'd' if env.PY2 else 0x64\n    assert buf.value == 0x64\n    io.BytesIO(b'A').readinto(buf)\n    assert buf.value == ord(b'A')\n    buf.readonly = True\n    with pytest.raises(TypeError):\n        memoryview(buf)[0] = b'\\0' if env.PY2 else 0\n    with pytest.raises(TypeError):",
        "detail": "pybind11.tests.test_buffers",
        "documentation": {}
    },
    {
        "label": "np",
        "kind": 5,
        "importPath": "pybind11.tests.test_buffers",
        "description": "pybind11.tests.test_buffers",
        "peekOfCode": "np = pytest.importorskip(\"numpy\")\ndef test_from_python():\n    with pytest.raises(RuntimeError) as excinfo:\n        m.Matrix(np.array([1, 2, 3]))  # trying to assign a 1D array\n    assert str(excinfo.value) == \"Incompatible buffer format!\"\n    m3 = np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)\n    m4 = m.Matrix(m3)\n    for i in range(m4.rows()):\n        for j in range(m4.cols()):\n            assert m3[i, j] == m4[i, j]",
        "detail": "pybind11.tests.test_buffers",
        "documentation": {}
    },
    {
        "label": "test_simple_string",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_simple_string():\n    assert m.string_roundtrip(\"const char *\") == \"const char *\"\ndef test_unicode_conversion():\n    \"\"\"Tests unicode conversion and error reporting.\"\"\"\n    assert m.good_utf8_string() == u\"Say utf8‽ 🎂 𝐀\"\n    assert m.good_utf16_string() == u\"b‽🎂𝐀z\"\n    assert m.good_utf32_string() == u\"a𝐀🎂‽z\"\n    assert m.good_wchar_string() == u\"a⸘𝐀z\"\n    if hasattr(m, \"has_u8string\"):\n        assert m.good_utf8_u8string() == u\"Say utf8‽ 🎂 𝐀\"",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_unicode_conversion",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_unicode_conversion():\n    \"\"\"Tests unicode conversion and error reporting.\"\"\"\n    assert m.good_utf8_string() == u\"Say utf8‽ 🎂 𝐀\"\n    assert m.good_utf16_string() == u\"b‽🎂𝐀z\"\n    assert m.good_utf32_string() == u\"a𝐀🎂‽z\"\n    assert m.good_wchar_string() == u\"a⸘𝐀z\"\n    if hasattr(m, \"has_u8string\"):\n        assert m.good_utf8_u8string() == u\"Say utf8‽ 🎂 𝐀\"\n    with pytest.raises(UnicodeDecodeError):\n        m.bad_utf8_string()",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_single_char_arguments",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_single_char_arguments():\n    \"\"\"Tests failures for passing invalid inputs to char-accepting functions\"\"\"\n    def toobig_message(r):\n        return \"Character code point not in range({0:#x})\".format(r)\n    toolong_message = \"Expected a character, but multi-character string found\"\n    assert m.ord_char(u'a') == 0x61  # simple ASCII\n    assert m.ord_char_lv(u'b') == 0x62\n    assert m.ord_char(u'é') == 0xE9  # requires 2 bytes in utf-8, but can be stuffed in a char\n    with pytest.raises(ValueError) as excinfo:\n        assert m.ord_char(u'Ā') == 0x100  # requires 2 bytes, doesn't fit in a char",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_bytes_to_string",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_bytes_to_string():\n    \"\"\"Tests the ability to pass bytes to C++ string-accepting functions.  Note that this is\n    one-way: the only way to return bytes to Python is via the pybind11::bytes class.\"\"\"\n    # Issue #816\n    def to_bytes(s):\n        b = s if env.PY2 else s.encode(\"utf8\")\n        assert isinstance(b, bytes)\n        return b\n    assert m.strlen(to_bytes(\"hi\")) == 2\n    assert m.string_length(to_bytes(\"world\")) == 5",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_string_view",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_string_view(capture):\n    \"\"\"Tests support for C++17 string_view arguments and return values\"\"\"\n    assert m.string_view_chars(\"Hi\") == [72, 105]\n    assert m.string_view_chars(\"Hi 🎂\") == [72, 105, 32, 0xf0, 0x9f, 0x8e, 0x82]\n    assert m.string_view16_chars(u\"Hi 🎂\") == [72, 105, 32, 0xd83c, 0xdf82]\n    assert m.string_view32_chars(u\"Hi 🎂\") == [72, 105, 32, 127874]\n    if hasattr(m, \"has_u8string\"):\n        assert m.string_view8_chars(\"Hi\") == [72, 105]\n        assert m.string_view8_chars(u\"Hi 🎂\") == [72, 105, 32, 0xf0, 0x9f, 0x8e, 0x82]\n    assert m.string_view_return() == u\"utf8 secret 🎂\"",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_integer_casting",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_integer_casting():\n    \"\"\"Issue #929 - out-of-range integer values shouldn't be accepted\"\"\"\n    assert m.i32_str(-1) == \"-1\"\n    assert m.i64_str(-1) == \"-1\"\n    assert m.i32_str(2000000000) == \"2000000000\"\n    assert m.u32_str(2000000000) == \"2000000000\"\n    if env.PY2:\n        assert m.i32_str(long(-1)) == \"-1\"  # noqa: F821 undefined name 'long'\n        assert m.i64_str(long(-1)) == \"-1\"  # noqa: F821 undefined name 'long'\n        assert m.i64_str(long(-999999999999)) == \"-999999999999\"  # noqa: F821 undefined name",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_tuple",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_tuple(doc):\n    \"\"\"std::pair <-> tuple & std::tuple <-> tuple\"\"\"\n    assert m.pair_passthrough((True, \"test\")) == (\"test\", True)\n    assert m.tuple_passthrough((True, \"test\", 5)) == (5, \"test\", True)\n    # Any sequence can be cast to a std::pair or std::tuple\n    assert m.pair_passthrough([True, \"test\"]) == (\"test\", True)\n    assert m.tuple_passthrough([True, \"test\", 5]) == (5, \"test\", True)\n    assert m.empty_tuple() == ()\n    assert doc(m.pair_passthrough) == \"\"\"\n        pair_passthrough(arg0: Tuple[bool, str]) -> Tuple[str, bool]",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_builtins_cast_return_none",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_builtins_cast_return_none():\n    \"\"\"Casters produced with PYBIND11_TYPE_CASTER() should convert nullptr to None\"\"\"\n    assert m.return_none_string() is None\n    assert m.return_none_char() is None\n    assert m.return_none_bool() is None\n    assert m.return_none_int() is None\n    assert m.return_none_float() is None\n    assert m.return_none_pair() is None\ndef test_none_deferred():\n    \"\"\"None passed as various argument types should defer to other overloads\"\"\"",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_none_deferred",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_none_deferred():\n    \"\"\"None passed as various argument types should defer to other overloads\"\"\"\n    assert not m.defer_none_cstring(\"abc\")\n    assert m.defer_none_cstring(None)\n    assert not m.defer_none_custom(UserType())\n    assert m.defer_none_custom(None)\n    assert m.nodefer_none_void(None)\ndef test_void_caster():\n    assert m.load_nullptr_t(None) is None\n    assert m.cast_nullptr_t() is None",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_void_caster",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_void_caster():\n    assert m.load_nullptr_t(None) is None\n    assert m.cast_nullptr_t() is None\ndef test_reference_wrapper():\n    \"\"\"std::reference_wrapper for builtin and user types\"\"\"\n    assert m.refwrap_builtin(42) == 420\n    assert m.refwrap_usertype(UserType(42)) == 42\n    with pytest.raises(TypeError) as excinfo:\n        m.refwrap_builtin(None)\n    assert \"incompatible function arguments\" in str(excinfo.value)",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_reference_wrapper",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_reference_wrapper():\n    \"\"\"std::reference_wrapper for builtin and user types\"\"\"\n    assert m.refwrap_builtin(42) == 420\n    assert m.refwrap_usertype(UserType(42)) == 42\n    with pytest.raises(TypeError) as excinfo:\n        m.refwrap_builtin(None)\n    assert \"incompatible function arguments\" in str(excinfo.value)\n    with pytest.raises(TypeError) as excinfo:\n        m.refwrap_usertype(None)\n    assert \"incompatible function arguments\" in str(excinfo.value)",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_complex_cast",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_complex_cast():\n    \"\"\"std::complex casts\"\"\"\n    assert m.complex_cast(1) == \"1.0\"\n    assert m.complex_cast(2j) == \"(0.0, 2.0)\"\ndef test_bool_caster():\n    \"\"\"Test bool caster implicit conversions.\"\"\"\n    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert\n    def require_implicit(v):\n        pytest.raises(TypeError, noconvert, v)\n    def cant_convert(v):",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_bool_caster",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_bool_caster():\n    \"\"\"Test bool caster implicit conversions.\"\"\"\n    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert\n    def require_implicit(v):\n        pytest.raises(TypeError, noconvert, v)\n    def cant_convert(v):\n        pytest.raises(TypeError, convert, v)\n    # straight up bool\n    assert convert(True) is True\n    assert convert(False) is False",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_numpy_bool",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_numpy_bool():\n    np = pytest.importorskip(\"numpy\")\n    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert\n    def cant_convert(v):\n        pytest.raises(TypeError, convert, v)\n    # np.bool_ is not considered implicit\n    assert convert(np.bool_(True)) is True\n    assert convert(np.bool_(False)) is False\n    assert noconvert(np.bool_(True)) is True\n    assert noconvert(np.bool_(False)) is False",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_int_long",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_int_long():\n    \"\"\"In Python 2, a C++ int should return a Python int rather than long\n    if possible: longs are not always accepted where ints are used (such\n    as the argument to sys.exit()). A C++ long long is always a Python\n    long.\"\"\"\n    import sys\n    must_be_long = type(getattr(sys, 'maxint', 1) + 1)\n    assert isinstance(m.int_cast(), int)\n    assert isinstance(m.long_cast(), int)\n    assert isinstance(m.longlong_cast(), must_be_long)",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_void_caster_2",
        "kind": 2,
        "importPath": "pybind11.tests.test_builtin_casters",
        "description": "pybind11.tests.test_builtin_casters",
        "peekOfCode": "def test_void_caster_2():\n    assert m.test_void_caster()",
        "detail": "pybind11.tests.test_builtin_casters",
        "documentation": {}
    },
    {
        "label": "test_keep_alive_argument",
        "kind": 2,
        "importPath": "pybind11.tests.test_call_policies",
        "description": "pybind11.tests.test_call_policies",
        "peekOfCode": "def test_keep_alive_argument(capture):\n    n_inst = ConstructorStats.detail_reg_inst()\n    with capture:\n        p = m.Parent()\n    assert capture == \"Allocating parent.\"\n    with capture:\n        p.addChild(m.Child())\n        assert ConstructorStats.detail_reg_inst() == n_inst + 1\n    assert capture == \"\"\"\n        Allocating child.",
        "detail": "pybind11.tests.test_call_policies",
        "documentation": {}
    },
    {
        "label": "test_keep_alive_return_value",
        "kind": 2,
        "importPath": "pybind11.tests.test_call_policies",
        "description": "pybind11.tests.test_call_policies",
        "peekOfCode": "def test_keep_alive_return_value(capture):\n    n_inst = ConstructorStats.detail_reg_inst()\n    with capture:\n        p = m.Parent()\n    assert capture == \"Allocating parent.\"\n    with capture:\n        p.returnChild()\n        assert ConstructorStats.detail_reg_inst() == n_inst + 1\n    assert capture == \"\"\"\n        Allocating child.",
        "detail": "pybind11.tests.test_call_policies",
        "documentation": {}
    },
    {
        "label": "test_alive_gc",
        "kind": 2,
        "importPath": "pybind11.tests.test_call_policies",
        "description": "pybind11.tests.test_call_policies",
        "peekOfCode": "def test_alive_gc(capture):\n    n_inst = ConstructorStats.detail_reg_inst()\n    p = m.ParentGC()\n    p.addChildKeepAlive(m.Child())\n    assert ConstructorStats.detail_reg_inst() == n_inst + 2\n    lst = [p]\n    lst.append(lst)   # creates a circular reference\n    with capture:\n        del p, lst\n        assert ConstructorStats.detail_reg_inst() == n_inst",
        "detail": "pybind11.tests.test_call_policies",
        "documentation": {}
    },
    {
        "label": "test_alive_gc_derived",
        "kind": 2,
        "importPath": "pybind11.tests.test_call_policies",
        "description": "pybind11.tests.test_call_policies",
        "peekOfCode": "def test_alive_gc_derived(capture):\n    class Derived(m.Parent):\n        pass\n    n_inst = ConstructorStats.detail_reg_inst()\n    p = Derived()\n    p.addChildKeepAlive(m.Child())\n    assert ConstructorStats.detail_reg_inst() == n_inst + 2\n    lst = [p]\n    lst.append(lst)   # creates a circular reference\n    with capture:",
        "detail": "pybind11.tests.test_call_policies",
        "documentation": {}
    },
    {
        "label": "test_alive_gc_multi_derived",
        "kind": 2,
        "importPath": "pybind11.tests.test_call_policies",
        "description": "pybind11.tests.test_call_policies",
        "peekOfCode": "def test_alive_gc_multi_derived(capture):\n    class Derived(m.Parent, m.Child):\n        def __init__(self):\n            m.Parent.__init__(self)\n            m.Child.__init__(self)\n    n_inst = ConstructorStats.detail_reg_inst()\n    p = Derived()\n    p.addChildKeepAlive(m.Child())\n    # +3 rather than +2 because Derived corresponds to two registered instances\n    assert ConstructorStats.detail_reg_inst() == n_inst + 3",
        "detail": "pybind11.tests.test_call_policies",
        "documentation": {}
    },
    {
        "label": "test_return_none",
        "kind": 2,
        "importPath": "pybind11.tests.test_call_policies",
        "description": "pybind11.tests.test_call_policies",
        "peekOfCode": "def test_return_none(capture):\n    n_inst = ConstructorStats.detail_reg_inst()\n    with capture:\n        p = m.Parent()\n    assert capture == \"Allocating parent.\"\n    with capture:\n        p.returnNullChildKeepAliveChild()\n        assert ConstructorStats.detail_reg_inst() == n_inst + 1\n    assert capture == \"\"\n    with capture:",
        "detail": "pybind11.tests.test_call_policies",
        "documentation": {}
    },
    {
        "label": "test_keep_alive_constructor",
        "kind": 2,
        "importPath": "pybind11.tests.test_call_policies",
        "description": "pybind11.tests.test_call_policies",
        "peekOfCode": "def test_keep_alive_constructor(capture):\n    n_inst = ConstructorStats.detail_reg_inst()\n    with capture:\n        p = m.Parent(m.Child())\n        assert ConstructorStats.detail_reg_inst() == n_inst + 2\n    assert capture == \"\"\"\n        Allocating child.\n        Allocating parent.\n    \"\"\"\n    with capture:",
        "detail": "pybind11.tests.test_call_policies",
        "documentation": {}
    },
    {
        "label": "test_call_guard",
        "kind": 2,
        "importPath": "pybind11.tests.test_call_policies",
        "description": "pybind11.tests.test_call_policies",
        "peekOfCode": "def test_call_guard():\n    assert m.unguarded_call() == \"unguarded\"\n    assert m.guarded_call() == \"guarded\"\n    assert m.multiple_guards_correct_order() == \"guarded & guarded\"\n    assert m.multiple_guards_wrong_order() == \"unguarded & guarded\"\n    if hasattr(m, \"with_gil\"):\n        assert m.with_gil() == \"GIL held\"\n        assert m.without_gil() == \"GIL released\"",
        "detail": "pybind11.tests.test_call_policies",
        "documentation": {}
    },
    {
        "label": "test_callbacks",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_callbacks():\n    from functools import partial\n    def func1():\n        return \"func1\"\n    def func2(a, b, c, d):\n        return \"func2\", a, b, c, d\n    def func3(a):\n        return \"func3({})\".format(a)\n    assert m.test_callback1(func1) == \"func1\"\n    assert m.test_callback2(func2) == (\"func2\", \"Hello\", \"x\", True, 5)",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_bound_method_callback",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_bound_method_callback():\n    # Bound Python method:\n    class MyClass:\n        def double(self, val):\n            return 2 * val\n    z = MyClass()\n    assert m.test_callback3(z.double) == \"func(43) = 86\"\n    z = m.CppBoundMethodTest()\n    assert m.test_callback3(z.triple) == \"func(43) = 129\"\ndef test_keyword_args_and_generalized_unpacking():",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_keyword_args_and_generalized_unpacking",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_keyword_args_and_generalized_unpacking():\n    def f(*args, **kwargs):\n        return args, kwargs\n    assert m.test_tuple_unpacking(f) == ((\"positional\", 1, 2, 3, 4, 5, 6), {})\n    assert m.test_dict_unpacking(f) == ((\"positional\", 1), {\"key\": \"value\", \"a\": 1, \"b\": 2})\n    assert m.test_keyword_args(f) == ((), {\"x\": 10, \"y\": 20})\n    assert m.test_unpacking_and_keywords1(f) == ((1, 2), {\"c\": 3, \"d\": 4})\n    assert m.test_unpacking_and_keywords2(f) == (\n        (\"positional\", 1, 2, 3, 4, 5),\n        {\"key\": \"value\", \"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_lambda_closure_cleanup",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_lambda_closure_cleanup():\n    m.test_cleanup()\n    cstats = m.payload_cstats()\n    assert cstats.alive() == 0\n    assert cstats.copy_constructions == 1\n    assert cstats.move_constructions >= 1\ndef test_cpp_function_roundtrip():\n    \"\"\"Test if passing a function pointer from C++ -> Python -> C++ yields the original pointer\"\"\"\n    assert m.test_dummy_function(m.dummy_function) == \"matches dummy_function: eval(1) = 2\"\n    assert (m.test_dummy_function(m.roundtrip(m.dummy_function)) ==",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_cpp_function_roundtrip",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_cpp_function_roundtrip():\n    \"\"\"Test if passing a function pointer from C++ -> Python -> C++ yields the original pointer\"\"\"\n    assert m.test_dummy_function(m.dummy_function) == \"matches dummy_function: eval(1) = 2\"\n    assert (m.test_dummy_function(m.roundtrip(m.dummy_function)) ==\n            \"matches dummy_function: eval(1) = 2\")\n    assert m.roundtrip(None, expect_none=True) is None\n    assert (m.test_dummy_function(lambda x: x + 2) ==\n            \"can't convert to function pointer: eval(1) = 3\")\n    with pytest.raises(TypeError) as excinfo:\n        m.test_dummy_function(m.dummy_function2)",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_function_signatures",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_function_signatures(doc):\n    assert doc(m.test_callback3) == \"test_callback3(arg0: Callable[[int], int]) -> str\"\n    assert doc(m.test_callback4) == \"test_callback4() -> Callable[[int], int]\"\ndef test_movable_object():\n    assert m.callback_with_movable(lambda _: None) is True\ndef test_async_callbacks():\n    # serves as state for async callback\n    class Item:\n        def __init__(self, value):\n            self.value = value",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_movable_object",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_movable_object():\n    assert m.callback_with_movable(lambda _: None) is True\ndef test_async_callbacks():\n    # serves as state for async callback\n    class Item:\n        def __init__(self, value):\n            self.value = value\n    res = []\n    # generate stateful lambda that will store result in `res`\n    def gen_f():",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_async_callbacks",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_async_callbacks():\n    # serves as state for async callback\n    class Item:\n        def __init__(self, value):\n            self.value = value\n    res = []\n    # generate stateful lambda that will store result in `res`\n    def gen_f():\n        s = Item(3)\n        return lambda j: res.append(s.value + j)",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_async_async_callbacks",
        "kind": 2,
        "importPath": "pybind11.tests.test_callbacks",
        "description": "pybind11.tests.test_callbacks",
        "peekOfCode": "def test_async_async_callbacks():\n    t = Thread(target=test_async_callbacks)\n    t.start()\n    t.join()",
        "detail": "pybind11.tests.test_callbacks",
        "documentation": {}
    },
    {
        "label": "test_chrono_system_clock",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_system_clock():\n    # Get the time from both c++ and datetime\n    date0 = datetime.datetime.today()\n    date1 = m.test_chrono1()\n    date2 = datetime.datetime.today()\n    # The returned value should be a datetime\n    assert isinstance(date1, datetime.datetime)\n    # The numbers should vary by a very small amount (time it took to execute)\n    diff_python = abs(date2 - date0)\n    diff = abs(date1 - date2)",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_chrono_system_clock_roundtrip",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_system_clock_roundtrip():\n    date1 = datetime.datetime.today()\n    # Roundtrip the time\n    date2 = m.test_chrono2(date1)\n    # The returned value should be a datetime\n    assert isinstance(date2, datetime.datetime)\n    # They should be identical (no information lost on roundtrip)\n    diff = abs(date1 - date2)\n    assert diff.days == 0\n    assert diff.seconds == 0",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_chrono_system_clock_roundtrip_date",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_system_clock_roundtrip_date():\n    date1 = datetime.date.today()\n    # Roundtrip the time\n    datetime2 = m.test_chrono2(date1)\n    date2 = datetime2.date()\n    time2 = datetime2.time()\n    # The returned value should be a datetime\n    assert isinstance(datetime2, datetime.datetime)\n    assert isinstance(date2, datetime.date)\n    assert isinstance(time2, datetime.time)",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_chrono_system_clock_roundtrip_time",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_system_clock_roundtrip_time(time1, tz, monkeypatch):\n    if tz is not None:\n        monkeypatch.setenv(\"TZ\", \"/usr/share/zoneinfo/{}\".format(tz))\n    # Roundtrip the time\n    datetime2 = m.test_chrono2(time1)\n    date2 = datetime2.date()\n    time2 = datetime2.time()\n    # The returned value should be a datetime\n    assert isinstance(datetime2, datetime.datetime)\n    assert isinstance(date2, datetime.date)",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_chrono_duration_roundtrip",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_duration_roundtrip():\n    # Get the difference between two times (a timedelta)\n    date1 = datetime.datetime.today()\n    date2 = datetime.datetime.today()\n    diff = date2 - date1\n    # Make sure this is a timedelta\n    assert isinstance(diff, datetime.timedelta)\n    cpp_diff = m.test_chrono3(diff)\n    assert cpp_diff.days == diff.days\n    assert cpp_diff.seconds == diff.seconds",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_chrono_duration_subtraction_equivalence",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_duration_subtraction_equivalence():\n    date1 = datetime.datetime.today()\n    date2 = datetime.datetime.today()\n    diff = date2 - date1\n    cpp_diff = m.test_chrono4(date2, date1)\n    assert cpp_diff.days == diff.days\n    assert cpp_diff.seconds == diff.seconds\n    assert cpp_diff.microseconds == diff.microseconds\ndef test_chrono_duration_subtraction_equivalence_date():\n    date1 = datetime.date.today()",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_chrono_duration_subtraction_equivalence_date",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_duration_subtraction_equivalence_date():\n    date1 = datetime.date.today()\n    date2 = datetime.date.today()\n    diff = date2 - date1\n    cpp_diff = m.test_chrono4(date2, date1)\n    assert cpp_diff.days == diff.days\n    assert cpp_diff.seconds == diff.seconds\n    assert cpp_diff.microseconds == diff.microseconds\ndef test_chrono_steady_clock():\n    time1 = m.test_chrono5()",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_chrono_steady_clock",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_steady_clock():\n    time1 = m.test_chrono5()\n    assert isinstance(time1, datetime.timedelta)\ndef test_chrono_steady_clock_roundtrip():\n    time1 = datetime.timedelta(days=10, seconds=10, microseconds=100)\n    time2 = m.test_chrono6(time1)\n    assert isinstance(time2, datetime.timedelta)\n    # They should be identical (no information lost on roundtrip)\n    assert time1.days == time2.days\n    assert time1.seconds == time2.seconds",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_chrono_steady_clock_roundtrip",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_chrono_steady_clock_roundtrip():\n    time1 = datetime.timedelta(days=10, seconds=10, microseconds=100)\n    time2 = m.test_chrono6(time1)\n    assert isinstance(time2, datetime.timedelta)\n    # They should be identical (no information lost on roundtrip)\n    assert time1.days == time2.days\n    assert time1.seconds == time2.seconds\n    assert time1.microseconds == time2.microseconds\ndef test_floating_point_duration():\n    # Test using a floating point number in seconds",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_floating_point_duration",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_floating_point_duration():\n    # Test using a floating point number in seconds\n    time = m.test_chrono7(35.525123)\n    assert isinstance(time, datetime.timedelta)\n    assert time.seconds == 35\n    assert 525122 <= time.microseconds <= 525123\n    diff = m.test_chrono_float_diff(43.789012, 1.123456)\n    assert diff.seconds == 42\n    assert 665556 <= diff.microseconds <= 665557\ndef test_nano_timepoint():",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_nano_timepoint",
        "kind": 2,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "def test_nano_timepoint():\n    time = datetime.datetime.now()\n    time1 = m.test_nano_timepoint(time, datetime.timedelta(seconds=60))\n    assert(time1 == time + datetime.timedelta(seconds=60))",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "SKIP_TZ_ENV_ON_WIN",
        "kind": 5,
        "importPath": "pybind11.tests.test_chrono",
        "description": "pybind11.tests.test_chrono",
        "peekOfCode": "SKIP_TZ_ENV_ON_WIN = pytest.mark.skipif(\n    \"env.WIN\", reason=\"TZ environment variable only supported on POSIX\"\n)\n@pytest.mark.parametrize(\"time1\", [\n    datetime.datetime.today().time(),\n    datetime.time(0, 0, 0),\n    datetime.time(0, 0, 0, 1),\n    datetime.time(0, 28, 45, 109827),\n    datetime.time(0, 59, 59, 999999),\n    datetime.time(1, 0, 0),",
        "detail": "pybind11.tests.test_chrono",
        "documentation": {}
    },
    {
        "label": "test_repr",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_repr():\n    # In Python 3.3+, repr() accesses __qualname__\n    assert \"pybind11_type\" in repr(type(UserType))\n    assert \"UserType\" in repr(UserType)\ndef test_instance(msg):\n    with pytest.raises(TypeError) as excinfo:\n        m.NoConstructor()\n    assert msg(excinfo.value) == \"m.class_.NoConstructor: No constructor defined!\"\n    instance = m.NoConstructor.new_instance()\n    cstats = ConstructorStats.get(m.NoConstructor)",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_instance",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_instance(msg):\n    with pytest.raises(TypeError) as excinfo:\n        m.NoConstructor()\n    assert msg(excinfo.value) == \"m.class_.NoConstructor: No constructor defined!\"\n    instance = m.NoConstructor.new_instance()\n    cstats = ConstructorStats.get(m.NoConstructor)\n    assert cstats.alive() == 1\n    del instance\n    assert cstats.alive() == 0\ndef test_docstrings(doc):",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_docstrings",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_docstrings(doc):\n    assert doc(UserType) == \"A `py::class_` type for testing\"\n    assert UserType.__name__ == \"UserType\"\n    assert UserType.__module__ == \"pybind11_tests\"\n    assert UserType.get_value.__name__ == \"get_value\"\n    assert UserType.get_value.__module__ == \"pybind11_tests\"\n    assert doc(UserType.get_value) == \"\"\"\n        get_value(self: m.UserType) -> int\n        Get value using a method\n    \"\"\"",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_qualname",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_qualname(doc):\n    \"\"\"Tests that a properly qualified name is set in __qualname__ (even in pre-3.3, where we\n    backport the attribute) and that generated docstrings properly use it and the module name\"\"\"\n    assert m.NestBase.__qualname__ == \"NestBase\"\n    assert m.NestBase.Nested.__qualname__ == \"NestBase.Nested\"\n    assert doc(m.NestBase.__init__) == \"\"\"\n        __init__(self: m.class_.NestBase) -> None\n    \"\"\"\n    assert doc(m.NestBase.g) == \"\"\"\n        g(self: m.class_.NestBase, arg0: m.class_.NestBase.Nested) -> None",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_inheritance",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_inheritance(msg):\n    roger = m.Rabbit('Rabbit')\n    assert roger.name() + \" is a \" + roger.species() == \"Rabbit is a parrot\"\n    assert m.pet_name_species(roger) == \"Rabbit is a parrot\"\n    polly = m.Pet('Polly', 'parrot')\n    assert polly.name() + \" is a \" + polly.species() == \"Polly is a parrot\"\n    assert m.pet_name_species(polly) == \"Polly is a parrot\"\n    molly = m.Dog('Molly')\n    assert molly.name() + \" is a \" + molly.species() == \"Molly is a dog\"\n    assert m.pet_name_species(molly) == \"Molly is a dog\"",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_inheritance_init",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_inheritance_init(msg):\n    # Single base\n    class Python(m.Pet):\n        def __init__(self):\n            pass\n    with pytest.raises(TypeError) as exc_info:\n        Python()\n    expected = [\"m.class_.Pet.__init__() must be called when overriding __init__\",\n                \"Pet.__init__() must be called when overriding __init__\"]  # PyPy?\n    # TODO: fix PyPy error message wrt. tp_name/__qualname__?",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_automatic_upcasting",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_automatic_upcasting():\n    assert type(m.return_class_1()).__name__ == \"DerivedClass1\"\n    assert type(m.return_class_2()).__name__ == \"DerivedClass2\"\n    assert type(m.return_none()).__name__ == \"NoneType\"\n    # Repeat these a few times in a random order to ensure no invalid caching is applied\n    assert type(m.return_class_n(1)).__name__ == \"DerivedClass1\"\n    assert type(m.return_class_n(2)).__name__ == \"DerivedClass2\"\n    assert type(m.return_class_n(0)).__name__ == \"BaseClass\"\n    assert type(m.return_class_n(2)).__name__ == \"DerivedClass2\"\n    assert type(m.return_class_n(2)).__name__ == \"DerivedClass2\"",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_isinstance",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_isinstance():\n    objects = [tuple(), dict(), m.Pet(\"Polly\", \"parrot\")] + [m.Dog(\"Molly\")] * 4\n    expected = (True, True, True, True, True, False, False)\n    assert m.check_instances(objects) == expected\ndef test_mismatched_holder():\n    import re\n    with pytest.raises(RuntimeError) as excinfo:\n        m.mismatched_holder_1()\n    assert re.match('generic_type: type \".*MismatchDerived1\" does not have a non-default '\n                    'holder type while its base \".*MismatchBase1\" does', str(excinfo.value))",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_mismatched_holder",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_mismatched_holder():\n    import re\n    with pytest.raises(RuntimeError) as excinfo:\n        m.mismatched_holder_1()\n    assert re.match('generic_type: type \".*MismatchDerived1\" does not have a non-default '\n                    'holder type while its base \".*MismatchBase1\" does', str(excinfo.value))\n    with pytest.raises(RuntimeError) as excinfo:\n        m.mismatched_holder_2()\n    assert re.match('generic_type: type \".*MismatchDerived2\" has a non-default holder type '\n                    'while its base \".*MismatchBase2\" does not', str(excinfo.value))",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_override_static",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_override_static():\n    \"\"\"#511: problem with inheritance + overwritten def_static\"\"\"\n    b = m.MyBase.make()\n    d1 = m.MyDerived.make2()\n    d2 = m.MyDerived.make()\n    assert isinstance(b, m.MyBase)\n    assert isinstance(d1, m.MyDerived)\n    assert isinstance(d2, m.MyDerived)\ndef test_implicit_conversion_life_support():\n    \"\"\"Ensure the lifetime of temporary objects created for implicit conversions\"\"\"",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_implicit_conversion_life_support",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_implicit_conversion_life_support():\n    \"\"\"Ensure the lifetime of temporary objects created for implicit conversions\"\"\"\n    assert m.implicitly_convert_argument(UserType(5)) == 5\n    assert m.implicitly_convert_variable(UserType(5)) == 5\n    assert \"outside a bound function\" in m.implicitly_convert_variable_fail(UserType(5))\ndef test_operator_new_delete(capture):\n    \"\"\"Tests that class-specific operator new/delete functions are invoked\"\"\"\n    class SubAliased(m.AliasedHasOpNewDelSize):\n        pass\n    with capture:",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_operator_new_delete",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_operator_new_delete(capture):\n    \"\"\"Tests that class-specific operator new/delete functions are invoked\"\"\"\n    class SubAliased(m.AliasedHasOpNewDelSize):\n        pass\n    with capture:\n        a = m.HasOpNewDel()\n        b = m.HasOpNewDelSize()\n        d = m.HasOpNewDelBoth()\n    assert capture == \"\"\"\n        A new 8",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_bind_protected_functions",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_bind_protected_functions():\n    \"\"\"Expose protected member functions to Python using a helper class\"\"\"\n    a = m.ProtectedA()\n    assert a.foo() == 42\n    b = m.ProtectedB()\n    assert b.foo() == 42\n    class C(m.ProtectedB):\n        def __init__(self):\n            m.ProtectedB.__init__(self)\n        def foo(self):",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_brace_initialization",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_brace_initialization():\n    \"\"\" Tests that simple POD classes can be constructed using C++11 brace initialization \"\"\"\n    a = m.BraceInitialization(123, \"test\")\n    assert a.field1 == 123\n    assert a.field2 == \"test\"\n    # Tests that a non-simple class doesn't get brace initialization (if the\n    # class defines an initializer_list constructor, in particular, it would\n    # win over the expected constructor).\n    b = m.NoBraceInitialization([123, 456])\n    assert b.vec == [123, 456]",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_class_refcount",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_class_refcount():\n    \"\"\"Instances must correctly increase/decrease the reference count of their types (#1029)\"\"\"\n    from sys import getrefcount\n    class PyDog(m.Dog):\n        pass\n    for cls in m.Dog, PyDog:\n        refcount_1 = getrefcount(cls)\n        molly = [cls(\"Molly\") for _ in range(10)]\n        refcount_2 = getrefcount(cls)\n        del molly",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_reentrant_implicit_conversion_failure",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_reentrant_implicit_conversion_failure(msg):\n    # ensure that there is no runaway reentrant implicit conversion (#1035)\n    with pytest.raises(TypeError) as excinfo:\n        m.BogusImplicitConversion(0)\n    assert msg(excinfo.value) == '''\n        __init__(): incompatible constructor arguments. The following argument types are supported:\n            1. m.class_.BogusImplicitConversion(arg0: m.class_.BogusImplicitConversion)\n        Invoked with: 0\n    '''\ndef test_error_after_conversions():",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_error_after_conversions",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_error_after_conversions():\n    with pytest.raises(TypeError) as exc_info:\n        m.test_error_after_conversions(\"hello\")\n    assert str(exc_info.value).startswith(\n        \"Unable to convert function return value to a Python type!\")\ndef test_aligned():\n    if hasattr(m, \"Aligned\"):\n        p = m.Aligned().ptr()\n        assert p % 1024 == 0\n# https://foss.heptapod.net/pypy/pypy/-/issues/2742",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_aligned",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_aligned():\n    if hasattr(m, \"Aligned\"):\n        p = m.Aligned().ptr()\n        assert p % 1024 == 0\n# https://foss.heptapod.net/pypy/pypy/-/issues/2742\n@pytest.mark.xfail(\"env.PYPY\")\ndef test_final():\n    with pytest.raises(TypeError) as exc_info:\n        class PyFinalChild(m.IsFinal):\n            pass",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_final",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_final():\n    with pytest.raises(TypeError) as exc_info:\n        class PyFinalChild(m.IsFinal):\n            pass\n    assert str(exc_info.value).endswith(\"is not an acceptable base type\")\n# https://foss.heptapod.net/pypy/pypy/-/issues/2742\n@pytest.mark.xfail(\"env.PYPY\")\ndef test_non_final_final():\n    with pytest.raises(TypeError) as exc_info:\n        class PyNonFinalFinalChild(m.IsNonFinalFinal):",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_non_final_final",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_non_final_final():\n    with pytest.raises(TypeError) as exc_info:\n        class PyNonFinalFinalChild(m.IsNonFinalFinal):\n            pass\n    assert str(exc_info.value).endswith(\"is not an acceptable base type\")\n# https://github.com/pybind/pybind11/issues/1878\ndef test_exception_rvalue_abort():\n    with pytest.raises(RuntimeError):\n        m.PyPrintDestructor().throw_something()",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_exception_rvalue_abort",
        "kind": 2,
        "importPath": "pybind11.tests.test_class",
        "description": "pybind11.tests.test_class",
        "peekOfCode": "def test_exception_rvalue_abort():\n    with pytest.raises(RuntimeError):\n        m.PyPrintDestructor().throw_something()",
        "detail": "pybind11.tests.test_class",
        "documentation": {}
    },
    {
        "label": "test_constants",
        "kind": 2,
        "importPath": "pybind11.tests.test_constants_and_functions",
        "description": "pybind11.tests.test_constants_and_functions",
        "peekOfCode": "def test_constants():\n    assert m.some_constant == 14\ndef test_function_overloading():\n    assert m.test_function() == \"test_function()\"\n    assert m.test_function(7) == \"test_function(7)\"\n    assert m.test_function(m.MyEnum.EFirstEntry) == \"test_function(enum=1)\"\n    assert m.test_function(m.MyEnum.ESecondEntry) == \"test_function(enum=2)\"\n    assert m.test_function() == \"test_function()\"\n    assert m.test_function(\"abcd\") == \"test_function(char *)\"\n    assert m.test_function(1, 1.0) == \"test_function(int, float)\"",
        "detail": "pybind11.tests.test_constants_and_functions",
        "documentation": {}
    },
    {
        "label": "test_function_overloading",
        "kind": 2,
        "importPath": "pybind11.tests.test_constants_and_functions",
        "description": "pybind11.tests.test_constants_and_functions",
        "peekOfCode": "def test_function_overloading():\n    assert m.test_function() == \"test_function()\"\n    assert m.test_function(7) == \"test_function(7)\"\n    assert m.test_function(m.MyEnum.EFirstEntry) == \"test_function(enum=1)\"\n    assert m.test_function(m.MyEnum.ESecondEntry) == \"test_function(enum=2)\"\n    assert m.test_function() == \"test_function()\"\n    assert m.test_function(\"abcd\") == \"test_function(char *)\"\n    assert m.test_function(1, 1.0) == \"test_function(int, float)\"\n    assert m.test_function(1, 1.0) == \"test_function(int, float)\"\n    assert m.test_function(2.0, 2) == \"test_function(float, int)\"",
        "detail": "pybind11.tests.test_constants_and_functions",
        "documentation": {}
    },
    {
        "label": "test_bytes",
        "kind": 2,
        "importPath": "pybind11.tests.test_constants_and_functions",
        "description": "pybind11.tests.test_constants_and_functions",
        "peekOfCode": "def test_bytes():\n    assert m.print_bytes(m.return_bytes()) == \"bytes[1 0 2 0]\"\ndef test_exception_specifiers():\n    c = m.C()\n    assert c.m1(2) == 1\n    assert c.m2(3) == 1\n    assert c.m3(5) == 2\n    assert c.m4(7) == 3\n    assert c.m5(10) == 5\n    assert c.m6(14) == 8",
        "detail": "pybind11.tests.test_constants_and_functions",
        "documentation": {}
    },
    {
        "label": "test_exception_specifiers",
        "kind": 2,
        "importPath": "pybind11.tests.test_constants_and_functions",
        "description": "pybind11.tests.test_constants_and_functions",
        "peekOfCode": "def test_exception_specifiers():\n    c = m.C()\n    assert c.m1(2) == 1\n    assert c.m2(3) == 1\n    assert c.m3(5) == 2\n    assert c.m4(7) == 3\n    assert c.m5(10) == 5\n    assert c.m6(14) == 8\n    assert c.m7(20) == 13\n    assert c.m8(29) == 21",
        "detail": "pybind11.tests.test_constants_and_functions",
        "documentation": {}
    },
    {
        "label": "test_lacking_copy_ctor",
        "kind": 2,
        "importPath": "pybind11.tests.test_copy_move",
        "description": "pybind11.tests.test_copy_move",
        "peekOfCode": "def test_lacking_copy_ctor():\n    with pytest.raises(RuntimeError) as excinfo:\n        m.lacking_copy_ctor.get_one()\n    assert \"is non-copyable!\" in str(excinfo.value)\ndef test_lacking_move_ctor():\n    with pytest.raises(RuntimeError) as excinfo:\n        m.lacking_move_ctor.get_one()\n    assert \"is neither movable nor copyable!\" in str(excinfo.value)\ndef test_move_and_copy_casts():\n    \"\"\"Cast some values in C++ via custom type casters and count the number of moves/copies.\"\"\"",
        "detail": "pybind11.tests.test_copy_move",
        "documentation": {}
    },
    {
        "label": "test_lacking_move_ctor",
        "kind": 2,
        "importPath": "pybind11.tests.test_copy_move",
        "description": "pybind11.tests.test_copy_move",
        "peekOfCode": "def test_lacking_move_ctor():\n    with pytest.raises(RuntimeError) as excinfo:\n        m.lacking_move_ctor.get_one()\n    assert \"is neither movable nor copyable!\" in str(excinfo.value)\ndef test_move_and_copy_casts():\n    \"\"\"Cast some values in C++ via custom type casters and count the number of moves/copies.\"\"\"\n    cstats = m.move_and_copy_cstats()\n    c_m, c_mc, c_c = cstats[\"MoveOnlyInt\"], cstats[\"MoveOrCopyInt\"], cstats[\"CopyOnlyInt\"]\n    # The type move constructions/assignments below each get incremented: the move assignment comes\n    # from the type_caster load; the move construction happens when extracting that via a cast or",
        "detail": "pybind11.tests.test_copy_move",
        "documentation": {}
    },
    {
        "label": "test_move_and_copy_casts",
        "kind": 2,
        "importPath": "pybind11.tests.test_copy_move",
        "description": "pybind11.tests.test_copy_move",
        "peekOfCode": "def test_move_and_copy_casts():\n    \"\"\"Cast some values in C++ via custom type casters and count the number of moves/copies.\"\"\"\n    cstats = m.move_and_copy_cstats()\n    c_m, c_mc, c_c = cstats[\"MoveOnlyInt\"], cstats[\"MoveOrCopyInt\"], cstats[\"CopyOnlyInt\"]\n    # The type move constructions/assignments below each get incremented: the move assignment comes\n    # from the type_caster load; the move construction happens when extracting that via a cast or\n    # loading into an argument.\n    assert m.move_and_copy_casts(3) == 18\n    assert c_m.copy_assignments + c_m.copy_constructions == 0\n    assert c_m.move_assignments == 2",
        "detail": "pybind11.tests.test_copy_move",
        "documentation": {}
    },
    {
        "label": "test_move_and_copy_loads",
        "kind": 2,
        "importPath": "pybind11.tests.test_copy_move",
        "description": "pybind11.tests.test_copy_move",
        "peekOfCode": "def test_move_and_copy_loads():\n    \"\"\"Call some functions that load arguments via custom type casters and count the number of\n    moves/copies.\"\"\"\n    cstats = m.move_and_copy_cstats()\n    c_m, c_mc, c_c = cstats[\"MoveOnlyInt\"], cstats[\"MoveOrCopyInt\"], cstats[\"CopyOnlyInt\"]\n    assert m.move_only(10) == 10  # 1 move, c_m\n    assert m.move_or_copy(11) == 11  # 1 move, c_mc\n    assert m.copy_only(12) == 12  # 1 copy, c_c\n    assert m.move_pair((13, 14)) == 27  # 1 c_m move, 1 c_mc move\n    assert m.move_tuple((15, 16, 17)) == 48  # 2 c_m moves, 1 c_mc move",
        "detail": "pybind11.tests.test_copy_move",
        "documentation": {}
    },
    {
        "label": "test_move_and_copy_load_optional",
        "kind": 2,
        "importPath": "pybind11.tests.test_copy_move",
        "description": "pybind11.tests.test_copy_move",
        "peekOfCode": "def test_move_and_copy_load_optional():\n    \"\"\"Tests move/copy loads of std::optional arguments\"\"\"\n    cstats = m.move_and_copy_cstats()\n    c_m, c_mc, c_c = cstats[\"MoveOnlyInt\"], cstats[\"MoveOrCopyInt\"], cstats[\"CopyOnlyInt\"]\n    # The extra move/copy constructions below come from the std::optional move (which has to move\n    # its arguments):\n    assert m.move_optional(10) == 10  # c_m: 1 move assign, 2 move construct\n    assert m.move_or_copy_optional(11) == 11  # c_mc: 1 move assign, 2 move construct\n    assert m.copy_optional(12) == 12  # c_c: 1 copy assign, 2 copy construct\n    # 1 move assign + move construct moves each of c_m, c_mc, 1 c_c copy",
        "detail": "pybind11.tests.test_copy_move",
        "documentation": {}
    },
    {
        "label": "test_private_op_new",
        "kind": 2,
        "importPath": "pybind11.tests.test_copy_move",
        "description": "pybind11.tests.test_copy_move",
        "peekOfCode": "def test_private_op_new():\n    \"\"\"An object with a private `operator new` cannot be returned by value\"\"\"\n    with pytest.raises(RuntimeError) as excinfo:\n        m.private_op_new_value()\n    assert \"is neither movable nor copyable\" in str(excinfo.value)\n    assert m.private_op_new_reference().value == 1\ndef test_move_fallback():\n    \"\"\"#389: rvp::move should fall-through to copy on non-movable objects\"\"\"\n    m2 = m.get_moveissue2(2)\n    assert m2.value == 2",
        "detail": "pybind11.tests.test_copy_move",
        "documentation": {}
    },
    {
        "label": "test_move_fallback",
        "kind": 2,
        "importPath": "pybind11.tests.test_copy_move",
        "description": "pybind11.tests.test_copy_move",
        "peekOfCode": "def test_move_fallback():\n    \"\"\"#389: rvp::move should fall-through to copy on non-movable objects\"\"\"\n    m2 = m.get_moveissue2(2)\n    assert m2.value == 2\n    m1 = m.get_moveissue1(1)\n    assert m1.value == 1",
        "detail": "pybind11.tests.test_copy_move",
        "documentation": {}
    },
    {
        "label": "test_noconvert_args",
        "kind": 2,
        "importPath": "pybind11.tests.test_custom_type_casters",
        "description": "pybind11.tests.test_custom_type_casters",
        "peekOfCode": "def test_noconvert_args(msg):\n    a = m.ArgInspector()\n    assert msg(a.f(\"hi\")) == \"\"\"\n        loading ArgInspector1 argument WITH conversion allowed.  Argument value = hi\n    \"\"\"\n    assert msg(a.g(\"this is a\", \"this is b\")) == \"\"\"\n        loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a\n        loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b\n        13\n        loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)",
        "detail": "pybind11.tests.test_custom_type_casters",
        "documentation": {}
    },
    {
        "label": "test_custom_caster_destruction",
        "kind": 2,
        "importPath": "pybind11.tests.test_custom_type_casters",
        "description": "pybind11.tests.test_custom_type_casters",
        "peekOfCode": "def test_custom_caster_destruction():\n    \"\"\"Tests that returning a pointer to a type that gets converted with a custom type caster gets\n    destroyed when the function has py::return_value_policy::take_ownership policy applied.\"\"\"\n    cstats = m.destruction_tester_cstats()\n    # This one *doesn't* have take_ownership: the pointer should be used but not destroyed:\n    z = m.custom_caster_no_destroy()\n    assert cstats.alive() == 1 and cstats.default_constructions == 1\n    assert z\n    # take_ownership applied: this constructs a new object, casts it, then destroys it:\n    z = m.custom_caster_destroy()",
        "detail": "pybind11.tests.test_custom_type_casters",
        "documentation": {}
    },
    {
        "label": "test_docstring_options",
        "kind": 2,
        "importPath": "pybind11.tests.test_docstring_options",
        "description": "pybind11.tests.test_docstring_options",
        "peekOfCode": "def test_docstring_options():\n    # options.disable_function_signatures()\n    assert not m.test_function1.__doc__\n    assert m.test_function2.__doc__ == \"A custom docstring\"\n    # docstring specified on just the first overload definition:\n    assert m.test_overloaded1.__doc__ == \"Overload docstring\"\n    # docstring on both overloads:\n    assert m.test_overloaded2.__doc__ == \"overload docstring 1\\noverload docstring 2\"\n    # docstring on only second overload:\n    assert m.test_overloaded3.__doc__ == \"Overload docstr\"",
        "detail": "pybind11.tests.test_docstring_options",
        "documentation": {}
    },
    {
        "label": "assert_equal_ref",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def assert_equal_ref(mat):\n    np.testing.assert_array_equal(mat, ref)\ndef assert_sparse_equal_ref(sparse_mat):\n    assert_equal_ref(sparse_mat.toarray())\ndef test_fixed():\n    assert_equal_ref(m.fixed_c())\n    assert_equal_ref(m.fixed_r())\n    assert_equal_ref(m.fixed_copy_r(m.fixed_r()))\n    assert_equal_ref(m.fixed_copy_c(m.fixed_c()))\n    assert_equal_ref(m.fixed_copy_r(m.fixed_c()))",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "assert_sparse_equal_ref",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def assert_sparse_equal_ref(sparse_mat):\n    assert_equal_ref(sparse_mat.toarray())\ndef test_fixed():\n    assert_equal_ref(m.fixed_c())\n    assert_equal_ref(m.fixed_r())\n    assert_equal_ref(m.fixed_copy_r(m.fixed_r()))\n    assert_equal_ref(m.fixed_copy_c(m.fixed_c()))\n    assert_equal_ref(m.fixed_copy_r(m.fixed_c()))\n    assert_equal_ref(m.fixed_copy_c(m.fixed_r()))\ndef test_dense():",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_fixed",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_fixed():\n    assert_equal_ref(m.fixed_c())\n    assert_equal_ref(m.fixed_r())\n    assert_equal_ref(m.fixed_copy_r(m.fixed_r()))\n    assert_equal_ref(m.fixed_copy_c(m.fixed_c()))\n    assert_equal_ref(m.fixed_copy_r(m.fixed_c()))\n    assert_equal_ref(m.fixed_copy_c(m.fixed_r()))\ndef test_dense():\n    assert_equal_ref(m.dense_r())\n    assert_equal_ref(m.dense_c())",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_dense",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_dense():\n    assert_equal_ref(m.dense_r())\n    assert_equal_ref(m.dense_c())\n    assert_equal_ref(m.dense_copy_r(m.dense_r()))\n    assert_equal_ref(m.dense_copy_c(m.dense_c()))\n    assert_equal_ref(m.dense_copy_r(m.dense_c()))\n    assert_equal_ref(m.dense_copy_c(m.dense_r()))\ndef test_partially_fixed():\n    ref2 = np.array([[0., 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]])\n    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2), ref2)",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_partially_fixed",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_partially_fixed():\n    ref2 = np.array([[0., 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]])\n    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2), ref2)\n    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2), ref2)\n    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2[:, 1]), ref2[:, [1]])\n    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2[0, :]), ref2[[0], :])\n    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)])\n    np.testing.assert_array_equal(\n        m.partial_copy_four_rm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :])\n    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2), ref2)",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_mutator_descriptors",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_mutator_descriptors():\n    zr = np.arange(30, dtype='float32').reshape(5, 6)  # row-major\n    zc = zr.reshape(6, 5).transpose()  # column-major\n    m.fixed_mutator_r(zr)\n    m.fixed_mutator_c(zc)\n    m.fixed_mutator_a(zr)\n    m.fixed_mutator_a(zc)\n    with pytest.raises(TypeError) as excinfo:\n        m.fixed_mutator_r(zc)\n    assert ('(arg0: numpy.ndarray[numpy.float32[5, 6],'",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_cpp_casting",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_cpp_casting():\n    assert m.cpp_copy(m.fixed_r()) == 22.\n    assert m.cpp_copy(m.fixed_c()) == 22.\n    z = np.array([[5., 6], [7, 8]])\n    assert m.cpp_copy(z) == 7.\n    assert m.cpp_copy(m.get_cm_ref()) == 21.\n    assert m.cpp_copy(m.get_rm_ref()) == 21.\n    assert m.cpp_ref_c(m.get_cm_ref()) == 21.\n    assert m.cpp_ref_r(m.get_rm_ref()) == 21.\n    with pytest.raises(RuntimeError) as excinfo:",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_pass_readonly_array",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_pass_readonly_array():\n    z = np.full((5, 6), 42.0)\n    z.flags.writeable = False\n    np.testing.assert_array_equal(z, m.fixed_copy_r(z))\n    np.testing.assert_array_equal(m.fixed_r_const(), m.fixed_r())\n    assert not m.fixed_r_const().flags.writeable\n    np.testing.assert_array_equal(m.fixed_copy_r(m.fixed_r_const()), m.fixed_r_const())\ndef test_nonunit_stride_from_python():\n    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))\n    second_row = counting_mat[1, :]",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_nonunit_stride_from_python",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_nonunit_stride_from_python():\n    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))\n    second_row = counting_mat[1, :]\n    second_col = counting_mat[:, 1]\n    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)\n    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)\n    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)\n    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)\n    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)\n    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_negative_stride_from_python",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_negative_stride_from_python(msg):\n    \"\"\"Eigen doesn't support (as of yet) negative strides. When a function takes an Eigen matrix by\n    copy or const reference, we can pass a numpy array that has negative strides.  Otherwise, an\n    exception will be thrown as Eigen will not be able to map the numpy array.\"\"\"\n    counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))\n    counting_mat = counting_mat[::-1, ::-1]\n    second_row = counting_mat[1, :]\n    second_col = counting_mat[:, 1]\n    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)\n    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_nonunit_stride_to_python",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_nonunit_stride_to_python():\n    assert np.all(m.diagonal(ref) == ref.diagonal())\n    assert np.all(m.diagonal_1(ref) == ref.diagonal(1))\n    for i in range(-5, 7):\n        assert np.all(m.diagonal_n(ref, i) == ref.diagonal(i)), \"m.diagonal_n({})\".format(i)\n    assert np.all(m.block(ref, 2, 1, 3, 3) == ref[2:5, 1:4])\n    assert np.all(m.block(ref, 1, 4, 4, 2) == ref[1:, 4:])\n    assert np.all(m.block(ref, 1, 4, 3, 2) == ref[1:4, 4:])\ndef test_eigen_ref_to_python():\n    chols = [m.cholesky1, m.cholesky2, m.cholesky3, m.cholesky4]",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_eigen_ref_to_python",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_eigen_ref_to_python():\n    chols = [m.cholesky1, m.cholesky2, m.cholesky3, m.cholesky4]\n    for i, chol in enumerate(chols, start=1):\n        mymat = chol(np.array([[1., 2, 4], [2, 13, 23], [4, 23, 77]]))\n        assert np.all(mymat == np.array([[1, 0, 0], [2, 3, 0], [4, 5, 6]])), \"cholesky{}\".format(i)\ndef assign_both(a1, a2, r, c, v):\n    a1[r, c] = v\n    a2[r, c] = v\ndef array_copy_but_one(a, r, c, v):\n    z = np.array(a, copy=True)",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "assign_both",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def assign_both(a1, a2, r, c, v):\n    a1[r, c] = v\n    a2[r, c] = v\ndef array_copy_but_one(a, r, c, v):\n    z = np.array(a, copy=True)\n    z[r, c] = v\n    return z\ndef test_eigen_return_references():\n    \"\"\"Tests various ways of returning references and non-referencing copies\"\"\"\n    master = np.ones((10, 10))",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "array_copy_but_one",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def array_copy_but_one(a, r, c, v):\n    z = np.array(a, copy=True)\n    z[r, c] = v\n    return z\ndef test_eigen_return_references():\n    \"\"\"Tests various ways of returning references and non-referencing copies\"\"\"\n    master = np.ones((10, 10))\n    a = m.ReturnTester()\n    a_get1 = a.get()\n    assert not a_get1.flags.owndata and a_get1.flags.writeable",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_eigen_return_references",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_eigen_return_references():\n    \"\"\"Tests various ways of returning references and non-referencing copies\"\"\"\n    master = np.ones((10, 10))\n    a = m.ReturnTester()\n    a_get1 = a.get()\n    assert not a_get1.flags.owndata and a_get1.flags.writeable\n    assign_both(a_get1, master, 3, 3, 5)\n    a_get2 = a.get_ptr()\n    assert not a_get2.flags.owndata and a_get2.flags.writeable\n    assign_both(a_get1, master, 2, 3, 6)",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "assert_keeps_alive",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def assert_keeps_alive(cl, method, *args):\n    cstats = ConstructorStats.get(cl)\n    start_with = cstats.alive()\n    a = cl()\n    assert cstats.alive() == start_with + 1\n    z = method(a, *args)\n    assert cstats.alive() == start_with + 1\n    del a\n    # Here's the keep alive in action:\n    assert cstats.alive() == start_with + 1",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_eigen_keepalive",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_eigen_keepalive():\n    a = m.ReturnTester()\n    cstats = ConstructorStats.get(m.ReturnTester)\n    assert cstats.alive() == 1\n    unsafe = [a.ref(), a.ref_const(), a.block(1, 2, 3, 4)]\n    copies = [a.copy_get(), a.copy_view(), a.copy_ref(), a.copy_ref_const(),\n              a.copy_block(4, 3, 2, 1)]\n    del a\n    assert cstats.alive() == 0\n    del unsafe",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_eigen_ref_mutators",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_eigen_ref_mutators():\n    \"\"\"Tests Eigen's ability to mutate numpy values\"\"\"\n    orig = np.array([[1., 2, 3], [4, 5, 6], [7, 8, 9]])\n    zr = np.array(orig)\n    zc = np.array(orig, order='F')\n    m.add_rm(zr, 1, 0, 100)\n    assert np.all(zr == np.array([[1., 2, 3], [104, 5, 6], [7, 8, 9]]))\n    m.add_cm(zc, 1, 0, 200)\n    assert np.all(zc == np.array([[1., 2, 3], [204, 5, 6], [7, 8, 9]]))\n    m.add_any(zr, 1, 0, 20)",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_numpy_ref_mutators",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_numpy_ref_mutators():\n    \"\"\"Tests numpy mutating Eigen matrices (for returned Eigen::Ref<...>s)\"\"\"\n    m.reset_refs()  # In case another test already changed it\n    zc = m.get_cm_ref()\n    zcro = m.get_cm_const_ref()\n    zr = m.get_rm_ref()\n    zrro = m.get_rm_const_ref()\n    assert [zc[1, 2], zcro[1, 2], zr[1, 2], zrro[1, 2]] == [23] * 4\n    assert not zc.flags.owndata and zc.flags.writeable\n    assert not zr.flags.owndata and zr.flags.writeable",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_both_ref_mutators",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_both_ref_mutators():\n    \"\"\"Tests a complex chain of nested eigen/numpy references\"\"\"\n    m.reset_refs()  # In case another test already changed it\n    z = m.get_cm_ref()  # numpy -> eigen\n    z[0, 2] -= 3\n    z2 = m.incr_matrix(z, 1)  # numpy -> eigen -> numpy -> eigen\n    z2[1, 1] += 6\n    z3 = m.incr_matrix(z, 2)  # (numpy -> eigen)^3\n    z3[2, 2] += -5\n    z4 = m.incr_matrix(z, 3)  # (numpy -> eigen)^4",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_nocopy_wrapper",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_nocopy_wrapper():\n    # get_elem requires a column-contiguous matrix reference, but should be\n    # callable with other types of matrix (via copying):\n    int_matrix_colmajor = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], order='F')\n    dbl_matrix_colmajor = np.array(int_matrix_colmajor, dtype='double', order='F', copy=True)\n    int_matrix_rowmajor = np.array(int_matrix_colmajor, order='C', copy=True)\n    dbl_matrix_rowmajor = np.array(int_matrix_rowmajor, dtype='double', order='C', copy=True)\n    # All should be callable via get_elem:\n    assert m.get_elem(int_matrix_colmajor) == 8\n    assert m.get_elem(dbl_matrix_colmajor) == 8",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_eigen_ref_life_support",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_eigen_ref_life_support():\n    \"\"\"Ensure the lifetime of temporary arrays created by the `Ref` caster\n    The `Ref` caster sometimes creates a copy which needs to stay alive. This needs to\n    happen both for directs casts (just the array) or indirectly (e.g. list of arrays).\n    \"\"\"\n    a = np.full(shape=10, fill_value=8, dtype=np.int8)\n    assert m.get_elem_direct(a) == 8\n    list_of_a = [a]\n    assert m.get_elem_indirect(list_of_a) == 8\ndef test_special_matrix_objects():",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_special_matrix_objects",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_special_matrix_objects():\n    assert np.all(m.incr_diag(7) == np.diag([1., 2, 3, 4, 5, 6, 7]))\n    asymm = np.array([[ 1.,  2,  3,  4],\n                      [ 5,  6,  7,  8],\n                      [ 9, 10, 11, 12],\n                      [13, 14, 15, 16]])\n    symm_lower = np.array(asymm)\n    symm_upper = np.array(asymm)\n    for i in range(4):\n        for j in range(i + 1, 4):",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_dense_signature",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_dense_signature(doc):\n    assert doc(m.double_col) == \"\"\"\n        double_col(arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]\n    \"\"\"\n    assert doc(m.double_row) == \"\"\"\n        double_row(arg0: numpy.ndarray[numpy.float32[1, n]]) -> numpy.ndarray[numpy.float32[1, n]]\n    \"\"\"\n    assert doc(m.double_complex) == (\"\"\"\n        double_complex(arg0: numpy.ndarray[numpy.complex64[m, 1]])\"\"\"\n                                     \"\"\" -> numpy.ndarray[numpy.complex64[m, 1]]",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_named_arguments",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_named_arguments():\n    a = np.array([[1.0, 2], [3, 4], [5, 6]])\n    b = np.ones((2, 1))\n    assert np.all(m.matrix_multiply(a, b) == np.array([[3.], [7], [11]]))\n    assert np.all(m.matrix_multiply(A=a, B=b) == np.array([[3.], [7], [11]]))\n    assert np.all(m.matrix_multiply(B=b, A=a) == np.array([[3.], [7], [11]]))\n    with pytest.raises(ValueError) as excinfo:\n        m.matrix_multiply(b, a)\n    assert str(excinfo.value) == 'Nonconformable matrices!'\n    with pytest.raises(ValueError) as excinfo:",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_sparse",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_sparse():\n    pytest.importorskip(\"scipy\")\n    assert_sparse_equal_ref(m.sparse_r())\n    assert_sparse_equal_ref(m.sparse_c())\n    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_r()))\n    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_c()))\n    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_c()))\n    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_r()))\ndef test_sparse_signature(doc):\n    pytest.importorskip(\"scipy\")",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_sparse_signature",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_sparse_signature(doc):\n    pytest.importorskip(\"scipy\")\n    assert doc(m.sparse_copy_r) == \"\"\"\n        sparse_copy_r(arg0: scipy.sparse.csr_matrix[numpy.float32]) -> scipy.sparse.csr_matrix[numpy.float32]\n    \"\"\"  # noqa: E501 line too long\n    assert doc(m.sparse_copy_c) == \"\"\"\n        sparse_copy_c(arg0: scipy.sparse.csc_matrix[numpy.float32]) -> scipy.sparse.csc_matrix[numpy.float32]\n    \"\"\"  # noqa: E501 line too long\ndef test_issue738():\n    \"\"\"Ignore strides on a length-1 dimension (even if they would be incompatible length > 1)\"\"\"",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_issue738",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_issue738():\n    \"\"\"Ignore strides on a length-1 dimension (even if they would be incompatible length > 1)\"\"\"\n    assert np.all(m.iss738_f1(np.array([[1., 2, 3]])) == np.array([[1., 102, 203]]))\n    assert np.all(m.iss738_f1(np.array([[1.], [2], [3]])) == np.array([[1.], [12], [23]]))\n    assert np.all(m.iss738_f2(np.array([[1., 2, 3]])) == np.array([[1., 102, 203]]))\n    assert np.all(m.iss738_f2(np.array([[1.], [2], [3]])) == np.array([[1.], [12], [23]]))\ndef test_issue1105():\n    \"\"\"Issue 1105: 1xN or Nx1 input arrays weren't accepted for eigen\n    compile-time row vectors or column vector\"\"\"\n    assert m.iss1105_row(np.ones((1, 7)))",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_issue1105",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_issue1105():\n    \"\"\"Issue 1105: 1xN or Nx1 input arrays weren't accepted for eigen\n    compile-time row vectors or column vector\"\"\"\n    assert m.iss1105_row(np.ones((1, 7)))\n    assert m.iss1105_col(np.ones((7, 1)))\n    # These should still fail (incompatible dimensions):\n    with pytest.raises(TypeError) as excinfo:\n        m.iss1105_row(np.ones((7, 1)))\n    assert \"incompatible function arguments\" in str(excinfo.value)\n    with pytest.raises(TypeError) as excinfo:",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_custom_operator_new",
        "kind": 2,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "def test_custom_operator_new():\n    \"\"\"Using Eigen types as member variables requires a class-specific\n    operator new with proper alignment\"\"\"\n    o = m.CustomOperatorNew()\n    np.testing.assert_allclose(o.a, 0.0)\n    np.testing.assert_allclose(o.b.diagonal(), 1.0)",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "np",
        "kind": 5,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "np = pytest.importorskip(\"numpy\")\nm = pytest.importorskip(\"pybind11_tests.eigen\")\nref = np.array([[ 0.,  3,  0,  0,  0, 11],\n                [22,  0,  0,  0, 17, 11],\n                [ 7,  5,  0,  1,  0, 11],\n                [ 0,  0,  0,  0,  0, 11],\n                [ 0,  0, 14,  0,  8, 11]])\ndef assert_equal_ref(mat):\n    np.testing.assert_array_equal(mat, ref)\ndef assert_sparse_equal_ref(sparse_mat):",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "m = pytest.importorskip(\"pybind11_tests.eigen\")\nref = np.array([[ 0.,  3,  0,  0,  0, 11],\n                [22,  0,  0,  0, 17, 11],\n                [ 7,  5,  0,  1,  0, 11],\n                [ 0,  0,  0,  0,  0, 11],\n                [ 0,  0, 14,  0,  8, 11]])\ndef assert_equal_ref(mat):\n    np.testing.assert_array_equal(mat, ref)\ndef assert_sparse_equal_ref(sparse_mat):\n    assert_equal_ref(sparse_mat.toarray())",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "ref",
        "kind": 5,
        "importPath": "pybind11.tests.test_eigen",
        "description": "pybind11.tests.test_eigen",
        "peekOfCode": "ref = np.array([[ 0.,  3,  0,  0,  0, 11],\n                [22,  0,  0,  0, 17, 11],\n                [ 7,  5,  0,  1,  0, 11],\n                [ 0,  0,  0,  0,  0, 11],\n                [ 0,  0, 14,  0,  8, 11]])\ndef assert_equal_ref(mat):\n    np.testing.assert_array_equal(mat, ref)\ndef assert_sparse_equal_ref(sparse_mat):\n    assert_equal_ref(sparse_mat.toarray())\ndef test_fixed():",
        "detail": "pybind11.tests.test_eigen",
        "documentation": {}
    },
    {
        "label": "test_unscoped_enum",
        "kind": 2,
        "importPath": "pybind11.tests.test_enum",
        "description": "pybind11.tests.test_enum",
        "peekOfCode": "def test_unscoped_enum():\n    assert str(m.UnscopedEnum.EOne) == \"UnscopedEnum.EOne\"\n    assert str(m.UnscopedEnum.ETwo) == \"UnscopedEnum.ETwo\"\n    assert str(m.EOne) == \"UnscopedEnum.EOne\"\n    # name property\n    assert m.UnscopedEnum.EOne.name == \"EOne\"\n    assert m.UnscopedEnum.ETwo.name == \"ETwo\"\n    assert m.EOne.name == \"EOne\"\n    # name readonly\n    with pytest.raises(AttributeError):",
        "detail": "pybind11.tests.test_enum",
        "documentation": {}
    },
    {
        "label": "test_scoped_enum",
        "kind": 2,
        "importPath": "pybind11.tests.test_enum",
        "description": "pybind11.tests.test_enum",
        "peekOfCode": "def test_scoped_enum():\n    assert m.test_scoped_enum(m.ScopedEnum.Three) == \"ScopedEnum::Three\"\n    z = m.ScopedEnum.Two\n    assert m.test_scoped_enum(z) == \"ScopedEnum::Two\"\n    # Scoped enums will *NOT* accept ==/!= int comparisons (Will always return False)\n    assert not z == 3\n    assert not 3 == z\n    assert z != 3\n    assert 3 != z\n    # Compare with None",
        "detail": "pybind11.tests.test_enum",
        "documentation": {}
    },
    {
        "label": "test_implicit_conversion",
        "kind": 2,
        "importPath": "pybind11.tests.test_enum",
        "description": "pybind11.tests.test_enum",
        "peekOfCode": "def test_implicit_conversion():\n    assert str(m.ClassWithUnscopedEnum.EMode.EFirstMode) == \"EMode.EFirstMode\"\n    assert str(m.ClassWithUnscopedEnum.EFirstMode) == \"EMode.EFirstMode\"\n    f = m.ClassWithUnscopedEnum.test_function\n    first = m.ClassWithUnscopedEnum.EFirstMode\n    second = m.ClassWithUnscopedEnum.ESecondMode\n    assert f(first) == 1\n    assert f(first) == f(first)\n    assert not f(first) != f(first)\n    assert f(first) != f(second)",
        "detail": "pybind11.tests.test_enum",
        "documentation": {}
    },
    {
        "label": "test_binary_operators",
        "kind": 2,
        "importPath": "pybind11.tests.test_enum",
        "description": "pybind11.tests.test_enum",
        "peekOfCode": "def test_binary_operators():\n    assert int(m.Flags.Read) == 4\n    assert int(m.Flags.Write) == 2\n    assert int(m.Flags.Execute) == 1\n    assert int(m.Flags.Read | m.Flags.Write | m.Flags.Execute) == 7\n    assert int(m.Flags.Read | m.Flags.Write) == 6\n    assert int(m.Flags.Read | m.Flags.Execute) == 5\n    assert int(m.Flags.Write | m.Flags.Execute) == 3\n    assert int(m.Flags.Write | 1) == 3\n    assert ~m.Flags.Write == -3",
        "detail": "pybind11.tests.test_enum",
        "documentation": {}
    },
    {
        "label": "test_enum_to_int",
        "kind": 2,
        "importPath": "pybind11.tests.test_enum",
        "description": "pybind11.tests.test_enum",
        "peekOfCode": "def test_enum_to_int():\n    m.test_enum_to_int(m.Flags.Read)\n    m.test_enum_to_int(m.ClassWithUnscopedEnum.EMode.EFirstMode)\n    m.test_enum_to_uint(m.Flags.Read)\n    m.test_enum_to_uint(m.ClassWithUnscopedEnum.EMode.EFirstMode)\n    m.test_enum_to_long_long(m.Flags.Read)\n    m.test_enum_to_long_long(m.ClassWithUnscopedEnum.EMode.EFirstMode)\ndef test_duplicate_enum_name():\n    with pytest.raises(ValueError) as excinfo:\n        m.register_bad_enum()",
        "detail": "pybind11.tests.test_enum",
        "documentation": {}
    },
    {
        "label": "test_duplicate_enum_name",
        "kind": 2,
        "importPath": "pybind11.tests.test_enum",
        "description": "pybind11.tests.test_enum",
        "peekOfCode": "def test_duplicate_enum_name():\n    with pytest.raises(ValueError) as excinfo:\n        m.register_bad_enum()\n    assert str(excinfo.value) == 'SimpleEnum: element \"ONE\" already exists!'",
        "detail": "pybind11.tests.test_enum",
        "documentation": {}
    },
    {
        "label": "test_evals",
        "kind": 2,
        "importPath": "pybind11.tests.test_eval",
        "description": "pybind11.tests.test_eval",
        "peekOfCode": "def test_evals(capture):\n    with capture:\n        assert m.test_eval_statements()\n    assert capture == \"Hello World!\"\n    assert m.test_eval()\n    assert m.test_eval_single_statement()\n    assert m.test_eval_failure()\n@pytest.mark.xfail(\"env.PYPY and not env.PY2\", raises=RuntimeError)\ndef test_eval_file():\n    filename = os.path.join(os.path.dirname(__file__), \"test_eval_call.py\")",
        "detail": "pybind11.tests.test_eval",
        "documentation": {}
    },
    {
        "label": "test_eval_file",
        "kind": 2,
        "importPath": "pybind11.tests.test_eval",
        "description": "pybind11.tests.test_eval",
        "peekOfCode": "def test_eval_file():\n    filename = os.path.join(os.path.dirname(__file__), \"test_eval_call.py\")\n    assert m.test_eval_file(filename)\n    assert m.test_eval_file_failure()",
        "detail": "pybind11.tests.test_eval",
        "documentation": {}
    },
    {
        "label": "test_std_exception",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_std_exception(msg):\n    with pytest.raises(RuntimeError) as excinfo:\n        m.throw_std_exception()\n    assert msg(excinfo.value) == \"This exception was intentionally thrown.\"\ndef test_error_already_set(msg):\n    with pytest.raises(RuntimeError) as excinfo:\n        m.throw_already_set(False)\n    assert msg(excinfo.value) == \"Unknown internal error occurred\"\n    with pytest.raises(ValueError) as excinfo:\n        m.throw_already_set(True)",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_error_already_set",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_error_already_set(msg):\n    with pytest.raises(RuntimeError) as excinfo:\n        m.throw_already_set(False)\n    assert msg(excinfo.value) == \"Unknown internal error occurred\"\n    with pytest.raises(ValueError) as excinfo:\n        m.throw_already_set(True)\n    assert msg(excinfo.value) == \"foo\"\ndef test_cross_module_exceptions():\n    with pytest.raises(RuntimeError) as excinfo:\n        cm.raise_runtime_error()",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_cross_module_exceptions",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_cross_module_exceptions():\n    with pytest.raises(RuntimeError) as excinfo:\n        cm.raise_runtime_error()\n    assert str(excinfo.value) == \"My runtime error\"\n    with pytest.raises(ValueError) as excinfo:\n        cm.raise_value_error()\n    assert str(excinfo.value) == \"My value error\"\n    with pytest.raises(ValueError) as excinfo:\n        cm.throw_pybind_value_error()\n    assert str(excinfo.value) == \"pybind11 value error\"",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_python_call_in_catch",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_python_call_in_catch():\n    d = {}\n    assert m.python_call_in_destructor(d) is True\n    assert d[\"good\"] is True\ndef test_python_alreadyset_in_destructor(monkeypatch, capsys):\n    hooked = False\n    triggered = [False]  # mutable, so Python 2.7 closure can modify it\n    if hasattr(sys, 'unraisablehook'):  # Python 3.8+\n        hooked = True\n        default_hook = sys.unraisablehook",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_python_alreadyset_in_destructor",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_python_alreadyset_in_destructor(monkeypatch, capsys):\n    hooked = False\n    triggered = [False]  # mutable, so Python 2.7 closure can modify it\n    if hasattr(sys, 'unraisablehook'):  # Python 3.8+\n        hooked = True\n        default_hook = sys.unraisablehook\n        def hook(unraisable_hook_args):\n            exc_type, exc_value, exc_tb, err_msg, obj = unraisable_hook_args\n            if obj == 'already_set demo':\n                triggered[0] = True",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_exception_matches",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_exception_matches():\n    assert m.exception_matches()\n    assert m.exception_matches_base()\n    assert m.modulenotfound_exception_matches_base()\ndef test_custom(msg):\n    # Can we catch a MyException?\n    with pytest.raises(m.MyException) as excinfo:\n        m.throws1()\n    assert msg(excinfo.value) == \"this error should go to a custom type\"\n    # Can we translate to standard Python exceptions?",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_custom",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_custom(msg):\n    # Can we catch a MyException?\n    with pytest.raises(m.MyException) as excinfo:\n        m.throws1()\n    assert msg(excinfo.value) == \"this error should go to a custom type\"\n    # Can we translate to standard Python exceptions?\n    with pytest.raises(RuntimeError) as excinfo:\n        m.throws2()\n    assert msg(excinfo.value) == \"this error should go to a standard Python exception\"\n    # Can we handle unknown exceptions?",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_nested_throws",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_nested_throws(capture):\n    \"\"\"Tests nested (e.g. C++ -> Python -> C++) exception handling\"\"\"\n    def throw_myex():\n        raise m.MyException(\"nested error\")\n    def throw_myex5():\n        raise m.MyException5(\"nested error 5\")\n    # In the comments below, the exception is caught in the first step, thrown in the last step\n    # C++ -> Python\n    with capture:\n        m.try_catch(m.MyException5, throw_myex5)",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_invalid_repr",
        "kind": 2,
        "importPath": "pybind11.tests.test_exceptions",
        "description": "pybind11.tests.test_exceptions",
        "peekOfCode": "def test_invalid_repr():\n    class MyRepr(object):\n        def __repr__(self):\n            raise AttributeError(\"Example error\")\n    with pytest.raises(TypeError):\n        m.simple_bool_passthrough(MyRepr())",
        "detail": "pybind11.tests.test_exceptions",
        "documentation": {}
    },
    {
        "label": "test_init_factory_basic",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_init_factory_basic():\n    \"\"\"Tests py::init_factory() wrapper around various ways of returning the object\"\"\"\n    cstats = [ConstructorStats.get(c) for c in [m.TestFactory1, m.TestFactory2, m.TestFactory3]]\n    cstats[0].alive()  # force gc\n    n_inst = ConstructorStats.detail_reg_inst()\n    x1 = m.TestFactory1(tag.unique_ptr, 3)\n    assert x1.value == \"3\"\n    y1 = m.TestFactory1(tag.pointer)\n    assert y1.value == \"(empty)\"\n    z1 = m.TestFactory1(\"hi!\")",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_init_factory_signature",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_init_factory_signature(msg):\n    with pytest.raises(TypeError) as excinfo:\n        m.TestFactory1(\"invalid\", \"constructor\", \"arguments\")\n    assert msg(excinfo.value) == \"\"\"\n        __init__(): incompatible constructor arguments. The following argument types are supported:\n            1. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int)\n            2. m.factory_constructors.TestFactory1(arg0: str)\n            3. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.pointer_tag)\n            4. m.factory_constructors.TestFactory1(arg0: handle, arg1: int, arg2: handle)\n        Invoked with: 'invalid', 'constructor', 'arguments'",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_init_factory_casting",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_init_factory_casting():\n    \"\"\"Tests py::init_factory() wrapper with various upcasting and downcasting returns\"\"\"\n    cstats = [ConstructorStats.get(c) for c in [m.TestFactory3, m.TestFactory4, m.TestFactory5]]\n    cstats[0].alive()  # force gc\n    n_inst = ConstructorStats.detail_reg_inst()\n    # Construction from derived references:\n    a = m.TestFactory3(tag.pointer, tag.TF4, 4)\n    assert a.value == \"4\"\n    b = m.TestFactory3(tag.shared_ptr, tag.TF4, 5)\n    assert b.value == \"5\"",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_init_factory_alias",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_init_factory_alias():\n    \"\"\"Tests py::init_factory() wrapper with value conversions and alias types\"\"\"\n    cstats = [m.TestFactory6.get_cstats(), m.TestFactory6.get_alias_cstats()]\n    cstats[0].alive()  # force gc\n    n_inst = ConstructorStats.detail_reg_inst()\n    a = m.TestFactory6(tag.base, 1)\n    assert a.get() == 1\n    assert not a.has_alias()\n    b = m.TestFactory6(tag.alias, \"hi there\")\n    assert b.get() == 8",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_init_factory_dual",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_init_factory_dual():\n    \"\"\"Tests init factory functions with dual main/alias factory functions\"\"\"\n    from pybind11_tests.factory_constructors import TestFactory7\n    cstats = [TestFactory7.get_cstats(), TestFactory7.get_alias_cstats()]\n    cstats[0].alive()  # force gc\n    n_inst = ConstructorStats.detail_reg_inst()\n    class PythFactory7(TestFactory7):\n        def get(self):\n            return 100 + TestFactory7.get(self)\n    a1 = TestFactory7(1)",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_no_placement_new",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_no_placement_new(capture):\n    \"\"\"Prior to 2.2, `py::init<...>` relied on the type supporting placement\n    new; this tests a class without placement new support.\"\"\"\n    with capture:\n        a = m.NoPlacementNew(123)\n    found = re.search(r'^operator new called, returning (\\d+)\\n$', str(capture))\n    assert found\n    assert a.i == 123\n    with capture:\n        del a",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_multiple_inheritance",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_multiple_inheritance():\n    class MITest(m.TestFactory1, m.TestFactory2):\n        def __init__(self):\n            m.TestFactory1.__init__(self, tag.unique_ptr, 33)\n            m.TestFactory2.__init__(self, tag.move)\n    a = MITest()\n    assert m.TestFactory1.value.fget(a) == \"33\"\n    assert m.TestFactory2.value.fget(a) == \"(empty2)\"\ndef create_and_destroy(*args):\n    a = m.NoisyAlloc(*args)",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "create_and_destroy",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def create_and_destroy(*args):\n    a = m.NoisyAlloc(*args)\n    print(\"---\")\n    del a\n    pytest.gc_collect()\ndef strip_comments(s):\n    return re.sub(r'\\s+#.*', '', s)\ndef test_reallocations(capture, msg):\n    \"\"\"When the constructor is overloaded, previous overloads can require a preallocated value.\n    This test makes sure that such preallocated values only happen when they might be necessary,",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "strip_comments",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def strip_comments(s):\n    return re.sub(r'\\s+#.*', '', s)\ndef test_reallocations(capture, msg):\n    \"\"\"When the constructor is overloaded, previous overloads can require a preallocated value.\n    This test makes sure that such preallocated values only happen when they might be necessary,\n    and that they are deallocated properly\"\"\"\n    pytest.gc_collect()\n    with capture:\n        create_and_destroy(1)\n    assert msg(capture) == \"\"\"",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_reallocations",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_reallocations(capture, msg):\n    \"\"\"When the constructor is overloaded, previous overloads can require a preallocated value.\n    This test makes sure that such preallocated values only happen when they might be necessary,\n    and that they are deallocated properly\"\"\"\n    pytest.gc_collect()\n    with capture:\n        create_and_destroy(1)\n    assert msg(capture) == \"\"\"\n        noisy new\n        noisy placement new",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_invalid_self",
        "kind": 2,
        "importPath": "pybind11.tests.test_factory_constructors",
        "description": "pybind11.tests.test_factory_constructors",
        "peekOfCode": "def test_invalid_self():\n    \"\"\"Tests invocation of the pybind-registered base class with an invalid `self` argument.  You\n    can only actually do this on Python 3: Python 2 raises an exception itself if you try.\"\"\"\n    class NotPybindDerived(object):\n        pass\n    # Attempts to initialize with an invalid type passed as `self`:\n    class BrokenTF1(m.TestFactory1):\n        def __init__(self, bad):\n            if bad == 1:\n                a = m.TestFactory2(tag.pointer, 1)",
        "detail": "pybind11.tests.test_factory_constructors",
        "documentation": {}
    },
    {
        "label": "test_python_to_cpp_to_python_from_thread",
        "kind": 2,
        "importPath": "pybind11.tests.test_gil_scoped",
        "description": "pybind11.tests.test_gil_scoped",
        "peekOfCode": "def test_python_to_cpp_to_python_from_thread():\n    \"\"\"Makes sure there is no GIL deadlock when running in a thread.\n    It runs in a separate process to be able to stop and assert if it deadlocks.\n    \"\"\"\n    assert _run_in_process(_python_to_cpp_to_python_from_threads, 1) == 0\n# TODO: FIXME\n@pytest.mark.xfail(\"env.PY > (3,8) and env.MACOS\", strict=False)\ndef test_python_to_cpp_to_python_from_thread_multiple_parallel():\n    \"\"\"Makes sure there is no GIL deadlock when running in a thread multiple times in parallel.\n    It runs in a separate process to be able to stop and assert if it deadlocks.",
        "detail": "pybind11.tests.test_gil_scoped",
        "documentation": {}
    },
    {
        "label": "test_python_to_cpp_to_python_from_thread_multiple_parallel",
        "kind": 2,
        "importPath": "pybind11.tests.test_gil_scoped",
        "description": "pybind11.tests.test_gil_scoped",
        "peekOfCode": "def test_python_to_cpp_to_python_from_thread_multiple_parallel():\n    \"\"\"Makes sure there is no GIL deadlock when running in a thread multiple times in parallel.\n    It runs in a separate process to be able to stop and assert if it deadlocks.\n    \"\"\"\n    assert _run_in_process(_python_to_cpp_to_python_from_threads, 8, parallel=True) == 0\n# TODO: FIXME\n@pytest.mark.xfail(\"env.PY > (3,8) and env.MACOS\", strict=False)\ndef test_python_to_cpp_to_python_from_thread_multiple_sequential():\n    \"\"\"Makes sure there is no GIL deadlock when running in a thread multiple times sequentially.\n    It runs in a separate process to be able to stop and assert if it deadlocks.",
        "detail": "pybind11.tests.test_gil_scoped",
        "documentation": {}
    },
    {
        "label": "test_python_to_cpp_to_python_from_thread_multiple_sequential",
        "kind": 2,
        "importPath": "pybind11.tests.test_gil_scoped",
        "description": "pybind11.tests.test_gil_scoped",
        "peekOfCode": "def test_python_to_cpp_to_python_from_thread_multiple_sequential():\n    \"\"\"Makes sure there is no GIL deadlock when running in a thread multiple times sequentially.\n    It runs in a separate process to be able to stop and assert if it deadlocks.\n    \"\"\"\n    assert _run_in_process(_python_to_cpp_to_python_from_threads, 8, parallel=False) == 0\n# TODO: FIXME\n@pytest.mark.xfail(\"env.PY > (3,8) and env.MACOS\", strict=False)\ndef test_python_to_cpp_to_python_from_process():\n    \"\"\"Makes sure there is no GIL deadlock when using processes.\n    This test is for completion, but it was never an issue.",
        "detail": "pybind11.tests.test_gil_scoped",
        "documentation": {}
    },
    {
        "label": "test_python_to_cpp_to_python_from_process",
        "kind": 2,
        "importPath": "pybind11.tests.test_gil_scoped",
        "description": "pybind11.tests.test_gil_scoped",
        "peekOfCode": "def test_python_to_cpp_to_python_from_process():\n    \"\"\"Makes sure there is no GIL deadlock when using processes.\n    This test is for completion, but it was never an issue.\n    \"\"\"\n    assert _run_in_process(_python_to_cpp_to_python) == 0\ndef test_cross_module_gil():\n    \"\"\"Makes sure that the GIL can be acquired by another module from a GIL-released state.\"\"\"\n    m.test_cross_module_gil()  # Should not raise a SIGSEGV",
        "detail": "pybind11.tests.test_gil_scoped",
        "documentation": {}
    },
    {
        "label": "test_cross_module_gil",
        "kind": 2,
        "importPath": "pybind11.tests.test_gil_scoped",
        "description": "pybind11.tests.test_gil_scoped",
        "peekOfCode": "def test_cross_module_gil():\n    \"\"\"Makes sure that the GIL can be acquired by another module from a GIL-released state.\"\"\"\n    m.test_cross_module_gil()  # Should not raise a SIGSEGV",
        "detail": "pybind11.tests.test_gil_scoped",
        "documentation": {}
    },
    {
        "label": "test_captured",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_captured(capsys):\n    msg = \"I've been redirected to Python, I hope!\"\n    m.captured_output(msg)\n    stdout, stderr = capsys.readouterr()\n    assert stdout == msg\n    assert stderr == ''\n    m.captured_output_default(msg)\n    stdout, stderr = capsys.readouterr()\n    assert stdout == msg\n    assert stderr == ''",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_captured_large_string",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_captured_large_string(capsys):\n    # Make this bigger than the buffer used on the C++ side: 1024 chars\n    msg = \"I've been redirected to Python, I hope!\"\n    msg = msg * (1024 // len(msg) + 1)\n    m.captured_output_default(msg)\n    stdout, stderr = capsys.readouterr()\n    assert stdout == msg\n    assert stderr == ''\ndef test_guard_capture(capsys):\n    msg = \"I've been redirected to Python, I hope!\"",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_guard_capture",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_guard_capture(capsys):\n    msg = \"I've been redirected to Python, I hope!\"\n    m.guard_output(msg)\n    stdout, stderr = capsys.readouterr()\n    assert stdout == msg\n    assert stderr == ''\ndef test_series_captured(capture):\n    with capture:\n        m.captured_output(\"a\")\n        m.captured_output(\"b\")",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_series_captured",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_series_captured(capture):\n    with capture:\n        m.captured_output(\"a\")\n        m.captured_output(\"b\")\n    assert capture == \"ab\"\ndef test_flush(capfd):\n    msg = \"(not flushed)\"\n    msg2 = \"(flushed)\"\n    with m.ostream_redirect():\n        m.noisy_function(msg, flush=False)",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_flush",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_flush(capfd):\n    msg = \"(not flushed)\"\n    msg2 = \"(flushed)\"\n    with m.ostream_redirect():\n        m.noisy_function(msg, flush=False)\n        stdout, stderr = capfd.readouterr()\n        assert stdout == ''\n        m.noisy_function(msg2, flush=True)\n        stdout, stderr = capfd.readouterr()\n        assert stdout == msg + msg2",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_not_captured",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_not_captured(capfd):\n    msg = \"Something that should not show up in log\"\n    stream = StringIO()\n    with redirect_stdout(stream):\n        m.raw_output(msg)\n    stdout, stderr = capfd.readouterr()\n    assert stdout == msg\n    assert stderr == ''\n    assert stream.getvalue() == ''\n    stream = StringIO()",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_err",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_err(capfd):\n    msg = \"Something that should not show up in log\"\n    stream = StringIO()\n    with redirect_stderr(stream):\n        m.raw_err(msg)\n    stdout, stderr = capfd.readouterr()\n    assert stdout == ''\n    assert stderr == msg\n    assert stream.getvalue() == ''\n    stream = StringIO()",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_multi_captured",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_multi_captured(capfd):\n    stream = StringIO()\n    with redirect_stdout(stream):\n        m.captured_output(\"a\")\n        m.raw_output(\"b\")\n        m.captured_output(\"c\")\n        m.raw_output(\"d\")\n    stdout, stderr = capfd.readouterr()\n    assert stdout == 'bd'\n    assert stream.getvalue() == 'ac'",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_dual",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_dual(capsys):\n    m.captured_dual(\"a\", \"b\")\n    stdout, stderr = capsys.readouterr()\n    assert stdout == \"a\"\n    assert stderr == \"b\"\ndef test_redirect(capfd):\n    msg = \"Should not be in log!\"\n    stream = StringIO()\n    with redirect_stdout(stream):\n        m.raw_output(msg)",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_redirect",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_redirect(capfd):\n    msg = \"Should not be in log!\"\n    stream = StringIO()\n    with redirect_stdout(stream):\n        m.raw_output(msg)\n    stdout, stderr = capfd.readouterr()\n    assert stdout == msg\n    assert stream.getvalue() == ''\n    stream = StringIO()\n    with redirect_stdout(stream):",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_redirect_err",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_redirect_err(capfd):\n    msg = \"StdOut\"\n    msg2 = \"StdErr\"\n    stream = StringIO()\n    with redirect_stderr(stream):\n        with m.ostream_redirect(stdout=False):\n            m.raw_output(msg)\n            m.raw_err(msg2)\n    stdout, stderr = capfd.readouterr()\n    assert stdout == msg",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_redirect_both",
        "kind": 2,
        "importPath": "pybind11.tests.test_iostream",
        "description": "pybind11.tests.test_iostream",
        "peekOfCode": "def test_redirect_both(capfd):\n    msg = \"StdOut\"\n    msg2 = \"StdErr\"\n    stream = StringIO()\n    stream2 = StringIO()\n    with redirect_stdout(stream):\n        with redirect_stderr(stream2):\n            with m.ostream_redirect():\n                m.raw_output(msg)\n                m.raw_err(msg2)",
        "detail": "pybind11.tests.test_iostream",
        "documentation": {}
    },
    {
        "label": "test_function_signatures",
        "kind": 2,
        "importPath": "pybind11.tests.test_kwargs_and_defaults",
        "description": "pybind11.tests.test_kwargs_and_defaults",
        "peekOfCode": "def test_function_signatures(doc):\n    assert doc(m.kw_func0) == \"kw_func0(arg0: int, arg1: int) -> str\"\n    assert doc(m.kw_func1) == \"kw_func1(x: int, y: int) -> str\"\n    assert doc(m.kw_func2) == \"kw_func2(x: int = 100, y: int = 200) -> str\"\n    assert doc(m.kw_func3) == \"kw_func3(data: str = 'Hello world!') -> None\"\n    assert doc(m.kw_func4) == \"kw_func4(myList: List[int] = [13, 17]) -> str\"\n    assert doc(m.kw_func_udl) == \"kw_func_udl(x: int, y: int = 300) -> str\"\n    assert doc(m.kw_func_udl_z) == \"kw_func_udl_z(x: int, y: int = 0) -> str\"\n    assert doc(m.args_function) == \"args_function(*args) -> tuple\"\n    assert doc(m.args_kwargs_function) == \"args_kwargs_function(*args, **kwargs) -> tuple\"",
        "detail": "pybind11.tests.test_kwargs_and_defaults",
        "documentation": {}
    },
    {
        "label": "test_named_arguments",
        "kind": 2,
        "importPath": "pybind11.tests.test_kwargs_and_defaults",
        "description": "pybind11.tests.test_kwargs_and_defaults",
        "peekOfCode": "def test_named_arguments(msg):\n    assert m.kw_func0(5, 10) == \"x=5, y=10\"\n    assert m.kw_func1(5, 10) == \"x=5, y=10\"\n    assert m.kw_func1(5, y=10) == \"x=5, y=10\"\n    assert m.kw_func1(y=10, x=5) == \"x=5, y=10\"\n    assert m.kw_func2() == \"x=100, y=200\"\n    assert m.kw_func2(5) == \"x=5, y=200\"\n    assert m.kw_func2(x=5) == \"x=5, y=200\"\n    assert m.kw_func2(y=10) == \"x=100, y=10\"\n    assert m.kw_func2(5, 10) == \"x=5, y=10\"",
        "detail": "pybind11.tests.test_kwargs_and_defaults",
        "documentation": {}
    },
    {
        "label": "test_arg_and_kwargs",
        "kind": 2,
        "importPath": "pybind11.tests.test_kwargs_and_defaults",
        "description": "pybind11.tests.test_kwargs_and_defaults",
        "peekOfCode": "def test_arg_and_kwargs():\n    args = 'arg1_value', 'arg2_value', 3\n    assert m.args_function(*args) == args\n    args = 'a1', 'a2'\n    kwargs = dict(arg3='a3', arg4=4)\n    assert m.args_kwargs_function(*args, **kwargs) == (args, kwargs)\ndef test_mixed_args_and_kwargs(msg):\n    mpa = m.mixed_plus_args\n    mpk = m.mixed_plus_kwargs\n    mpak = m.mixed_plus_args_kwargs",
        "detail": "pybind11.tests.test_kwargs_and_defaults",
        "documentation": {}
    },
    {
        "label": "test_mixed_args_and_kwargs",
        "kind": 2,
        "importPath": "pybind11.tests.test_kwargs_and_defaults",
        "description": "pybind11.tests.test_kwargs_and_defaults",
        "peekOfCode": "def test_mixed_args_and_kwargs(msg):\n    mpa = m.mixed_plus_args\n    mpk = m.mixed_plus_kwargs\n    mpak = m.mixed_plus_args_kwargs\n    mpakd = m.mixed_plus_args_kwargs_defaults\n    assert mpa(1, 2.5, 4, 99.5, None) == (1, 2.5, (4, 99.5, None))\n    assert mpa(1, 2.5) == (1, 2.5, ())\n    with pytest.raises(TypeError) as excinfo:\n        assert mpa(1)\n    assert msg(excinfo.value) == \"\"\"",
        "detail": "pybind11.tests.test_kwargs_and_defaults",
        "documentation": {}
    },
    {
        "label": "test_keyword_only_args",
        "kind": 2,
        "importPath": "pybind11.tests.test_kwargs_and_defaults",
        "description": "pybind11.tests.test_kwargs_and_defaults",
        "peekOfCode": "def test_keyword_only_args(msg):\n    assert m.kwonly_all(i=1, j=2) == (1, 2)\n    assert m.kwonly_all(j=1, i=2) == (2, 1)\n    with pytest.raises(TypeError) as excinfo:\n        assert m.kwonly_all(i=1) == (1,)\n    assert \"incompatible function arguments\" in str(excinfo.value)\n    with pytest.raises(TypeError) as excinfo:\n        assert m.kwonly_all(1, 2) == (1, 2)\n    assert \"incompatible function arguments\" in str(excinfo.value)\n    assert m.kwonly_some(1, k=3, j=2) == (1, 2, 3)",
        "detail": "pybind11.tests.test_kwargs_and_defaults",
        "documentation": {}
    },
    {
        "label": "test_args_refcount",
        "kind": 2,
        "importPath": "pybind11.tests.test_kwargs_and_defaults",
        "description": "pybind11.tests.test_kwargs_and_defaults",
        "peekOfCode": "def test_args_refcount():\n    \"\"\"Issue/PR #1216 - py::args elements get double-inc_ref()ed when combined with regular\n    arguments\"\"\"\n    refcount = m.arg_refcount_h\n    myval = 54321\n    expected = refcount(myval)\n    assert m.arg_refcount_h(myval) == expected\n    assert m.arg_refcount_o(myval) == expected + 1\n    assert m.arg_refcount_h(myval) == expected\n    assert refcount(myval) == expected",
        "detail": "pybind11.tests.test_kwargs_and_defaults",
        "documentation": {}
    },
    {
        "label": "test_load_external",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_load_external():\n    \"\"\"Load a `py::module_local` type that's only registered in an external module\"\"\"\n    import pybind11_cross_module_tests as cm\n    assert m.load_external1(cm.ExternalType1(11)) == 11\n    assert m.load_external2(cm.ExternalType2(22)) == 22\n    with pytest.raises(TypeError) as excinfo:\n        assert m.load_external2(cm.ExternalType1(21)) == 21\n    assert \"incompatible function arguments\" in str(excinfo.value)\n    with pytest.raises(TypeError) as excinfo:\n        assert m.load_external1(cm.ExternalType2(12)) == 12",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_local_bindings",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_local_bindings():\n    \"\"\"Tests that duplicate `py::module_local` class bindings work across modules\"\"\"\n    # Make sure we can load the second module with the conflicting (but local) definition:\n    import pybind11_cross_module_tests as cm\n    i1 = m.LocalType(5)\n    assert i1.get() == 4\n    assert i1.get3() == 8\n    i2 = cm.LocalType(10)\n    assert i2.get() == 11\n    assert i2.get2() == 12",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_nonlocal_failure",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_nonlocal_failure():\n    \"\"\"Tests that attempting to register a non-local type in multiple modules fails\"\"\"\n    import pybind11_cross_module_tests as cm\n    with pytest.raises(RuntimeError) as excinfo:\n        cm.register_nonlocal()\n    assert str(excinfo.value) == 'generic_type: type \"NonLocalType\" is already registered!'\ndef test_duplicate_local():\n    \"\"\"Tests expected failure when registering a class twice with py::local in the same module\"\"\"\n    with pytest.raises(RuntimeError) as excinfo:\n        m.register_local_external()",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_duplicate_local",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_duplicate_local():\n    \"\"\"Tests expected failure when registering a class twice with py::local in the same module\"\"\"\n    with pytest.raises(RuntimeError) as excinfo:\n        m.register_local_external()\n    import pybind11_tests\n    assert str(excinfo.value) == (\n        'generic_type: type \"LocalExternal\" is already registered!'\n        if hasattr(pybind11_tests, 'class_') else 'test_class not enabled')\ndef test_stl_bind_local():\n    import pybind11_cross_module_tests as cm",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_stl_bind_local",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_stl_bind_local():\n    import pybind11_cross_module_tests as cm\n    v1, v2 = m.LocalVec(), cm.LocalVec()\n    v1.append(m.LocalType(1))\n    v1.append(m.LocalType(2))\n    v2.append(cm.LocalType(1))\n    v2.append(cm.LocalType(2))\n    # Cross module value loading:\n    v1.append(cm.LocalType(3))\n    v2.append(m.LocalType(3))",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_stl_bind_global",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_stl_bind_global():\n    import pybind11_cross_module_tests as cm\n    with pytest.raises(RuntimeError) as excinfo:\n        cm.register_nonlocal_map()\n    assert str(excinfo.value) == 'generic_type: type \"NonLocalMap\" is already registered!'\n    with pytest.raises(RuntimeError) as excinfo:\n        cm.register_nonlocal_vec()\n    assert str(excinfo.value) == 'generic_type: type \"NonLocalVec\" is already registered!'\n    with pytest.raises(RuntimeError) as excinfo:\n        cm.register_nonlocal_map2()",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_mixed_local_global",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_mixed_local_global():\n    \"\"\"Local types take precedence over globally registered types: a module with a `module_local`\n    type can be registered even if the type is already registered globally.  With the module,\n    casting will go to the local type; outside the module casting goes to the global type.\"\"\"\n    import pybind11_cross_module_tests as cm\n    m.register_mixed_global()\n    m.register_mixed_local()\n    a = []\n    a.append(m.MixedGlobalLocal(1))\n    a.append(m.MixedLocalGlobal(2))",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_internal_locals_differ",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_internal_locals_differ():\n    \"\"\"Makes sure the internal local type map differs across the two modules\"\"\"\n    import pybind11_cross_module_tests as cm\n    assert m.local_cpp_types_addr() != cm.local_cpp_types_addr()\n@pytest.mark.xfail(\"env.PYPY\")\ndef test_stl_caster_vs_stl_bind(msg):\n    \"\"\"One module uses a generic vector caster from `<pybind11/stl.h>` while the other\n    exports `std::vector<int>` via `py:bind_vector` and `py::module_local`\"\"\"\n    import pybind11_cross_module_tests as cm\n    v1 = cm.VectorInt([1, 2, 3])",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_stl_caster_vs_stl_bind",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_stl_caster_vs_stl_bind(msg):\n    \"\"\"One module uses a generic vector caster from `<pybind11/stl.h>` while the other\n    exports `std::vector<int>` via `py:bind_vector` and `py::module_local`\"\"\"\n    import pybind11_cross_module_tests as cm\n    v1 = cm.VectorInt([1, 2, 3])\n    assert m.load_vector_via_caster(v1) == 6\n    assert cm.load_vector_via_binding(v1) == 6\n    v2 = [1, 2, 3]\n    assert m.load_vector_via_caster(v2) == 6\n    with pytest.raises(TypeError) as excinfo:",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_cross_module_calls",
        "kind": 2,
        "importPath": "pybind11.tests.test_local_bindings",
        "description": "pybind11.tests.test_local_bindings",
        "peekOfCode": "def test_cross_module_calls():\n    import pybind11_cross_module_tests as cm\n    v1 = m.LocalVec()\n    v1.append(m.LocalType(1))\n    v2 = cm.LocalVec()\n    v2.append(cm.LocalType(2))\n    # Returning the self pointer should get picked up as returning an existing\n    # instance (even when that instance is of a foreign, non-local type).\n    assert m.return_self(v1) is v1\n    assert cm.return_self(v2) is v2",
        "detail": "pybind11.tests.test_local_bindings",
        "documentation": {}
    },
    {
        "label": "test_methods_and_attributes",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_methods_and_attributes():\n    instance1 = m.ExampleMandA()\n    instance2 = m.ExampleMandA(32)\n    instance1.add1(instance2)\n    instance1.add2(instance2)\n    instance1.add3(instance2)\n    instance1.add4(instance2)\n    instance1.add5(instance2)\n    instance1.add6(32)\n    instance1.add7(32)",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_copy_method",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_copy_method():\n    \"\"\"Issue #443: calling copied methods fails in Python 3\"\"\"\n    m.ExampleMandA.add2c = m.ExampleMandA.add2\n    m.ExampleMandA.add2d = m.ExampleMandA.add2b\n    a = m.ExampleMandA(123)\n    assert a.value == 123\n    a.add2(m.ExampleMandA(-100))\n    assert a.value == 23\n    a.add2b(m.ExampleMandA(20))\n    assert a.value == 43",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_properties",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_properties():\n    instance = m.TestProperties()\n    assert instance.def_readonly == 1\n    with pytest.raises(AttributeError):\n        instance.def_readonly = 2\n    instance.def_readwrite = 2\n    assert instance.def_readwrite == 2\n    assert instance.def_property_readonly == 2\n    with pytest.raises(AttributeError):\n        instance.def_property_readonly = 3",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_static_properties",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_static_properties():\n    assert m.TestProperties.def_readonly_static == 1\n    with pytest.raises(AttributeError) as excinfo:\n        m.TestProperties.def_readonly_static = 2\n    assert \"can't set attribute\" in str(excinfo.value)\n    m.TestProperties.def_readwrite_static = 2\n    assert m.TestProperties.def_readwrite_static == 2\n    with pytest.raises(AttributeError) as excinfo:\n        dummy = m.TestProperties.def_writeonly_static  # noqa: F841 unused var\n    assert \"unreadable attribute\" in str(excinfo.value)",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_static_cls",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_static_cls():\n    \"\"\"Static property getter and setters expect the type object as the their only argument\"\"\"\n    instance = m.TestProperties()\n    assert m.TestProperties.static_cls is m.TestProperties\n    assert instance.static_cls is m.TestProperties\n    def check_self(self):\n        assert self is m.TestProperties\n    m.TestProperties.static_cls = check_self\n    instance.static_cls = check_self\ndef test_metaclass_override():",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_metaclass_override",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_metaclass_override():\n    \"\"\"Overriding pybind11's default metaclass changes the behavior of `static_property`\"\"\"\n    assert type(m.ExampleMandA).__name__ == \"pybind11_type\"\n    assert type(m.MetaclassOverride).__name__ == \"type\"\n    assert m.MetaclassOverride.readonly == 1\n    assert type(m.MetaclassOverride.__dict__[\"readonly\"]).__name__ == \"pybind11_static_property\"\n    # Regular `type` replaces the property instead of calling `__set__()`\n    m.MetaclassOverride.readonly = 2\n    assert m.MetaclassOverride.readonly == 2\n    assert isinstance(m.MetaclassOverride.__dict__[\"readonly\"], int)",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_no_mixed_overloads",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_no_mixed_overloads():\n    from pybind11_tests import debug_enabled\n    with pytest.raises(RuntimeError) as excinfo:\n        m.ExampleMandA.add_mixed_overloads1()\n    assert (str(excinfo.value) ==\n            \"overloading a method with both static and instance methods is not supported; \" +\n            (\"compile in debug mode for more details\" if not debug_enabled else\n             \"error while attempting to bind static method ExampleMandA.overload_mixed1\"\n             \"(arg0: float) -> str\")\n            )",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_property_return_value_policies",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_property_return_value_policies(access):\n    if not access.startswith(\"static\"):\n        obj = m.TestPropRVP()\n    else:\n        obj = m.TestPropRVP\n    ref = getattr(obj, access + \"_ref\")\n    assert ref.value == 1\n    ref.value = 2\n    assert getattr(obj, access + \"_ref\").value == 2\n    ref.value = 1  # restore original value for static properties",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_property_rvalue_policy",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_property_rvalue_policy():\n    \"\"\"When returning an rvalue, the return value policy is automatically changed from\n    `reference(_internal)` to `move`. The following would not work otherwise.\"\"\"\n    instance = m.TestPropRVP()\n    o = instance.rvalue\n    assert o.value == 1\n    os = m.TestPropRVP.static_rvalue\n    assert os.value == 1\n# https://foss.heptapod.net/pypy/pypy/-/issues/2447\n@pytest.mark.xfail(\"env.PYPY\")",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_dynamic_attributes",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_dynamic_attributes():\n    instance = m.DynamicClass()\n    assert not hasattr(instance, \"foo\")\n    assert \"foo\" not in dir(instance)\n    # Dynamically add attribute\n    instance.foo = 42\n    assert hasattr(instance, \"foo\")\n    assert instance.foo == 42\n    assert \"foo\" in dir(instance)\n    # __dict__ should be accessible and replaceable",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_cyclic_gc",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_cyclic_gc():\n    # One object references itself\n    instance = m.DynamicClass()\n    instance.circular_reference = instance\n    cstats = ConstructorStats.get(m.DynamicClass)\n    assert cstats.alive() == 1\n    del instance\n    assert cstats.alive() == 0\n    # Two object reference each other\n    i1 = m.DynamicClass()",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_bad_arg_default",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_bad_arg_default(msg):\n    from pybind11_tests import debug_enabled\n    with pytest.raises(RuntimeError) as excinfo:\n        m.bad_arg_def_named()\n    assert msg(excinfo.value) == (\n        \"arg(): could not convert default argument 'a: UnregisteredType' in function \"\n        \"'should_fail' into a Python object (type not registered yet?)\"\n        if debug_enabled else\n        \"arg(): could not convert default argument into a Python object (type not registered \"\n        \"yet?). Compile in debug mode for more information.\"",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_accepts_none",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_accepts_none(msg):\n    a = m.NoneTester()\n    assert m.no_none1(a) == 42\n    assert m.no_none2(a) == 42\n    assert m.no_none3(a) == 42\n    assert m.no_none4(a) == 42\n    assert m.no_none5(a) == 42\n    assert m.ok_none1(a) == 42\n    assert m.ok_none2(a) == 42\n    assert m.ok_none3(a) == 42",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_str_issue",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_str_issue(msg):\n    \"\"\"#283: __str__ called on uninitialized instance when constructor arguments invalid\"\"\"\n    assert str(m.StrIssue(3)) == \"StrIssue[3]\"\n    with pytest.raises(TypeError) as excinfo:\n        str(m.StrIssue(\"no\", \"such\", \"constructor\"))\n    assert msg(excinfo.value) == \"\"\"\n        __init__(): incompatible constructor arguments. The following argument types are supported:\n            1. m.methods_and_attributes.StrIssue(arg0: int)\n            2. m.methods_and_attributes.StrIssue()\n        Invoked with: 'no', 'such', 'constructor'",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_unregistered_base_implementations",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_unregistered_base_implementations():\n    a = m.RegisteredDerived()\n    a.do_nothing()\n    assert a.rw_value == 42\n    assert a.ro_value == 1.25\n    a.rw_value += 5\n    assert a.sum() == 48.25\n    a.increase_value()\n    assert a.rw_value == 48\n    assert a.ro_value == 1.5",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_ref_qualified",
        "kind": 2,
        "importPath": "pybind11.tests.test_methods_and_attributes",
        "description": "pybind11.tests.test_methods_and_attributes",
        "peekOfCode": "def test_ref_qualified():\n    \"\"\"Tests that explicit lvalue ref-qualified methods can be called just like their\n    non ref-qualified counterparts.\"\"\"\n    r = m.RefQualified()\n    assert r.value == 0\n    r.refQualified(17)\n    assert r.value == 17\n    assert r.constRefQualified(23) == 40",
        "detail": "pybind11.tests.test_methods_and_attributes",
        "documentation": {}
    },
    {
        "label": "test_nested_modules",
        "kind": 2,
        "importPath": "pybind11.tests.test_modules",
        "description": "pybind11.tests.test_modules",
        "peekOfCode": "def test_nested_modules():\n    import pybind11_tests\n    assert pybind11_tests.__name__ == \"pybind11_tests\"\n    assert pybind11_tests.modules.__name__ == \"pybind11_tests.modules\"\n    assert pybind11_tests.modules.subsubmodule.__name__ == \"pybind11_tests.modules.subsubmodule\"\n    assert m.__name__ == \"pybind11_tests.modules\"\n    assert ms.__name__ == \"pybind11_tests.modules.subsubmodule\"\n    assert ms.submodule_func() == \"submodule_func()\"\ndef test_reference_internal():\n    b = ms.B()",
        "detail": "pybind11.tests.test_modules",
        "documentation": {}
    },
    {
        "label": "test_reference_internal",
        "kind": 2,
        "importPath": "pybind11.tests.test_modules",
        "description": "pybind11.tests.test_modules",
        "peekOfCode": "def test_reference_internal():\n    b = ms.B()\n    assert str(b.get_a1()) == \"A[1]\"\n    assert str(b.a1) == \"A[1]\"\n    assert str(b.get_a2()) == \"A[2]\"\n    assert str(b.a2) == \"A[2]\"\n    b.a1 = ms.A(42)\n    b.a2 = ms.A(43)\n    assert str(b.get_a1()) == \"A[42]\"\n    assert str(b.a1) == \"A[42]\"",
        "detail": "pybind11.tests.test_modules",
        "documentation": {}
    },
    {
        "label": "test_importing",
        "kind": 2,
        "importPath": "pybind11.tests.test_modules",
        "description": "pybind11.tests.test_modules",
        "peekOfCode": "def test_importing():\n    from pybind11_tests.modules import OD\n    from collections import OrderedDict\n    assert OD is OrderedDict\n    assert str(OD([(1, 'a'), (2, 'b')])) == \"OrderedDict([(1, 'a'), (2, 'b')])\"\ndef test_pydoc():\n    \"\"\"Pydoc needs to be able to provide help() for everything inside a pybind11 module\"\"\"\n    import pybind11_tests\n    import pydoc\n    assert pybind11_tests.__name__ == \"pybind11_tests\"",
        "detail": "pybind11.tests.test_modules",
        "documentation": {}
    },
    {
        "label": "test_pydoc",
        "kind": 2,
        "importPath": "pybind11.tests.test_modules",
        "description": "pybind11.tests.test_modules",
        "peekOfCode": "def test_pydoc():\n    \"\"\"Pydoc needs to be able to provide help() for everything inside a pybind11 module\"\"\"\n    import pybind11_tests\n    import pydoc\n    assert pybind11_tests.__name__ == \"pybind11_tests\"\n    assert pybind11_tests.__doc__ == \"pybind11 test module\"\n    assert pydoc.text.docmodule(pybind11_tests)\ndef test_duplicate_registration():\n    \"\"\"Registering two things with the same name\"\"\"\n    assert m.duplicate_registration() == []",
        "detail": "pybind11.tests.test_modules",
        "documentation": {}
    },
    {
        "label": "test_duplicate_registration",
        "kind": 2,
        "importPath": "pybind11.tests.test_modules",
        "description": "pybind11.tests.test_modules",
        "peekOfCode": "def test_duplicate_registration():\n    \"\"\"Registering two things with the same name\"\"\"\n    assert m.duplicate_registration() == []",
        "detail": "pybind11.tests.test_modules",
        "documentation": {}
    },
    {
        "label": "test_multiple_inheritance_cpp",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_multiple_inheritance_cpp():\n    mt = m.MIType(3, 4)\n    assert mt.foo() == 3\n    assert mt.bar() == 4\n@pytest.mark.skipif(\"env.PYPY and env.PY2\")\n@pytest.mark.xfail(\"env.PYPY and not env.PY2\")\ndef test_multiple_inheritance_mix1():\n    class Base1:\n        def __init__(self, i):\n            self.i = i",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_multiple_inheritance_mix1",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_multiple_inheritance_mix1():\n    class Base1:\n        def __init__(self, i):\n            self.i = i\n        def foo(self):\n            return self.i\n    class MITypePy(Base1, m.Base2):\n        def __init__(self, i, j):\n            Base1.__init__(self, i)\n            m.Base2.__init__(self, j)",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_multiple_inheritance_mix2",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_multiple_inheritance_mix2():\n    class Base2:\n        def __init__(self, i):\n            self.i = i\n        def bar(self):\n            return self.i\n    class MITypePy(m.Base1, Base2):\n        def __init__(self, i, j):\n            m.Base1.__init__(self, i)\n            Base2.__init__(self, j)",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_multiple_inheritance_python",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_multiple_inheritance_python():\n    class MI1(m.Base1, m.Base2):\n        def __init__(self, i, j):\n            m.Base1.__init__(self, i)\n            m.Base2.__init__(self, j)\n    class B1(object):\n        def v(self):\n            return 1\n    class MI2(B1, m.Base1, m.Base2):\n        def __init__(self, i, j):",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_multiple_inheritance_python_many_bases",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_multiple_inheritance_python_many_bases():\n    class MIMany14(m.BaseN1, m.BaseN2, m.BaseN3, m.BaseN4):\n        def __init__(self):\n            m.BaseN1.__init__(self, 1)\n            m.BaseN2.__init__(self, 2)\n            m.BaseN3.__init__(self, 3)\n            m.BaseN4.__init__(self, 4)\n    class MIMany58(m.BaseN5, m.BaseN6, m.BaseN7, m.BaseN8):\n        def __init__(self):\n            m.BaseN5.__init__(self, 5)",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_multiple_inheritance_virtbase",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_multiple_inheritance_virtbase():\n    class MITypePy(m.Base12a):\n        def __init__(self, i, j):\n            m.Base12a.__init__(self, i, j)\n    mt = MITypePy(3, 4)\n    assert mt.bar() == 4\n    assert m.bar_base2a(mt) == 4\n    assert m.bar_base2a_sharedptr(mt) == 4\ndef test_mi_static_properties():\n    \"\"\"Mixing bases with and without static properties should be possible",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_mi_static_properties",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_mi_static_properties():\n    \"\"\"Mixing bases with and without static properties should be possible\n     and the result should be independent of base definition order\"\"\"\n    for d in (m.VanillaStaticMix1(), m.VanillaStaticMix2()):\n        assert d.vanilla() == \"Vanilla\"\n        assert d.static_func1() == \"WithStatic1\"\n        assert d.static_func2() == \"WithStatic2\"\n        assert d.static_func() == d.__class__.__name__\n        m.WithStatic1.static_value1 = 1\n        m.WithStatic2.static_value2 = 2",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_mi_dynamic_attributes",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_mi_dynamic_attributes():\n    \"\"\"Mixing bases with and without dynamic attribute support\"\"\"\n    for d in (m.VanillaDictMix1(), m.VanillaDictMix2()):\n        d.dynamic = 1\n        assert d.dynamic == 1\ndef test_mi_unaligned_base():\n    \"\"\"Returning an offset (non-first MI) base class pointer should recognize the instance\"\"\"\n    n_inst = ConstructorStats.detail_reg_inst()\n    c = m.I801C()\n    d = m.I801D()",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_mi_unaligned_base",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_mi_unaligned_base():\n    \"\"\"Returning an offset (non-first MI) base class pointer should recognize the instance\"\"\"\n    n_inst = ConstructorStats.detail_reg_inst()\n    c = m.I801C()\n    d = m.I801D()\n    # + 4 below because we have the two instances, and each instance has offset base I801B2\n    assert ConstructorStats.detail_reg_inst() == n_inst + 4\n    b1c = m.i801b1_c(c)\n    assert b1c is c\n    b2c = m.i801b2_c(c)",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_mi_base_return",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_mi_base_return():\n    \"\"\"Tests returning an offset (non-first MI) base class pointer to a derived instance\"\"\"\n    n_inst = ConstructorStats.detail_reg_inst()\n    c1 = m.i801c_b1()\n    assert type(c1) is m.I801C\n    assert c1.a == 1\n    assert c1.b == 2\n    d1 = m.i801d_b1()\n    assert type(d1) is m.I801D\n    assert d1.a == 1",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_diamond_inheritance",
        "kind": 2,
        "importPath": "pybind11.tests.test_multiple_inheritance",
        "description": "pybind11.tests.test_multiple_inheritance",
        "peekOfCode": "def test_diamond_inheritance():\n    \"\"\"Tests that diamond inheritance works as expected (issue #959)\"\"\"\n    # Issue #959: this shouldn't segfault:\n    d = m.D()\n    # Make sure all the various distinct pointers are all recognized as registered instances:\n    assert d is d.c0()\n    assert d is d.c1()\n    assert d is d.b()\n    assert d is d.c0().b()\n    assert d is d.c1().b()",
        "detail": "pybind11.tests.test_multiple_inheritance",
        "documentation": {}
    },
    {
        "label": "test_dtypes",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_dtypes():\n    # See issue #1328.\n    # - Platform-dependent sizes.\n    for size_check in m.get_platform_dtype_size_checks():\n        print(size_check)\n        assert size_check.size_cpp == size_check.size_numpy, size_check\n    # - Concrete sizes.\n    for check in m.get_concrete_dtype_checks():\n        print(check)\n        assert check.numpy == check.pybind11, check",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def arr():\n    return np.array([[1, 2, 3], [4, 5, 6]], '=u2')\ndef test_array_attributes():\n    a = np.array(0, 'f8')\n    assert m.ndim(a) == 0\n    assert all(m.shape(a) == [])\n    assert all(m.strides(a) == [])\n    with pytest.raises(IndexError) as excinfo:\n        m.shape(a, 0)\n    assert str(excinfo.value) == 'invalid axis: 0 (ndim = 0)'",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_array_attributes",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_array_attributes():\n    a = np.array(0, 'f8')\n    assert m.ndim(a) == 0\n    assert all(m.shape(a) == [])\n    assert all(m.strides(a) == [])\n    with pytest.raises(IndexError) as excinfo:\n        m.shape(a, 0)\n    assert str(excinfo.value) == 'invalid axis: 0 (ndim = 0)'\n    with pytest.raises(IndexError) as excinfo:\n        m.strides(a, 0)",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_index_offset",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_index_offset(arr, args, ret):\n    assert m.index_at(arr, *args) == ret\n    assert m.index_at_t(arr, *args) == ret\n    assert m.offset_at(arr, *args) == ret * arr.dtype.itemsize\n    assert m.offset_at_t(arr, *args) == ret * arr.dtype.itemsize\ndef test_dim_check_fail(arr):\n    for func in (m.index_at, m.index_at_t, m.offset_at, m.offset_at_t, m.data, m.data_t,\n                 m.mutate_data, m.mutate_data_t):\n        with pytest.raises(IndexError) as excinfo:\n            func(arr, 1, 2, 3)",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_dim_check_fail",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_dim_check_fail(arr):\n    for func in (m.index_at, m.index_at_t, m.offset_at, m.offset_at_t, m.data, m.data_t,\n                 m.mutate_data, m.mutate_data_t):\n        with pytest.raises(IndexError) as excinfo:\n            func(arr, 1, 2, 3)\n        assert str(excinfo.value) == 'too many indices for an array: 3 (ndim = 2)'\n@pytest.mark.parametrize('args, ret',\n                         [([], [1, 2, 3, 4, 5, 6]),\n                          ([1], [4, 5, 6]),\n                          ([0, 1], [2, 3, 4, 5, 6]),",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_data",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_data(arr, args, ret):\n    from sys import byteorder\n    assert all(m.data_t(arr, *args) == ret)\n    assert all(m.data(arr, *args)[(0 if byteorder == 'little' else 1)::2] == ret)\n    assert all(m.data(arr, *args)[(1 if byteorder == 'little' else 0)::2] == 0)\n@pytest.mark.parametrize('dim', [0, 1, 3])\ndef test_at_fail(arr, dim):\n    for func in m.at_t, m.mutate_at_t:\n        with pytest.raises(IndexError) as excinfo:\n            func(arr, *([0] * dim))",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_at_fail",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_at_fail(arr, dim):\n    for func in m.at_t, m.mutate_at_t:\n        with pytest.raises(IndexError) as excinfo:\n            func(arr, *([0] * dim))\n        assert str(excinfo.value) == 'index dimension mismatch: {} (ndim = 2)'.format(dim)\ndef test_at(arr):\n    assert m.at_t(arr, 0, 2) == 3\n    assert m.at_t(arr, 1, 0) == 4\n    assert all(m.mutate_at_t(arr, 0, 2).ravel() == [1, 2, 4, 4, 5, 6])\n    assert all(m.mutate_at_t(arr, 1, 0).ravel() == [1, 2, 4, 5, 5, 6])",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_at",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_at(arr):\n    assert m.at_t(arr, 0, 2) == 3\n    assert m.at_t(arr, 1, 0) == 4\n    assert all(m.mutate_at_t(arr, 0, 2).ravel() == [1, 2, 4, 4, 5, 6])\n    assert all(m.mutate_at_t(arr, 1, 0).ravel() == [1, 2, 4, 5, 5, 6])\ndef test_mutate_readonly(arr):\n    arr.flags.writeable = False\n    for func, args in (m.mutate_data, ()), (m.mutate_data_t, ()), (m.mutate_at_t, (0, 0)):\n        with pytest.raises(ValueError) as excinfo:\n            func(arr, *args)",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_mutate_readonly",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_mutate_readonly(arr):\n    arr.flags.writeable = False\n    for func, args in (m.mutate_data, ()), (m.mutate_data_t, ()), (m.mutate_at_t, (0, 0)):\n        with pytest.raises(ValueError) as excinfo:\n            func(arr, *args)\n        assert str(excinfo.value) == 'array is not writeable'\ndef test_mutate_data(arr):\n    assert all(m.mutate_data(arr).ravel() == [2, 4, 6, 8, 10, 12])\n    assert all(m.mutate_data(arr).ravel() == [4, 8, 12, 16, 20, 24])\n    assert all(m.mutate_data(arr, 1).ravel() == [4, 8, 12, 32, 40, 48])",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_mutate_data",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_mutate_data(arr):\n    assert all(m.mutate_data(arr).ravel() == [2, 4, 6, 8, 10, 12])\n    assert all(m.mutate_data(arr).ravel() == [4, 8, 12, 16, 20, 24])\n    assert all(m.mutate_data(arr, 1).ravel() == [4, 8, 12, 32, 40, 48])\n    assert all(m.mutate_data(arr, 0, 1).ravel() == [4, 16, 24, 64, 80, 96])\n    assert all(m.mutate_data(arr, 1, 2).ravel() == [4, 16, 24, 64, 80, 192])\n    assert all(m.mutate_data_t(arr).ravel() == [5, 17, 25, 65, 81, 193])\n    assert all(m.mutate_data_t(arr).ravel() == [6, 18, 26, 66, 82, 194])\n    assert all(m.mutate_data_t(arr, 1).ravel() == [6, 18, 26, 67, 83, 195])\n    assert all(m.mutate_data_t(arr, 0, 1).ravel() == [6, 19, 27, 68, 84, 196])",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_bounds_check",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_bounds_check(arr):\n    for func in (m.index_at, m.index_at_t, m.data, m.data_t,\n                 m.mutate_data, m.mutate_data_t, m.at_t, m.mutate_at_t):\n        with pytest.raises(IndexError) as excinfo:\n            func(arr, 2, 0)\n        assert str(excinfo.value) == 'index 2 is out of bounds for axis 0 with size 2'\n        with pytest.raises(IndexError) as excinfo:\n            func(arr, 0, 4)\n        assert str(excinfo.value) == 'index 4 is out of bounds for axis 1 with size 3'\ndef test_make_c_f_array():",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_make_c_f_array",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_make_c_f_array():\n    assert m.make_c_array().flags.c_contiguous\n    assert not m.make_c_array().flags.f_contiguous\n    assert m.make_f_array().flags.f_contiguous\n    assert not m.make_f_array().flags.c_contiguous\ndef test_make_empty_shaped_array():\n    m.make_empty_shaped_array()\n    # empty shape means numpy scalar, PEP 3118\n    assert m.scalar_int().ndim == 0\n    assert m.scalar_int().shape == ()",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_make_empty_shaped_array",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_make_empty_shaped_array():\n    m.make_empty_shaped_array()\n    # empty shape means numpy scalar, PEP 3118\n    assert m.scalar_int().ndim == 0\n    assert m.scalar_int().shape == ()\n    assert m.scalar_int() == 42\ndef test_wrap():\n    def assert_references(a, b, base=None):\n        from distutils.version import LooseVersion\n        if base is None:",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_wrap",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_wrap():\n    def assert_references(a, b, base=None):\n        from distutils.version import LooseVersion\n        if base is None:\n            base = a\n        assert a is not b\n        assert a.__array_interface__['data'][0] == b.__array_interface__['data'][0]\n        assert a.shape == b.shape\n        assert a.strides == b.strides\n        assert a.flags.c_contiguous == b.flags.c_contiguous",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_numpy_view",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_numpy_view(capture):\n    with capture:\n        ac = m.ArrayClass()\n        ac_view_1 = ac.numpy_view()\n        ac_view_2 = ac.numpy_view()\n        assert np.all(ac_view_1 == np.array([1, 2], dtype=np.int32))\n        del ac\n        pytest.gc_collect()\n    assert capture == \"\"\"\n        ArrayClass()",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_cast_numpy_int64_to_uint64",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_cast_numpy_int64_to_uint64():\n    m.function_taking_uint64(123)\n    m.function_taking_uint64(np.uint64(123))\ndef test_isinstance():\n    assert m.isinstance_untyped(np.array([1, 2, 3]), \"not an array\")\n    assert m.isinstance_typed(np.array([1.0, 2.0, 3.0]))\ndef test_constructors():\n    defaults = m.default_constructors()\n    for a in defaults.values():\n        assert a.size == 0",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_isinstance",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_isinstance():\n    assert m.isinstance_untyped(np.array([1, 2, 3]), \"not an array\")\n    assert m.isinstance_typed(np.array([1.0, 2.0, 3.0]))\ndef test_constructors():\n    defaults = m.default_constructors()\n    for a in defaults.values():\n        assert a.size == 0\n    assert defaults[\"array\"].dtype == np.array([]).dtype\n    assert defaults[\"array_t<int32>\"].dtype == np.int32\n    assert defaults[\"array_t<double>\"].dtype == np.float64",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_constructors",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_constructors():\n    defaults = m.default_constructors()\n    for a in defaults.values():\n        assert a.size == 0\n    assert defaults[\"array\"].dtype == np.array([]).dtype\n    assert defaults[\"array_t<int32>\"].dtype == np.int32\n    assert defaults[\"array_t<double>\"].dtype == np.float64\n    results = m.converting_constructors([1, 2, 3])\n    for a in results.values():\n        np.testing.assert_array_equal(a, [1, 2, 3])",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_overload_resolution",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_overload_resolution(msg):\n    # Exact overload matches:\n    assert m.overloaded(np.array([1], dtype='float64')) == 'double'\n    assert m.overloaded(np.array([1], dtype='float32')) == 'float'\n    assert m.overloaded(np.array([1], dtype='ushort')) == 'unsigned short'\n    assert m.overloaded(np.array([1], dtype='intc')) == 'int'\n    assert m.overloaded(np.array([1], dtype='longlong')) == 'long long'\n    assert m.overloaded(np.array([1], dtype='complex')) == 'double complex'\n    assert m.overloaded(np.array([1], dtype='csingle')) == 'float complex'\n    # No exact match, should call first convertible version:",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_greedy_string_overload",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_greedy_string_overload():\n    \"\"\"Tests fix for #685 - ndarray shouldn't go to std::string overload\"\"\"\n    assert m.issue685(\"abc\") == \"string\"\n    assert m.issue685(np.array([97, 98, 99], dtype='b')) == \"array\"\n    assert m.issue685(123) == \"other\"\ndef test_array_unchecked_fixed_dims(msg):\n    z1 = np.array([[1, 2], [3, 4]], dtype='float64')\n    m.proxy_add2(z1, 10)\n    assert np.all(z1 == [[11, 12], [13, 14]])\n    with pytest.raises(ValueError) as excinfo:",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_array_unchecked_fixed_dims",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_array_unchecked_fixed_dims(msg):\n    z1 = np.array([[1, 2], [3, 4]], dtype='float64')\n    m.proxy_add2(z1, 10)\n    assert np.all(z1 == [[11, 12], [13, 14]])\n    with pytest.raises(ValueError) as excinfo:\n        m.proxy_add2(np.array([1., 2, 3]), 5.0)\n    assert msg(excinfo.value) == \"array has incorrect number of dimensions: 1; expected 2\"\n    expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype='int')\n    assert np.all(m.proxy_init3(3.0) == expect_c)\n    expect_f = np.transpose(expect_c)",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_array_unchecked_dyn_dims",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_array_unchecked_dyn_dims(msg):\n    z1 = np.array([[1, 2], [3, 4]], dtype='float64')\n    m.proxy_add2_dyn(z1, 10)\n    assert np.all(z1 == [[11, 12], [13, 14]])\n    expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype='int')\n    assert np.all(m.proxy_init3_dyn(3.0) == expect_c)\n    assert m.proxy_auxiliaries2_dyn(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]\n    assert m.proxy_auxiliaries2_dyn(z1) == m.array_auxiliaries2(z1)\ndef test_array_failure():\n    with pytest.raises(ValueError) as excinfo:",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_array_failure",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_array_failure():\n    with pytest.raises(ValueError) as excinfo:\n        m.array_fail_test()\n    assert str(excinfo.value) == 'cannot create a pybind11::array from a nullptr'\n    with pytest.raises(ValueError) as excinfo:\n        m.array_t_fail_test()\n    assert str(excinfo.value) == 'cannot create a pybind11::array_t from a nullptr'\n    with pytest.raises(ValueError) as excinfo:\n        m.array_fail_test_negative_size()\n    assert str(excinfo.value) == 'negative dimensions are not allowed'",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_initializer_list",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_initializer_list():\n    assert m.array_initializer_list1().shape == (1,)\n    assert m.array_initializer_list2().shape == (1, 2)\n    assert m.array_initializer_list3().shape == (1, 2, 3)\n    assert m.array_initializer_list4().shape == (1, 2, 3, 4)\ndef test_array_resize(msg):\n    a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype='float64')\n    m.array_reshape2(a)\n    assert(a.size == 9)\n    assert(np.all(a == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]))",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_array_resize",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_array_resize(msg):\n    a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype='float64')\n    m.array_reshape2(a)\n    assert(a.size == 9)\n    assert(np.all(a == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n    # total size change should succced with refcheck off\n    m.array_resize3(a, 4, False)\n    assert(a.size == 64)\n    # ... and fail with refcheck on\n    try:",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_array_create_and_resize",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_array_create_and_resize(msg):\n    a = m.create_and_resize(2)\n    assert(a.size == 4)\n    assert(np.all(a == 42.))\ndef test_index_using_ellipsis():\n    a = m.index_using_ellipsis(np.zeros((5, 6, 7)))\n    assert a.shape == (6,)\n@pytest.mark.xfail(\"env.PYPY\")\ndef test_dtype_refcount_leak():\n    from sys import getrefcount",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_index_using_ellipsis",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_index_using_ellipsis():\n    a = m.index_using_ellipsis(np.zeros((5, 6, 7)))\n    assert a.shape == (6,)\n@pytest.mark.xfail(\"env.PYPY\")\ndef test_dtype_refcount_leak():\n    from sys import getrefcount\n    dtype = np.dtype(np.float_)\n    a = np.array([1], dtype=dtype)\n    before = getrefcount(dtype)\n    m.ndim(a)",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "test_dtype_refcount_leak",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "def test_dtype_refcount_leak():\n    from sys import getrefcount\n    dtype = np.dtype(np.float_)\n    a = np.array([1], dtype=dtype)\n    before = getrefcount(dtype)\n    m.ndim(a)\n    after = getrefcount(dtype)\n    assert after == before",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "np",
        "kind": 5,
        "importPath": "pybind11.tests.test_numpy_array",
        "description": "pybind11.tests.test_numpy_array",
        "peekOfCode": "np = pytest.importorskip(\"numpy\")\ndef test_dtypes():\n    # See issue #1328.\n    # - Platform-dependent sizes.\n    for size_check in m.get_platform_dtype_size_checks():\n        print(size_check)\n        assert size_check.size_cpp == size_check.size_numpy, size_check\n    # - Concrete sizes.\n    for check in m.get_concrete_dtype_checks():\n        print(check)",
        "detail": "pybind11.tests.test_numpy_array",
        "documentation": {}
    },
    {
        "label": "simple_dtype",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def simple_dtype():\n    ld = np.dtype('longdouble')\n    return np.dtype({'names': ['bool_', 'uint_', 'float_', 'ldbl_'],\n                     'formats': ['?', 'u4', 'f4', 'f{}'.format(ld.itemsize)],\n                     'offsets': [0, 4, 8, (16 if ld.alignment > 4 else 12)]})\n@pytest.fixture(scope='module')\ndef packed_dtype():\n    return np.dtype([('bool_', '?'), ('uint_', 'u4'), ('float_', 'f4'), ('ldbl_', 'g')])\ndef dt_fmt():\n    from sys import byteorder",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "packed_dtype",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def packed_dtype():\n    return np.dtype([('bool_', '?'), ('uint_', 'u4'), ('float_', 'f4'), ('ldbl_', 'g')])\ndef dt_fmt():\n    from sys import byteorder\n    e = '<' if byteorder == 'little' else '>'\n    return (\"{{'names':['bool_','uint_','float_','ldbl_'],\"\n            \" 'formats':['?','\" + e + \"u4','\" + e + \"f4','\" + e + \"f{}'],\"\n            \" 'offsets':[0,4,8,{}], 'itemsize':{}}}\")\ndef simple_dtype_fmt():\n    ld = np.dtype('longdouble')",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "dt_fmt",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def dt_fmt():\n    from sys import byteorder\n    e = '<' if byteorder == 'little' else '>'\n    return (\"{{'names':['bool_','uint_','float_','ldbl_'],\"\n            \" 'formats':['?','\" + e + \"u4','\" + e + \"f4','\" + e + \"f{}'],\"\n            \" 'offsets':[0,4,8,{}], 'itemsize':{}}}\")\ndef simple_dtype_fmt():\n    ld = np.dtype('longdouble')\n    simple_ld_off = 12 + 4 * (ld.alignment > 4)\n    return dt_fmt().format(ld.itemsize, simple_ld_off, simple_ld_off + ld.itemsize)",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "simple_dtype_fmt",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def simple_dtype_fmt():\n    ld = np.dtype('longdouble')\n    simple_ld_off = 12 + 4 * (ld.alignment > 4)\n    return dt_fmt().format(ld.itemsize, simple_ld_off, simple_ld_off + ld.itemsize)\ndef packed_dtype_fmt():\n    from sys import byteorder\n    return \"[('bool_', '?'), ('uint_', '{e}u4'), ('float_', '{e}f4'), ('ldbl_', '{e}f{}')]\".format(\n        np.dtype('longdouble').itemsize, e='<' if byteorder == 'little' else '>')\ndef partial_ld_offset():\n    return 12 + 4 * (np.dtype('uint64').alignment > 4) + 8 + 8 * (",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "packed_dtype_fmt",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def packed_dtype_fmt():\n    from sys import byteorder\n    return \"[('bool_', '?'), ('uint_', '{e}u4'), ('float_', '{e}f4'), ('ldbl_', '{e}f{}')]\".format(\n        np.dtype('longdouble').itemsize, e='<' if byteorder == 'little' else '>')\ndef partial_ld_offset():\n    return 12 + 4 * (np.dtype('uint64').alignment > 4) + 8 + 8 * (\n        np.dtype('longdouble').alignment > 8)\ndef partial_dtype_fmt():\n    ld = np.dtype('longdouble')\n    partial_ld_off = partial_ld_offset()",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "partial_ld_offset",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def partial_ld_offset():\n    return 12 + 4 * (np.dtype('uint64').alignment > 4) + 8 + 8 * (\n        np.dtype('longdouble').alignment > 8)\ndef partial_dtype_fmt():\n    ld = np.dtype('longdouble')\n    partial_ld_off = partial_ld_offset()\n    return dt_fmt().format(ld.itemsize, partial_ld_off, partial_ld_off + ld.itemsize)\ndef partial_nested_fmt():\n    ld = np.dtype('longdouble')\n    partial_nested_off = 8 + 8 * (ld.alignment > 8)",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "partial_dtype_fmt",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def partial_dtype_fmt():\n    ld = np.dtype('longdouble')\n    partial_ld_off = partial_ld_offset()\n    return dt_fmt().format(ld.itemsize, partial_ld_off, partial_ld_off + ld.itemsize)\ndef partial_nested_fmt():\n    ld = np.dtype('longdouble')\n    partial_nested_off = 8 + 8 * (ld.alignment > 8)\n    partial_ld_off = partial_ld_offset()\n    partial_nested_size = partial_nested_off * 2 + partial_ld_off + ld.itemsize\n    return \"{{'names':['a'], 'formats':[{}], 'offsets':[{}], 'itemsize':{}}}\".format(",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "partial_nested_fmt",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def partial_nested_fmt():\n    ld = np.dtype('longdouble')\n    partial_nested_off = 8 + 8 * (ld.alignment > 8)\n    partial_ld_off = partial_ld_offset()\n    partial_nested_size = partial_nested_off * 2 + partial_ld_off + ld.itemsize\n    return \"{{'names':['a'], 'formats':[{}], 'offsets':[{}], 'itemsize':{}}}\".format(\n        partial_dtype_fmt(), partial_nested_off, partial_nested_size)\ndef assert_equal(actual, expected_data, expected_dtype):\n    np.testing.assert_equal(actual, np.array(expected_data, dtype=expected_dtype))\ndef test_format_descriptors():",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "assert_equal",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def assert_equal(actual, expected_data, expected_dtype):\n    np.testing.assert_equal(actual, np.array(expected_data, dtype=expected_dtype))\ndef test_format_descriptors():\n    with pytest.raises(RuntimeError) as excinfo:\n        m.get_format_unbound()\n    assert re.match('^NumPy type info missing for .*UnboundStruct.*$', str(excinfo.value))\n    ld = np.dtype('longdouble')\n    ldbl_fmt = ('4x' if ld.alignment > 4 else '') + ld.char\n    ss_fmt = \"^T{?:bool_:3xI:uint_:f:float_:\" + ldbl_fmt + \":ldbl_:}\"\n    dbl = np.dtype('double')",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_format_descriptors",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_format_descriptors():\n    with pytest.raises(RuntimeError) as excinfo:\n        m.get_format_unbound()\n    assert re.match('^NumPy type info missing for .*UnboundStruct.*$', str(excinfo.value))\n    ld = np.dtype('longdouble')\n    ldbl_fmt = ('4x' if ld.alignment > 4 else '') + ld.char\n    ss_fmt = \"^T{?:bool_:3xI:uint_:f:float_:\" + ldbl_fmt + \":ldbl_:}\"\n    dbl = np.dtype('double')\n    partial_fmt = (\"^T{?:bool_:3xI:uint_:f:float_:\" +\n                   str(4 * (dbl.alignment > 4) + dbl.itemsize + 8 * (ld.alignment > 8)) +",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_dtype",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_dtype(simple_dtype):\n    from sys import byteorder\n    e = '<' if byteorder == 'little' else '>'\n    assert m.print_dtypes() == [\n        simple_dtype_fmt(),\n        packed_dtype_fmt(),\n        \"[('a', {}), ('b', {})]\".format(simple_dtype_fmt(), packed_dtype_fmt()),\n        partial_dtype_fmt(),\n        partial_nested_fmt(),\n        \"[('a', 'S3'), ('b', 'S3')]\",",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_recarray",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_recarray(simple_dtype, packed_dtype):\n    elements = [(False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)]\n    for func, dtype in [(m.create_rec_simple, simple_dtype), (m.create_rec_packed, packed_dtype)]:\n        arr = func(0)\n        assert arr.dtype == dtype\n        assert_equal(arr, [], simple_dtype)\n        assert_equal(arr, [], packed_dtype)\n        arr = func(3)\n        assert arr.dtype == dtype\n        assert_equal(arr, elements, simple_dtype)",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_array_constructors",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_array_constructors():\n    data = np.arange(1, 7, dtype='int32')\n    for i in range(8):\n        np.testing.assert_array_equal(m.test_array_ctors(10 + i), data.reshape((3, 2)))\n        np.testing.assert_array_equal(m.test_array_ctors(20 + i), data.reshape((3, 2)))\n    for i in range(5):\n        np.testing.assert_array_equal(m.test_array_ctors(30 + i), data)\n        np.testing.assert_array_equal(m.test_array_ctors(40 + i), data)\ndef test_string_array():\n    arr = m.create_string_array(True)",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_string_array",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_string_array():\n    arr = m.create_string_array(True)\n    assert str(arr.dtype) == \"[('a', 'S3'), ('b', 'S3')]\"\n    assert m.print_string_array(arr) == [\n        \"a='',b=''\",\n        \"a='a',b='a'\",\n        \"a='ab',b='ab'\",\n        \"a='abc',b='abc'\"\n    ]\n    dtype = arr.dtype",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_array_array",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_array_array():\n    from sys import byteorder\n    e = '<' if byteorder == 'little' else '>'\n    arr = m.create_array_array(3)\n    assert str(arr.dtype) == (\n        \"{{'names':['a','b','c','d'], \" +\n        \"'formats':[('S4', (3,)),('\" + e + \"i4', (2,)),('u1', (3,)),('{e}f4', (4, 2))], \" +\n        \"'offsets':[0,12,20,24], 'itemsize':56}}\").format(e=e)\n    assert m.print_array_array(arr) == [\n        \"a={{A,B,C,D},{K,L,M,N},{U,V,W,X}},b={0,1},\" +",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_enum_array",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_enum_array():\n    from sys import byteorder\n    e = '<' if byteorder == 'little' else '>'\n    arr = m.create_enum_array(3)\n    dtype = arr.dtype\n    assert dtype == np.dtype([('e1', e + 'i8'), ('e2', 'u1')])\n    assert m.print_enum_array(arr) == [\n        \"e1=A,e2=X\",\n        \"e1=B,e2=Y\",\n        \"e1=A,e2=X\"",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_complex_array",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_complex_array():\n    from sys import byteorder\n    e = '<' if byteorder == 'little' else '>'\n    arr = m.create_complex_array(3)\n    dtype = arr.dtype\n    assert dtype == np.dtype([('cflt', e + 'c8'), ('cdbl', e + 'c16')])\n    assert m.print_complex_array(arr) == [\n        \"c:(0,0.25),(0.5,0.75)\",\n        \"c:(1,1.25),(1.5,1.75)\",\n        \"c:(2,2.25),(2.5,2.75)\"",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_signature",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_signature(doc):\n    assert doc(m.create_rec_nested) == \\\n        \"create_rec_nested(arg0: int) -> numpy.ndarray[NestedStruct]\"\ndef test_scalar_conversion():\n    n = 3\n    arrays = [m.create_rec_simple(n), m.create_rec_packed(n),\n              m.create_rec_nested(n), m.create_enum_array(n)]\n    funcs = [m.f_simple, m.f_packed, m.f_nested]\n    for i, func in enumerate(funcs):\n        for j, arr in enumerate(arrays):",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_scalar_conversion",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_scalar_conversion():\n    n = 3\n    arrays = [m.create_rec_simple(n), m.create_rec_packed(n),\n              m.create_rec_nested(n), m.create_enum_array(n)]\n    funcs = [m.f_simple, m.f_packed, m.f_nested]\n    for i, func in enumerate(funcs):\n        for j, arr in enumerate(arrays):\n            if i == j and i < 2:\n                assert [func(arr[k]) for k in range(n)] == [k * 10 for k in range(n)]\n            else:",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_register_dtype",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_register_dtype():\n    with pytest.raises(RuntimeError) as excinfo:\n        m.register_dtype()\n    assert 'dtype is already registered' in str(excinfo.value)\n@pytest.mark.xfail(\"env.PYPY\")\ndef test_str_leak():\n    from sys import getrefcount\n    fmt = \"f4\"\n    pytest.gc_collect()\n    start = getrefcount(fmt)",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_str_leak",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_str_leak():\n    from sys import getrefcount\n    fmt = \"f4\"\n    pytest.gc_collect()\n    start = getrefcount(fmt)\n    d = m.dtype_wrapper(fmt)\n    assert d is np.dtype(\"f4\")\n    del d\n    pytest.gc_collect()\n    assert getrefcount(fmt) == start",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_compare_buffer_info",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "def test_compare_buffer_info():\n    assert all(m.compare_buffer_info())",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "np",
        "kind": 5,
        "importPath": "pybind11.tests.test_numpy_dtypes",
        "description": "pybind11.tests.test_numpy_dtypes",
        "peekOfCode": "np = pytest.importorskip(\"numpy\")\n@pytest.fixture(scope='module')\ndef simple_dtype():\n    ld = np.dtype('longdouble')\n    return np.dtype({'names': ['bool_', 'uint_', 'float_', 'ldbl_'],\n                     'formats': ['?', 'u4', 'f4', 'f{}'.format(ld.itemsize)],\n                     'offsets': [0, 4, 8, (16 if ld.alignment > 4 else 12)]})\n@pytest.fixture(scope='module')\ndef packed_dtype():\n    return np.dtype([('bool_', '?'), ('uint_', 'u4'), ('float_', 'f4'), ('ldbl_', 'g')])",
        "detail": "pybind11.tests.test_numpy_dtypes",
        "documentation": {}
    },
    {
        "label": "test_vectorize",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_vectorize",
        "description": "pybind11.tests.test_numpy_vectorize",
        "peekOfCode": "def test_vectorize(capture):\n    assert np.isclose(m.vectorized_func3(np.array(3 + 7j)), [6 + 14j])\n    for f in [m.vectorized_func, m.vectorized_func2]:\n        with capture:\n            assert np.isclose(f(1, 2, 3), 6)\n        assert capture == \"my_func(x:int=1, y:float=2, z:float=3)\"\n        with capture:\n            assert np.isclose(f(np.array(1), np.array(2), 3), 6)\n        assert capture == \"my_func(x:int=1, y:float=2, z:float=3)\"\n        with capture:",
        "detail": "pybind11.tests.test_numpy_vectorize",
        "documentation": {}
    },
    {
        "label": "test_type_selection",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_vectorize",
        "description": "pybind11.tests.test_numpy_vectorize",
        "peekOfCode": "def test_type_selection():\n    assert m.selective_func(np.array([1], dtype=np.int32)) == \"Int branch taken.\"\n    assert m.selective_func(np.array([1.0], dtype=np.float32)) == \"Float branch taken.\"\n    assert m.selective_func(np.array([1.0j], dtype=np.complex64)) == \"Complex float branch taken.\"\ndef test_docs(doc):\n    assert doc(m.vectorized_func) == \"\"\"\n        vectorized_func(arg0: numpy.ndarray[numpy.int32], arg1: numpy.ndarray[numpy.float32], arg2: numpy.ndarray[numpy.float64]) -> object\n    \"\"\"  # noqa: E501 line too long\ndef test_trivial_broadcasting():\n    trivial, vectorized_is_trivial = m.trivial, m.vectorized_is_trivial",
        "detail": "pybind11.tests.test_numpy_vectorize",
        "documentation": {}
    },
    {
        "label": "test_docs",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_vectorize",
        "description": "pybind11.tests.test_numpy_vectorize",
        "peekOfCode": "def test_docs(doc):\n    assert doc(m.vectorized_func) == \"\"\"\n        vectorized_func(arg0: numpy.ndarray[numpy.int32], arg1: numpy.ndarray[numpy.float32], arg2: numpy.ndarray[numpy.float64]) -> object\n    \"\"\"  # noqa: E501 line too long\ndef test_trivial_broadcasting():\n    trivial, vectorized_is_trivial = m.trivial, m.vectorized_is_trivial\n    assert vectorized_is_trivial(1, 2, 3) == trivial.c_trivial\n    assert vectorized_is_trivial(np.array(1), np.array(2), 3) == trivial.c_trivial\n    assert vectorized_is_trivial(np.array([1, 3]), np.array([2, 4]), 3) == trivial.c_trivial\n    assert trivial.c_trivial == vectorized_is_trivial(",
        "detail": "pybind11.tests.test_numpy_vectorize",
        "documentation": {}
    },
    {
        "label": "test_trivial_broadcasting",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_vectorize",
        "description": "pybind11.tests.test_numpy_vectorize",
        "peekOfCode": "def test_trivial_broadcasting():\n    trivial, vectorized_is_trivial = m.trivial, m.vectorized_is_trivial\n    assert vectorized_is_trivial(1, 2, 3) == trivial.c_trivial\n    assert vectorized_is_trivial(np.array(1), np.array(2), 3) == trivial.c_trivial\n    assert vectorized_is_trivial(np.array([1, 3]), np.array([2, 4]), 3) == trivial.c_trivial\n    assert trivial.c_trivial == vectorized_is_trivial(\n        np.array([[1, 3, 5], [7, 9, 11]]), np.array([[2, 4, 6], [8, 10, 12]]), 3)\n    assert vectorized_is_trivial(\n        np.array([[1, 2, 3], [4, 5, 6]]), np.array([2, 3, 4]), 2) == trivial.non_trivial\n    assert vectorized_is_trivial(",
        "detail": "pybind11.tests.test_numpy_vectorize",
        "documentation": {}
    },
    {
        "label": "test_passthrough_arguments",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_vectorize",
        "description": "pybind11.tests.test_numpy_vectorize",
        "peekOfCode": "def test_passthrough_arguments(doc):\n    assert doc(m.vec_passthrough) == (\n        \"vec_passthrough(\" + \", \".join([\n            \"arg0: float\",\n            \"arg1: numpy.ndarray[numpy.float64]\",\n            \"arg2: numpy.ndarray[numpy.float64]\",\n            \"arg3: numpy.ndarray[numpy.int32]\",\n            \"arg4: int\",\n            \"arg5: m.numpy_vectorize.NonPODClass\",\n            \"arg6: numpy.ndarray[numpy.float64]\"]) + \") -> object\")",
        "detail": "pybind11.tests.test_numpy_vectorize",
        "documentation": {}
    },
    {
        "label": "test_method_vectorization",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_vectorize",
        "description": "pybind11.tests.test_numpy_vectorize",
        "peekOfCode": "def test_method_vectorization():\n    o = m.VectorizeTestClass(3)\n    x = np.array([1, 2], dtype='int')\n    y = np.array([[10], [20]], dtype='float32')\n    assert np.all(o.method(x, y) == [[14, 15], [24, 25]])\ndef test_array_collapse():\n    assert not isinstance(m.vectorized_func(1, 2, 3), np.ndarray)\n    assert not isinstance(m.vectorized_func(np.array(1), 2, 3), np.ndarray)\n    z = m.vectorized_func([1], 2, 3)\n    assert isinstance(z, np.ndarray)",
        "detail": "pybind11.tests.test_numpy_vectorize",
        "documentation": {}
    },
    {
        "label": "test_array_collapse",
        "kind": 2,
        "importPath": "pybind11.tests.test_numpy_vectorize",
        "description": "pybind11.tests.test_numpy_vectorize",
        "peekOfCode": "def test_array_collapse():\n    assert not isinstance(m.vectorized_func(1, 2, 3), np.ndarray)\n    assert not isinstance(m.vectorized_func(np.array(1), 2, 3), np.ndarray)\n    z = m.vectorized_func([1], 2, 3)\n    assert isinstance(z, np.ndarray)\n    assert z.shape == (1, )\n    z = m.vectorized_func(1, [[[2]]], 3)\n    assert isinstance(z, np.ndarray)\n    assert z.shape == (1, 1, 1)",
        "detail": "pybind11.tests.test_numpy_vectorize",
        "documentation": {}
    },
    {
        "label": "np",
        "kind": 5,
        "importPath": "pybind11.tests.test_numpy_vectorize",
        "description": "pybind11.tests.test_numpy_vectorize",
        "peekOfCode": "np = pytest.importorskip(\"numpy\")\ndef test_vectorize(capture):\n    assert np.isclose(m.vectorized_func3(np.array(3 + 7j)), [6 + 14j])\n    for f in [m.vectorized_func, m.vectorized_func2]:\n        with capture:\n            assert np.isclose(f(1, 2, 3), 6)\n        assert capture == \"my_func(x:int=1, y:float=2, z:float=3)\"\n        with capture:\n            assert np.isclose(f(np.array(1), np.array(2), 3), 6)\n        assert capture == \"my_func(x:int=1, y:float=2, z:float=3)\"",
        "detail": "pybind11.tests.test_numpy_vectorize",
        "documentation": {}
    },
    {
        "label": "test_string_list",
        "kind": 2,
        "importPath": "pybind11.tests.test_opaque_types",
        "description": "pybind11.tests.test_opaque_types",
        "peekOfCode": "def test_string_list():\n    lst = m.StringList()\n    lst.push_back(\"Element 1\")\n    lst.push_back(\"Element 2\")\n    assert m.print_opaque_list(lst) == \"Opaque list: [Element 1, Element 2]\"\n    assert lst.back() == \"Element 2\"\n    for i, k in enumerate(lst, start=1):\n        assert k == \"Element {}\".format(i)\n    lst.pop_back()\n    assert m.print_opaque_list(lst) == \"Opaque list: [Element 1]\"",
        "detail": "pybind11.tests.test_opaque_types",
        "documentation": {}
    },
    {
        "label": "test_pointers",
        "kind": 2,
        "importPath": "pybind11.tests.test_opaque_types",
        "description": "pybind11.tests.test_opaque_types",
        "peekOfCode": "def test_pointers(msg):\n    living_before = ConstructorStats.get(UserType).alive()\n    assert m.get_void_ptr_value(m.return_void_ptr()) == 0x1234\n    assert m.get_void_ptr_value(UserType())  # Should also work for other C++ types\n    assert ConstructorStats.get(UserType).alive() == living_before\n    with pytest.raises(TypeError) as excinfo:\n        m.get_void_ptr_value([1, 2, 3])  # This should not work\n    assert msg(excinfo.value) == \"\"\"\n        get_void_ptr_value(): incompatible function arguments. The following argument types are supported:\n            1. (arg0: capsule) -> int",
        "detail": "pybind11.tests.test_opaque_types",
        "documentation": {}
    },
    {
        "label": "test_operator_overloading",
        "kind": 2,
        "importPath": "pybind11.tests.test_operator_overloading",
        "description": "pybind11.tests.test_operator_overloading",
        "peekOfCode": "def test_operator_overloading():\n    v1 = m.Vector2(1, 2)\n    v2 = m.Vector(3, -1)\n    v3 = m.Vector2(1, 2)  # Same value as v1, but different instance.\n    assert v1 is not v3\n    assert str(v1) == \"[1.000000, 2.000000]\"\n    assert str(v2) == \"[3.000000, -1.000000]\"\n    assert str(-v2) == \"[-3.000000, 1.000000]\"\n    assert str(v1 + v2) == \"[4.000000, 1.000000]\"\n    assert str(v1 - v2) == \"[-2.000000, 3.000000]\"",
        "detail": "pybind11.tests.test_operator_overloading",
        "documentation": {}
    },
    {
        "label": "test_operators_notimplemented",
        "kind": 2,
        "importPath": "pybind11.tests.test_operator_overloading",
        "description": "pybind11.tests.test_operator_overloading",
        "peekOfCode": "def test_operators_notimplemented():\n    \"\"\"#393: need to return NotSupported to ensure correct arithmetic operator behavior\"\"\"\n    c1, c2 = m.C1(), m.C2()\n    assert c1 + c1 == 11\n    assert c2 + c2 == 22\n    assert c2 + c1 == 21\n    assert c1 + c2 == 12\ndef test_nested():\n    \"\"\"#328: first member in a class can't be used in operators\"\"\"\n    a = m.NestA()",
        "detail": "pybind11.tests.test_operator_overloading",
        "documentation": {}
    },
    {
        "label": "test_nested",
        "kind": 2,
        "importPath": "pybind11.tests.test_operator_overloading",
        "description": "pybind11.tests.test_operator_overloading",
        "peekOfCode": "def test_nested():\n    \"\"\"#328: first member in a class can't be used in operators\"\"\"\n    a = m.NestA()\n    b = m.NestB()\n    c = m.NestC()\n    a += 10\n    assert m.get_NestA(a) == 13\n    b.a += 100\n    assert m.get_NestA(b.a) == 103\n    c.b.a += 1000",
        "detail": "pybind11.tests.test_operator_overloading",
        "documentation": {}
    },
    {
        "label": "test_overriding_eq_reset_hash",
        "kind": 2,
        "importPath": "pybind11.tests.test_operator_overloading",
        "description": "pybind11.tests.test_operator_overloading",
        "peekOfCode": "def test_overriding_eq_reset_hash():\n    assert m.Comparable(15) is not m.Comparable(15)\n    assert m.Comparable(15) == m.Comparable(15)\n    with pytest.raises(TypeError):\n        hash(m.Comparable(15))  # TypeError: unhashable type: 'm.Comparable'\n    for hashable in (m.Hashable, m.Hashable2):\n        assert hashable(15) is not hashable(15)\n        assert hashable(15) == hashable(15)\n        assert hash(hashable(15)) == 15\n        assert hash(hashable(15)) == hash(hashable(15))",
        "detail": "pybind11.tests.test_operator_overloading",
        "documentation": {}
    },
    {
        "label": "test_roundtrip",
        "kind": 2,
        "importPath": "pybind11.tests.test_pickling",
        "description": "pybind11.tests.test_pickling",
        "peekOfCode": "def test_roundtrip(cls_name):\n    cls = getattr(m, cls_name)\n    p = cls(\"test_value\")\n    p.setExtra1(15)\n    p.setExtra2(48)\n    data = pickle.dumps(p, 2)  # Must use pickle protocol >= 2\n    p2 = pickle.loads(data)\n    assert p2.value() == p.value()\n    assert p2.extra1() == p.extra1()\n    assert p2.extra2() == p.extra2()",
        "detail": "pybind11.tests.test_pickling",
        "documentation": {}
    },
    {
        "label": "test_roundtrip_with_dict",
        "kind": 2,
        "importPath": "pybind11.tests.test_pickling",
        "description": "pybind11.tests.test_pickling",
        "peekOfCode": "def test_roundtrip_with_dict(cls_name):\n    cls = getattr(m, cls_name)\n    p = cls(\"test_value\")\n    p.extra = 15\n    p.dynamic = \"Attribute\"\n    data = pickle.dumps(p, pickle.HIGHEST_PROTOCOL)\n    p2 = pickle.loads(data)\n    assert p2.value == p.value\n    assert p2.extra == p.extra\n    assert p2.dynamic == p.dynamic",
        "detail": "pybind11.tests.test_pickling",
        "documentation": {}
    },
    {
        "label": "test_enum_pickle",
        "kind": 2,
        "importPath": "pybind11.tests.test_pickling",
        "description": "pybind11.tests.test_pickling",
        "peekOfCode": "def test_enum_pickle():\n    from pybind11_tests import enums as e\n    data = pickle.dumps(e.EOne, 2)\n    assert e.EOne == pickle.loads(data)",
        "detail": "pybind11.tests.test_pickling",
        "documentation": {}
    },
    {
        "label": "test_int",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_int(doc):\n    assert doc(m.get_int) == \"get_int() -> int\"\ndef test_iterator(doc):\n    assert doc(m.get_iterator) == \"get_iterator() -> Iterator\"\ndef test_iterable(doc):\n    assert doc(m.get_iterable) == \"get_iterable() -> Iterable\"\ndef test_list(capture, doc):\n    with capture:\n        lst = m.get_list()\n        assert lst == [\"inserted-0\", \"overwritten\", \"inserted-2\"]",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_iterator",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_iterator(doc):\n    assert doc(m.get_iterator) == \"get_iterator() -> Iterator\"\ndef test_iterable(doc):\n    assert doc(m.get_iterable) == \"get_iterable() -> Iterable\"\ndef test_list(capture, doc):\n    with capture:\n        lst = m.get_list()\n        assert lst == [\"inserted-0\", \"overwritten\", \"inserted-2\"]\n        lst.append(\"value2\")\n        m.print_list(lst)",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_iterable",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_iterable(doc):\n    assert doc(m.get_iterable) == \"get_iterable() -> Iterable\"\ndef test_list(capture, doc):\n    with capture:\n        lst = m.get_list()\n        assert lst == [\"inserted-0\", \"overwritten\", \"inserted-2\"]\n        lst.append(\"value2\")\n        m.print_list(lst)\n    assert capture.unordered == \"\"\"\n        Entry at position 0: value",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_list",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_list(capture, doc):\n    with capture:\n        lst = m.get_list()\n        assert lst == [\"inserted-0\", \"overwritten\", \"inserted-2\"]\n        lst.append(\"value2\")\n        m.print_list(lst)\n    assert capture.unordered == \"\"\"\n        Entry at position 0: value\n        list item 0: inserted-0\n        list item 1: overwritten",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_none",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_none(capture, doc):\n    assert doc(m.get_none) == \"get_none() -> None\"\n    assert doc(m.print_none) == \"print_none(arg0: None) -> None\"\ndef test_set(capture, doc):\n    s = m.get_set()\n    assert s == {\"key1\", \"key2\", \"key3\"}\n    with capture:\n        s.add(\"key4\")\n        m.print_set(s)\n    assert capture.unordered == \"\"\"",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_set",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_set(capture, doc):\n    s = m.get_set()\n    assert s == {\"key1\", \"key2\", \"key3\"}\n    with capture:\n        s.add(\"key4\")\n        m.print_set(s)\n    assert capture.unordered == \"\"\"\n        key: key1\n        key: key2\n        key: key3",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_dict",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_dict(capture, doc):\n    d = m.get_dict()\n    assert d == {\"key\": \"value\"}\n    with capture:\n        d[\"key2\"] = \"value2\"\n        m.print_dict(d)\n    assert capture.unordered == \"\"\"\n        key: key, value=value\n        key: key2, value=value2\n    \"\"\"",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_str",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_str(doc):\n    assert m.str_from_string().encode().decode() == \"baz\"\n    assert m.str_from_bytes().encode().decode() == \"boo\"\n    assert doc(m.str_from_bytes) == \"str_from_bytes() -> str\"\n    class A(object):\n        def __str__(self):\n            return \"this is a str\"\n        def __repr__(self):\n            return \"this is a repr\"\n    assert m.str_from_object(A()) == \"this is a str\"",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_bytes",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_bytes(doc):\n    assert m.bytes_from_string().decode() == \"foo\"\n    assert m.bytes_from_str().decode() == \"bar\"\n    assert doc(m.bytes_from_str) == \"bytes_from_str() -> {}\".format(\n        \"str\" if env.PY2 else \"bytes\"\n    )\ndef test_capsule(capture):\n    pytest.gc_collect()\n    with capture:\n        a = m.return_capsule_with_destructor()",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_capsule",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_capsule(capture):\n    pytest.gc_collect()\n    with capture:\n        a = m.return_capsule_with_destructor()\n        del a\n        pytest.gc_collect()\n    assert capture.unordered == \"\"\"\n        creating capsule\n        destructing capsule\n    \"\"\"",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_accessors",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_accessors():\n    class SubTestObject:\n        attr_obj = 1\n        attr_char = 2\n    class TestObject:\n        basic_attr = 1\n        begin_end = [1, 2, 3]\n        d = {\"operator[object]\": 1, \"operator[char *]\": 2}\n        sub = SubTestObject()\n        def func(self, x, *args):",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_constructors",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_constructors():\n    \"\"\"C++ default and converting constructors are equivalent to type calls in Python\"\"\"\n    types = [bytes, str, bool, int, float, tuple, list, dict, set]\n    expected = {t.__name__: t() for t in types}\n    if env.PY2:\n        # Note that bytes.__name__ == 'str' in Python 2.\n        # pybind11::str is unicode even under Python 2.\n        expected[\"bytes\"] = bytes()\n        expected[\"str\"] = unicode()  # noqa: F821\n    assert m.default_constructors() == expected",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_pybind11_str_raw_str",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_pybind11_str_raw_str():\n    # specifically to exercise pybind11::str::raw_str\n    cvt = m.convert_to_pybind11_str\n    assert cvt(u\"Str\") == u\"Str\"\n    assert cvt(b'Bytes') == u\"Bytes\" if env.PY2 else \"b'Bytes'\"\n    assert cvt(None) == u\"None\"\n    assert cvt(False) == u\"False\"\n    assert cvt(True) == u\"True\"\n    assert cvt(42) == u\"42\"\n    assert cvt(2**65) == u\"36893488147419103232\"",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_implicit_casting",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_implicit_casting():\n    \"\"\"Tests implicit casting when assigning or appending to dicts and lists.\"\"\"\n    z = m.get_implicit_casting()\n    assert z['d'] == {\n        'char*_i1': 'abc', 'char*_i2': 'abc', 'char*_e': 'abc', 'char*_p': 'abc',\n        'str_i1': 'str', 'str_i2': 'str1', 'str_e': 'str2', 'str_p': 'str3',\n        'int_i1': 42, 'int_i2': 42, 'int_e': 43, 'int_p': 44\n    }\n    assert z['l'] == [3, 6, 9, 12, 15]\ndef test_print(capture):",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_print",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_print(capture):\n    with capture:\n        m.print_function()\n    assert capture == \"\"\"\n        Hello, World!\n        1 2.0 three True -- multiple args\n        *args-and-a-custom-separator\n        no new line here -- next print\n        flush\n        py::print + str.format = this",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_hash",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_hash():\n    class Hashable(object):\n        def __init__(self, value):\n            self.value = value\n        def __hash__(self):\n            return self.value\n    class Unhashable(object):\n        __hash__ = None\n    assert m.hash_function(Hashable(42)) == 42\n    with pytest.raises(TypeError):",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_number_protocol",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_number_protocol():\n    for a, b in [(1, 1), (3, 5)]:\n        li = [a == b, a != b, a < b, a <= b, a > b, a >= b, a + b,\n              a - b, a * b, a / b, a | b, a & b, a ^ b, a >> b, a << b]\n        assert m.test_number_protocol(a, b) == li\ndef test_list_slicing():\n    li = list(range(100))\n    assert li[::2] == m.test_list_slicing(li)\n@pytest.mark.parametrize('method, args, fmt, expected_view', [\n    (m.test_memoryview_object, (b'red',), 'B', b'red'),",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_list_slicing",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_list_slicing():\n    li = list(range(100))\n    assert li[::2] == m.test_list_slicing(li)\n@pytest.mark.parametrize('method, args, fmt, expected_view', [\n    (m.test_memoryview_object, (b'red',), 'B', b'red'),\n    (m.test_memoryview_buffer_info, (b'green',), 'B', b'green'),\n    (m.test_memoryview_from_buffer, (False,), 'h', [3, 1, 4, 1, 5]),\n    (m.test_memoryview_from_buffer, (True,), 'H', [2, 7, 1, 8]),\n    (m.test_memoryview_from_buffer_nativeformat, (), '@i', [4, 7, 5]),\n])",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_memoryview",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_memoryview(method, args, fmt, expected_view):\n    view = method(*args)\n    assert isinstance(view, memoryview)\n    assert view.format == fmt\n    if isinstance(expected_view, bytes) or not env.PY2:\n        view_as_list = list(view)\n    else:\n        # Using max to pick non-zero byte (big-endian vs little-endian).\n        view_as_list = [max([ord(c) for c in s]) for s in view]\n    assert view_as_list == list(expected_view)",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_memoryview_refcount",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_memoryview_refcount(method):\n    buf = b'\\x0a\\x0b\\x0c\\x0d'\n    ref_before = sys.getrefcount(buf)\n    view = method(buf)\n    ref_after = sys.getrefcount(buf)\n    assert ref_before < ref_after\n    assert list(view) == list(buf)\ndef test_memoryview_from_buffer_empty_shape():\n    view = m.test_memoryview_from_buffer_empty_shape()\n    assert isinstance(view, memoryview)",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_memoryview_from_buffer_empty_shape",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_memoryview_from_buffer_empty_shape():\n    view = m.test_memoryview_from_buffer_empty_shape()\n    assert isinstance(view, memoryview)\n    assert view.format == 'B'\n    if env.PY2:\n        # Python 2 behavior is weird, but Python 3 (the future) is fine.\n        # PyPy3 has <memoryview, while CPython 2 has <memory\n        assert bytes(view).startswith(b'<memory')\n    else:\n        assert bytes(view) == b''",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_test_memoryview_from_buffer_invalid_strides",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_test_memoryview_from_buffer_invalid_strides():\n    with pytest.raises(RuntimeError):\n        m.test_memoryview_from_buffer_invalid_strides()\ndef test_test_memoryview_from_buffer_nullptr():\n    if env.PY2:\n        m.test_memoryview_from_buffer_nullptr()\n    else:\n        with pytest.raises(ValueError):\n            m.test_memoryview_from_buffer_nullptr()\n@pytest.mark.skipif(\"env.PY2\")",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_test_memoryview_from_buffer_nullptr",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_test_memoryview_from_buffer_nullptr():\n    if env.PY2:\n        m.test_memoryview_from_buffer_nullptr()\n    else:\n        with pytest.raises(ValueError):\n            m.test_memoryview_from_buffer_nullptr()\n@pytest.mark.skipif(\"env.PY2\")\ndef test_memoryview_from_memory():\n    view = m.test_memoryview_from_memory()\n    assert isinstance(view, memoryview)",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "test_memoryview_from_memory",
        "kind": 2,
        "importPath": "pybind11.tests.test_pytypes",
        "description": "pybind11.tests.test_pytypes",
        "peekOfCode": "def test_memoryview_from_memory():\n    view = m.test_memoryview_from_memory()\n    assert isinstance(view, memoryview)\n    assert view.format == 'B'\n    assert bytes(view) == b'\\xff\\xe1\\xab\\x37'",
        "detail": "pybind11.tests.test_pytypes",
        "documentation": {}
    },
    {
        "label": "isclose",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def isclose(a, b, rel_tol=1e-05, abs_tol=0.0):\n    \"\"\"Like math.isclose() from Python 3.5\"\"\"\n    return abs(a - b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\ndef allclose(a_list, b_list, rel_tol=1e-05, abs_tol=0.0):\n    return all(isclose(a, b, rel_tol=rel_tol, abs_tol=abs_tol) for a, b in zip(a_list, b_list))\ndef test_generalized_iterators():\n    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero()) == [(1, 2), (3, 4)]\n    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero()) == [(1, 2)]\n    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero()) == []\n    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_keys()) == [1, 3]",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "allclose",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def allclose(a_list, b_list, rel_tol=1e-05, abs_tol=0.0):\n    return all(isclose(a, b, rel_tol=rel_tol, abs_tol=abs_tol) for a, b in zip(a_list, b_list))\ndef test_generalized_iterators():\n    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero()) == [(1, 2), (3, 4)]\n    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero()) == [(1, 2)]\n    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero()) == []\n    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_keys()) == [1, 3]\n    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_keys()) == [1]\n    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_keys()) == []\n    # __next__ must continue to raise StopIteration",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_generalized_iterators",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def test_generalized_iterators():\n    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero()) == [(1, 2), (3, 4)]\n    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero()) == [(1, 2)]\n    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero()) == []\n    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_keys()) == [1, 3]\n    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_keys()) == [1]\n    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_keys()) == []\n    # __next__ must continue to raise StopIteration\n    it = m.IntPairs([(0, 0)]).nonzero()\n    for _ in range(3):",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_sliceable",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def test_sliceable():\n    sliceable = m.Sliceable(100)\n    assert sliceable[::] == (0, 100, 1)\n    assert sliceable[10::] == (10, 100, 1)\n    assert sliceable[:10:] == (0, 10, 1)\n    assert sliceable[::10] == (0, 100, 10)\n    assert sliceable[-10::] == (90, 100, 1)\n    assert sliceable[:-10:] == (0, 90, 1)\n    assert sliceable[::-10] == (99, -1, -10)\n    assert sliceable[50:60:1] == (50, 60, 1)",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_sequence",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def test_sequence():\n    cstats = ConstructorStats.get(m.Sequence)\n    s = m.Sequence(5)\n    assert cstats.values() == ['of size', '5']\n    assert \"Sequence\" in repr(s)\n    assert len(s) == 5\n    assert s[0] == 0 and s[3] == 0\n    assert 12.34 not in s\n    s[0], s[3] = 12.34, 56.78\n    assert 12.34 in s",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_sequence_length",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def test_sequence_length():\n    \"\"\"#2076: Exception raised by len(arg) should be propagated \"\"\"\n    class BadLen(RuntimeError):\n        pass\n    class SequenceLike():\n        def __getitem__(self, i):\n            return None\n        def __len__(self):\n            raise BadLen()\n    with pytest.raises(BadLen):",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_map_iterator",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def test_map_iterator():\n    sm = m.StringMap({'hi': 'bye', 'black': 'white'})\n    assert sm['hi'] == 'bye'\n    assert len(sm) == 2\n    assert sm['black'] == 'white'\n    with pytest.raises(KeyError):\n        assert sm['orange']\n    sm['orange'] = 'banana'\n    assert sm['orange'] == 'banana'\n    expected = {'hi': 'bye', 'black': 'white', 'orange': 'banana'}",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_python_iterator_in_cpp",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def test_python_iterator_in_cpp():\n    t = (1, 2, 3)\n    assert m.object_to_list(t) == [1, 2, 3]\n    assert m.object_to_list(iter(t)) == [1, 2, 3]\n    assert m.iterator_to_list(iter(t)) == [1, 2, 3]\n    with pytest.raises(TypeError) as excinfo:\n        m.object_to_list(1)\n    assert \"object is not iterable\" in str(excinfo.value)\n    with pytest.raises(TypeError) as excinfo:\n        m.iterator_to_list(1)",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_iterator_passthrough",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def test_iterator_passthrough():\n    \"\"\"#181: iterator passthrough did not compile\"\"\"\n    from pybind11_tests.sequences_and_iterators import iterator_passthrough\n    assert list(iterator_passthrough(iter([3, 5, 7, 9, 11, 13, 15]))) == [3, 5, 7, 9, 11, 13, 15]\ndef test_iterator_rvp():\n    \"\"\"#388: Can't make iterators via make_iterator() with different r/v policies \"\"\"\n    import pybind11_tests.sequences_and_iterators as m\n    assert list(m.make_iterator_1()) == [1, 2, 3]\n    assert list(m.make_iterator_2()) == [1, 2, 3]\n    assert not isinstance(m.make_iterator_1(), type(m.make_iterator_2()))",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_iterator_rvp",
        "kind": 2,
        "importPath": "pybind11.tests.test_sequences_and_iterators",
        "description": "pybind11.tests.test_sequences_and_iterators",
        "peekOfCode": "def test_iterator_rvp():\n    \"\"\"#388: Can't make iterators via make_iterator() with different r/v policies \"\"\"\n    import pybind11_tests.sequences_and_iterators as m\n    assert list(m.make_iterator_1()) == [1, 2, 3]\n    assert list(m.make_iterator_2()) == [1, 2, 3]\n    assert not isinstance(m.make_iterator_1(), type(m.make_iterator_2()))",
        "detail": "pybind11.tests.test_sequences_and_iterators",
        "documentation": {}
    },
    {
        "label": "test_smart_ptr",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_smart_ptr(capture):\n    # Object1\n    for i, o in enumerate([m.make_object_1(), m.make_object_2(), m.MyObject1(3)], start=1):\n        assert o.getRefCount() == 1\n        with capture:\n            m.print_object_1(o)\n            m.print_object_2(o)\n            m.print_object_3(o)\n            m.print_object_4(o)\n        assert capture == \"MyObject1[{i}]\\n\".format(i=i) * 4",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_smart_ptr_refcounting",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_smart_ptr_refcounting():\n    assert m.test_object1_refcounting()\ndef test_unique_nodelete():\n    o = m.MyObject4(23)\n    assert o.value == 23\n    cstats = ConstructorStats.get(m.MyObject4)\n    assert cstats.alive() == 1\n    del o\n    assert cstats.alive() == 1  # Leak, but that's intentional\ndef test_unique_nodelete4a():",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_unique_nodelete",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_unique_nodelete():\n    o = m.MyObject4(23)\n    assert o.value == 23\n    cstats = ConstructorStats.get(m.MyObject4)\n    assert cstats.alive() == 1\n    del o\n    assert cstats.alive() == 1  # Leak, but that's intentional\ndef test_unique_nodelete4a():\n    o = m.MyObject4a(23)\n    assert o.value == 23",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_unique_nodelete4a",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_unique_nodelete4a():\n    o = m.MyObject4a(23)\n    assert o.value == 23\n    cstats = ConstructorStats.get(m.MyObject4a)\n    assert cstats.alive() == 1\n    del o\n    assert cstats.alive() == 1  # Leak, but that's intentional\ndef test_unique_deleter():\n    o = m.MyObject4b(23)\n    assert o.value == 23",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_unique_deleter",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_unique_deleter():\n    o = m.MyObject4b(23)\n    assert o.value == 23\n    cstats4a = ConstructorStats.get(m.MyObject4a)\n    assert cstats4a.alive() == 2  # Two because of previous test\n    cstats4b = ConstructorStats.get(m.MyObject4b)\n    assert cstats4b.alive() == 1\n    del o\n    assert cstats4a.alive() == 1  # Should now only be one leftover from previous test\n    assert cstats4b.alive() == 0  # Should be deleted",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_large_holder",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_large_holder():\n    o = m.MyObject5(5)\n    assert o.value == 5\n    cstats = ConstructorStats.get(m.MyObject5)\n    assert cstats.alive() == 1\n    del o\n    assert cstats.alive() == 0\ndef test_shared_ptr_and_references():\n    s = m.SharedPtrRef()\n    stats = ConstructorStats.get(m.A)",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_shared_ptr_and_references",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_shared_ptr_and_references():\n    s = m.SharedPtrRef()\n    stats = ConstructorStats.get(m.A)\n    assert stats.alive() == 2\n    ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false)\n    assert stats.alive() == 2\n    assert s.set_ref(ref)\n    with pytest.raises(RuntimeError) as excinfo:\n        assert s.set_holder(ref)\n    assert \"Unable to cast from non-held to held instance\" in str(excinfo.value)",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_shared_ptr_from_this_and_references",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_shared_ptr_from_this_and_references():\n    s = m.SharedFromThisRef()\n    stats = ConstructorStats.get(m.B)\n    assert stats.alive() == 2\n    ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=false)\n    assert stats.alive() == 2\n    assert s.set_ref(ref)\n    assert s.set_holder(ref)  # std::enable_shared_from_this can create a holder from a reference\n    bad_wp = s.bad_wp  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=true)\n    assert stats.alive() == 2",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_move_only_holder",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_move_only_holder():\n    a = m.TypeWithMoveOnlyHolder.make()\n    b = m.TypeWithMoveOnlyHolder.make_as_object()\n    stats = ConstructorStats.get(m.TypeWithMoveOnlyHolder)\n    assert stats.alive() == 2\n    del b\n    assert stats.alive() == 1\n    del a\n    assert stats.alive() == 0\ndef test_holder_with_addressof_operator():",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_holder_with_addressof_operator",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_holder_with_addressof_operator():\n    # this test must not throw exception from c++\n    a = m.TypeForHolderWithAddressOf.make()\n    a.print_object_1()\n    a.print_object_2()\n    a.print_object_3()\n    a.print_object_4()\n    stats = ConstructorStats.get(m.TypeForHolderWithAddressOf)\n    assert stats.alive() == 1\n    np = m.TypeForHolderWithAddressOf.make()",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_move_only_holder_with_addressof_operator",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_move_only_holder_with_addressof_operator():\n    a = m.TypeForMoveOnlyHolderWithAddressOf.make()\n    a.print_object()\n    stats = ConstructorStats.get(m.TypeForMoveOnlyHolderWithAddressOf)\n    assert stats.alive() == 1\n    a.value = 42\n    assert a.value == 42\n    del a\n    assert stats.alive() == 0\ndef test_smart_ptr_from_default():",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_smart_ptr_from_default",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_smart_ptr_from_default():\n    instance = m.HeldByDefaultHolder()\n    with pytest.raises(RuntimeError) as excinfo:\n        m.HeldByDefaultHolder.load_shared_ptr(instance)\n    assert \"Unable to load a custom holder type from a \" \\\n           \"default-holder instance\" in str(excinfo.value)\ndef test_shared_ptr_gc():\n    \"\"\"#187: issue involving std::shared_ptr<> return value policy & garbage collection\"\"\"\n    el = m.ElementList()\n    for i in range(10):",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_shared_ptr_gc",
        "kind": 2,
        "importPath": "pybind11.tests.test_smart_ptr",
        "description": "pybind11.tests.test_smart_ptr",
        "peekOfCode": "def test_shared_ptr_gc():\n    \"\"\"#187: issue involving std::shared_ptr<> return value policy & garbage collection\"\"\"\n    el = m.ElementList()\n    for i in range(10):\n        el.add(m.ElementA(i))\n    pytest.gc_collect()\n    for i, v in enumerate(el.get()):\n        assert i == v.value()",
        "detail": "pybind11.tests.test_smart_ptr",
        "documentation": {}
    },
    {
        "label": "test_vector",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_vector(doc):\n    \"\"\"std::vector <-> list\"\"\"\n    lst = m.cast_vector()\n    assert lst == [1]\n    lst.append(2)\n    assert m.load_vector(lst)\n    assert m.load_vector(tuple(lst))\n    assert m.cast_bool_vector() == [True, False]\n    assert m.load_bool_vector([True, False])\n    assert doc(m.cast_vector) == \"cast_vector() -> List[int]\"",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_deque",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_deque(doc):\n    \"\"\"std::deque <-> list\"\"\"\n    lst = m.cast_deque()\n    assert lst == [1]\n    lst.append(2)\n    assert m.load_deque(lst)\n    assert m.load_deque(tuple(lst))\ndef test_array(doc):\n    \"\"\"std::array <-> list\"\"\"\n    lst = m.cast_array()",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_array",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_array(doc):\n    \"\"\"std::array <-> list\"\"\"\n    lst = m.cast_array()\n    assert lst == [1, 2]\n    assert m.load_array(lst)\n    assert doc(m.cast_array) == \"cast_array() -> List[int[2]]\"\n    assert doc(m.load_array) == \"load_array(arg0: List[int[2]]) -> bool\"\ndef test_valarray(doc):\n    \"\"\"std::valarray <-> list\"\"\"\n    lst = m.cast_valarray()",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_valarray",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_valarray(doc):\n    \"\"\"std::valarray <-> list\"\"\"\n    lst = m.cast_valarray()\n    assert lst == [1, 4, 9]\n    assert m.load_valarray(lst)\n    assert doc(m.cast_valarray) == \"cast_valarray() -> List[int]\"\n    assert doc(m.load_valarray) == \"load_valarray(arg0: List[int]) -> bool\"\ndef test_map(doc):\n    \"\"\"std::map <-> dict\"\"\"\n    d = m.cast_map()",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_map",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_map(doc):\n    \"\"\"std::map <-> dict\"\"\"\n    d = m.cast_map()\n    assert d == {\"key\": \"value\"}\n    assert \"key\" in d\n    d[\"key2\"] = \"value2\"\n    assert \"key2\" in d\n    assert m.load_map(d)\n    assert doc(m.cast_map) == \"cast_map() -> Dict[str, str]\"\n    assert doc(m.load_map) == \"load_map(arg0: Dict[str, str]) -> bool\"",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_set",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_set(doc):\n    \"\"\"std::set <-> set\"\"\"\n    s = m.cast_set()\n    assert s == {\"key1\", \"key2\"}\n    s.add(\"key3\")\n    assert m.load_set(s)\n    assert doc(m.cast_set) == \"cast_set() -> Set[str]\"\n    assert doc(m.load_set) == \"load_set(arg0: Set[str]) -> bool\"\ndef test_recursive_casting():\n    \"\"\"Tests that stl casters preserve lvalue/rvalue context for container values\"\"\"",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_recursive_casting",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_recursive_casting():\n    \"\"\"Tests that stl casters preserve lvalue/rvalue context for container values\"\"\"\n    assert m.cast_rv_vector() == [\"rvalue\", \"rvalue\"]\n    assert m.cast_lv_vector() == [\"lvalue\", \"lvalue\"]\n    assert m.cast_rv_array() == [\"rvalue\", \"rvalue\", \"rvalue\"]\n    assert m.cast_lv_array() == [\"lvalue\", \"lvalue\"]\n    assert m.cast_rv_map() == {\"a\": \"rvalue\"}\n    assert m.cast_lv_map() == {\"a\": \"lvalue\", \"b\": \"lvalue\"}\n    assert m.cast_rv_nested() == [[[{\"b\": \"rvalue\", \"c\": \"rvalue\"}], [{\"a\": \"rvalue\"}]]]\n    assert m.cast_lv_nested() == {",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_move_out_container",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_move_out_container():\n    \"\"\"Properties use the `reference_internal` policy by default. If the underlying function\n    returns an rvalue, the policy is automatically changed to `move` to avoid referencing\n    a temporary. In case the return value is a container of user-defined types, the policy\n    also needs to be applied to the elements, not just the container.\"\"\"\n    c = m.MoveOutContainer()\n    moved_out_list = c.move_list\n    assert [x.value for x in moved_out_list] == [0, 1, 2]\n@pytest.mark.skipif(not hasattr(m, \"has_optional\"), reason='no <optional>')\ndef test_optional():",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_optional",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_optional():\n    assert m.double_or_zero(None) == 0\n    assert m.double_or_zero(42) == 84\n    pytest.raises(TypeError, m.double_or_zero, 'foo')\n    assert m.half_or_none(0) is None\n    assert m.half_or_none(42) == 21\n    pytest.raises(TypeError, m.half_or_none, 'foo')\n    assert m.test_nullopt() == 42\n    assert m.test_nullopt(None) == 42\n    assert m.test_nullopt(42) == 42",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_exp_optional",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_exp_optional():\n    assert m.double_or_zero_exp(None) == 0\n    assert m.double_or_zero_exp(42) == 84\n    pytest.raises(TypeError, m.double_or_zero_exp, 'foo')\n    assert m.half_or_none_exp(0) is None\n    assert m.half_or_none_exp(42) == 21\n    pytest.raises(TypeError, m.half_or_none_exp, 'foo')\n    assert m.test_nullopt_exp() == 42\n    assert m.test_nullopt_exp(None) == 42\n    assert m.test_nullopt_exp(42) == 42",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_variant",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_variant(doc):\n    assert m.load_variant(1) == \"int\"\n    assert m.load_variant(\"1\") == \"std::string\"\n    assert m.load_variant(1.0) == \"double\"\n    assert m.load_variant(None) == \"std::nullptr_t\"\n    assert m.load_variant_2pass(1) == \"int\"\n    assert m.load_variant_2pass(1.0) == \"double\"\n    assert m.cast_variant() == (5, \"Hello\")\n    assert doc(m.load_variant) == \"load_variant(arg0: Union[int, str, float, None]) -> str\"\ndef test_vec_of_reference_wrapper():",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_vec_of_reference_wrapper",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_vec_of_reference_wrapper():\n    \"\"\"#171: Can't return reference wrappers (or STL structures containing them)\"\"\"\n    assert str(m.return_vec_of_reference_wrapper(UserType(4))) == \\\n        \"[UserType(1), UserType(2), UserType(3), UserType(4)]\"\ndef test_stl_pass_by_pointer(msg):\n    \"\"\"Passing nullptr or None to an STL container pointer is not expected to work\"\"\"\n    with pytest.raises(TypeError) as excinfo:\n        m.stl_pass_by_pointer()  # default value is `nullptr`\n    assert msg(excinfo.value) == \"\"\"\n        stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_stl_pass_by_pointer",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_stl_pass_by_pointer(msg):\n    \"\"\"Passing nullptr or None to an STL container pointer is not expected to work\"\"\"\n    with pytest.raises(TypeError) as excinfo:\n        m.stl_pass_by_pointer()  # default value is `nullptr`\n    assert msg(excinfo.value) == \"\"\"\n        stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:\n            1. (v: List[int] = None) -> List[int]\n        Invoked with:\n    \"\"\"  # noqa: E501 line too long\n    with pytest.raises(TypeError) as excinfo:",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_missing_header_message",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_missing_header_message():\n    \"\"\"Trying convert `list` to a `std::vector`, or vice versa, without including\n    <pybind11/stl.h> should result in a helpful suggestion in the error message\"\"\"\n    import pybind11_cross_module_tests as cm\n    expected_message = (\"Did you forget to `#include <pybind11/stl.h>`? Or <pybind11/complex.h>,\\n\"\n                        \"<pybind11/functional.h>, <pybind11/chrono.h>, etc. Some automatic\\n\"\n                        \"conversions are optional and require extra headers to be included\\n\"\n                        \"when compiling your pybind11 module.\")\n    with pytest.raises(TypeError) as excinfo:\n        cm.missing_header_arg([1.0, 2.0, 3.0])",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_function_with_string_and_vector_string_arg",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_function_with_string_and_vector_string_arg():\n    \"\"\"Check if a string is NOT implicitly converted to a list, which was the\n    behavior before fix of issue #1258\"\"\"\n    assert m.func_with_string_or_vector_string_arg_overload(('A', 'B', )) == 2\n    assert m.func_with_string_or_vector_string_arg_overload(['A', 'B']) == 2\n    assert m.func_with_string_or_vector_string_arg_overload('A') == 3\ndef test_stl_ownership():\n    cstats = ConstructorStats.get(m.Placeholder)\n    assert cstats.alive() == 0\n    r = m.test_stl_ownership()",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_stl_ownership",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_stl_ownership():\n    cstats = ConstructorStats.get(m.Placeholder)\n    assert cstats.alive() == 0\n    r = m.test_stl_ownership()\n    assert len(r) == 1\n    del r\n    assert cstats.alive() == 0\ndef test_array_cast_sequence():\n    assert m.array_cast_sequence((1, 2, 3)) == [1, 2, 3]\ndef test_issue_1561():",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_array_cast_sequence",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_array_cast_sequence():\n    assert m.array_cast_sequence((1, 2, 3)) == [1, 2, 3]\ndef test_issue_1561():\n    \"\"\" check fix for issue #1561 \"\"\"\n    bar = m.Issue1561Outer()\n    bar.list = [m.Issue1561Inner('bar')]\n    bar.list\n    assert bar.list[0].data == 'bar'",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_issue_1561",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl",
        "description": "pybind11.tests.test_stl",
        "peekOfCode": "def test_issue_1561():\n    \"\"\" check fix for issue #1561 \"\"\"\n    bar = m.Issue1561Outer()\n    bar.list = [m.Issue1561Inner('bar')]\n    bar.list\n    assert bar.list[0].data == 'bar'",
        "detail": "pybind11.tests.test_stl",
        "documentation": {}
    },
    {
        "label": "test_vector_int",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_vector_int():\n    v_int = m.VectorInt([0, 0])\n    assert len(v_int) == 2\n    assert bool(v_int) is True\n    # test construction from a generator\n    v_int1 = m.VectorInt(x for x in range(5))\n    assert v_int1 == m.VectorInt([0, 1, 2, 3, 4])\n    v_int2 = m.VectorInt([0, 0])\n    assert v_int == v_int2\n    v_int2[1] = 1",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_vector_buffer",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_vector_buffer():\n    b = bytearray([1, 2, 3, 4])\n    v = m.VectorUChar(b)\n    assert v[1] == 2\n    v[2] = 5\n    mv = memoryview(v)  # We expose the buffer interface\n    if not env.PY2:\n        assert mv[2] == 5\n        mv[2] = 6\n    else:",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_vector_buffer_numpy",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_vector_buffer_numpy():\n    np = pytest.importorskip(\"numpy\")\n    a = np.array([1, 2, 3, 4], dtype=np.int32)\n    with pytest.raises(TypeError):\n        m.VectorInt(a)\n    a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], dtype=np.uintc)\n    v = m.VectorInt(a[0, :])\n    assert len(v) == 4\n    assert v[2] == 3\n    ma = np.asarray(v)",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_vector_bool",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_vector_bool():\n    import pybind11_cross_module_tests as cm\n    vv_c = cm.VectorBool()\n    for i in range(10):\n        vv_c.append(i % 2 == 0)\n    for i in range(10):\n        assert vv_c[i] == (i % 2 == 0)\n    assert str(vv_c) == \"VectorBool[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\"\ndef test_vector_custom():\n    v_a = m.VectorEl()",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_vector_custom",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_vector_custom():\n    v_a = m.VectorEl()\n    v_a.append(m.El(1))\n    v_a.append(m.El(2))\n    assert str(v_a) == \"VectorEl[El{1}, El{2}]\"\n    vv_a = m.VectorVectorEl()\n    vv_a.append(v_a)\n    vv_b = vv_a[0]\n    assert str(vv_b) == \"VectorEl[El{1}, El{2}]\"\ndef test_map_string_double():",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_map_string_double",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_map_string_double():\n    mm = m.MapStringDouble()\n    mm['a'] = 1\n    mm['b'] = 2.5\n    assert list(mm) == ['a', 'b']\n    assert list(mm.items()) == [('a', 1), ('b', 2.5)]\n    assert str(mm) == \"MapStringDouble{a: 1, b: 2.5}\"\n    um = m.UnorderedMapStringDouble()\n    um['ua'] = 1.1\n    um['ub'] = 2.6",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_map_string_double_const",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_map_string_double_const():\n    mc = m.MapStringDoubleConst()\n    mc['a'] = 10\n    mc['b'] = 20.5\n    assert str(mc) == \"MapStringDoubleConst{a: 10, b: 20.5}\"\n    umc = m.UnorderedMapStringDoubleConst()\n    umc['a'] = 11\n    umc['b'] = 21.5\n    str(umc)\ndef test_noncopyable_containers():",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_noncopyable_containers",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_noncopyable_containers():\n    # std::vector\n    vnc = m.get_vnc(5)\n    for i in range(0, 5):\n        assert vnc[i].value == i + 1\n    for i, j in enumerate(vnc, start=1):\n        assert j.value == i\n    # std::deque\n    dnc = m.get_dnc(5)\n    for i in range(0, 5):",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_map_delitem",
        "kind": 2,
        "importPath": "pybind11.tests.test_stl_binders",
        "description": "pybind11.tests.test_stl_binders",
        "peekOfCode": "def test_map_delitem():\n    mm = m.MapStringDouble()\n    mm['a'] = 1\n    mm['b'] = 2.5\n    assert list(mm) == ['a', 'b']\n    assert list(mm.items()) == [('a', 1), ('b', 2.5)]\n    del mm['a']\n    assert list(mm) == ['b']\n    assert list(mm.items()) == [('b', 2.5)]\n    um = m.UnorderedMapStringDouble()",
        "detail": "pybind11.tests.test_stl_binders",
        "documentation": {}
    },
    {
        "label": "test_downcast",
        "kind": 2,
        "importPath": "pybind11.tests.test_tagbased_polymorphic",
        "description": "pybind11.tests.test_tagbased_polymorphic",
        "peekOfCode": "def test_downcast():\n    zoo = m.create_zoo()\n    assert [type(animal) for animal in zoo] == [\n        m.Labrador, m.Dog, m.Chihuahua, m.Cat, m.Panther\n    ]\n    assert [animal.name for animal in zoo] == [\n        \"Fido\", \"Ginger\", \"Hertzl\", \"Tiger\", \"Leo\"\n    ]\n    zoo[1].sound = \"woooooo\"\n    assert [dog.bark() for dog in zoo[:3]] == [",
        "detail": "pybind11.tests.test_tagbased_polymorphic",
        "documentation": {}
    },
    {
        "label": "test_union",
        "kind": 2,
        "importPath": "pybind11.tests.test_union",
        "description": "pybind11.tests.test_union",
        "peekOfCode": "def test_union():\n    instance = m.TestUnion()\n    instance.as_uint = 10\n    assert instance.as_int == 10",
        "detail": "pybind11.tests.test_union",
        "documentation": {}
    },
    {
        "label": "test_override",
        "kind": 2,
        "importPath": "pybind11.tests.test_virtual_functions",
        "description": "pybind11.tests.test_virtual_functions",
        "peekOfCode": "def test_override(capture, msg):\n    class ExtendedExampleVirt(m.ExampleVirt):\n        def __init__(self, state):\n            super(ExtendedExampleVirt, self).__init__(state + 1)\n            self.data = \"Hello world\"\n        def run(self, value):\n            print('ExtendedExampleVirt::run(%i), calling parent..' % value)\n            return super(ExtendedExampleVirt, self).run(value + 1)\n        def run_bool(self):\n            print('ExtendedExampleVirt::run_bool()')",
        "detail": "pybind11.tests.test_virtual_functions",
        "documentation": {}
    },
    {
        "label": "test_alias_delay_initialization1",
        "kind": 2,
        "importPath": "pybind11.tests.test_virtual_functions",
        "description": "pybind11.tests.test_virtual_functions",
        "peekOfCode": "def test_alias_delay_initialization1(capture):\n    \"\"\"`A` only initializes its trampoline class when we inherit from it\n    If we just create and use an A instance directly, the trampoline initialization is\n    bypassed and we only initialize an A() instead (for performance reasons).\n    \"\"\"\n    class B(m.A):\n        def __init__(self):\n            super(B, self).__init__()\n        def f(self):\n            print(\"In python f()\")",
        "detail": "pybind11.tests.test_virtual_functions",
        "documentation": {}
    },
    {
        "label": "test_alias_delay_initialization2",
        "kind": 2,
        "importPath": "pybind11.tests.test_virtual_functions",
        "description": "pybind11.tests.test_virtual_functions",
        "peekOfCode": "def test_alias_delay_initialization2(capture):\n    \"\"\"`A2`, unlike the above, is configured to always initialize the alias\n    While the extra initialization and extra class layer has small virtual dispatch\n    performance penalty, it also allows us to do more things with the trampoline\n    class such as defining local variables and performing construction/destruction.\n    \"\"\"\n    class B2(m.A2):\n        def __init__(self):\n            super(B2, self).__init__()\n        def f(self):",
        "detail": "pybind11.tests.test_virtual_functions",
        "documentation": {}
    },
    {
        "label": "test_move_support",
        "kind": 2,
        "importPath": "pybind11.tests.test_virtual_functions",
        "description": "pybind11.tests.test_virtual_functions",
        "peekOfCode": "def test_move_support():\n    class NCVirtExt(m.NCVirt):\n        def get_noncopyable(self, a, b):\n            # Constructs and returns a new instance:\n            nc = m.NonCopyable(a * a, b * b)\n            return nc\n        def get_movable(self, a, b):\n            # Return a referenced copy\n            self.movable = m.Movable(a, b)\n            return self.movable",
        "detail": "pybind11.tests.test_virtual_functions",
        "documentation": {}
    },
    {
        "label": "test_dispatch_issue",
        "kind": 2,
        "importPath": "pybind11.tests.test_virtual_functions",
        "description": "pybind11.tests.test_virtual_functions",
        "peekOfCode": "def test_dispatch_issue(msg):\n    \"\"\"#159: virtual function dispatch has problems with similar-named functions\"\"\"\n    class PyClass1(m.DispatchIssue):\n        def dispatch(self):\n            return \"Yay..\"\n    class PyClass2(m.DispatchIssue):\n        def dispatch(self):\n            with pytest.raises(RuntimeError) as excinfo:\n                super(PyClass2, self).dispatch()\n            assert msg(excinfo.value) == 'Tried to call pure virtual function \"Base::dispatch\"'",
        "detail": "pybind11.tests.test_virtual_functions",
        "documentation": {}
    },
    {
        "label": "test_override_ref",
        "kind": 2,
        "importPath": "pybind11.tests.test_virtual_functions",
        "description": "pybind11.tests.test_virtual_functions",
        "peekOfCode": "def test_override_ref():\n    \"\"\"#392/397: overriding reference-returning functions\"\"\"\n    o = m.OverrideTest(\"asdf\")\n    # Not allowed (see associated .cpp comment)\n    # i = o.str_ref()\n    # assert o.str_ref() == \"asdf\"\n    assert o.str_value() == \"asdf\"\n    assert o.A_value().value == \"hi\"\n    a = o.A_ref()\n    assert a.value == \"hi\"",
        "detail": "pybind11.tests.test_virtual_functions",
        "documentation": {}
    },
    {
        "label": "test_inherited_virtuals",
        "kind": 2,
        "importPath": "pybind11.tests.test_virtual_functions",
        "description": "pybind11.tests.test_virtual_functions",
        "peekOfCode": "def test_inherited_virtuals():\n    class AR(m.A_Repeat):\n        def unlucky_number(self):\n            return 99\n    class AT(m.A_Tpl):\n        def unlucky_number(self):\n            return 999\n    obj = AR()\n    assert obj.say_something(3) == \"hihihi\"\n    assert obj.unlucky_number() == 99",
        "detail": "pybind11.tests.test_virtual_functions",
        "documentation": {}
    },
    {
        "label": "test_issue_1454",
        "kind": 2,
        "importPath": "pybind11.tests.test_virtual_functions",
        "description": "pybind11.tests.test_virtual_functions",
        "peekOfCode": "def test_issue_1454():\n    # Fix issue #1454 (crash when acquiring/releasing GIL on another thread in Python 2.7)\n    m.test_gil()\n    m.test_gil_from_thread()",
        "detail": "pybind11.tests.test_virtual_functions",
        "documentation": {}
    },
    {
        "label": "TranslationUnitLoadError",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class TranslationUnitLoadError(Exception):\n    \"\"\"Represents an error that occurred when loading a TranslationUnit.\n    This is raised in the case where a TranslationUnit could not be\n    instantiated due to failure in the libclang library.\n    FIXME: Make libclang expose additional error information in this scenario.\n    \"\"\"\n    pass\nclass TranslationUnitSaveError(Exception):\n    \"\"\"Represents an error that occurred when saving a TranslationUnit.\n    Each error has associated with it an enumerated value, accessible under",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TranslationUnitSaveError",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class TranslationUnitSaveError(Exception):\n    \"\"\"Represents an error that occurred when saving a TranslationUnit.\n    Each error has associated with it an enumerated value, accessible under\n    e.save_error. Consumers can compare the value with one of the ERROR_\n    constants in this class.\n    \"\"\"\n    # Indicates that an unknown error occurred. This typically indicates that\n    # I/O failed during save.\n    ERROR_UNKNOWN = 1\n    # Indicates that errors during translation prevented saving. The errors",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CachedProperty",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CachedProperty(object):\n    \"\"\"Decorator that lazy-loads the value of a property.\n    The first time the property is accessed, the original property function is\n    executed. The value it returns is set as the new value of that instance's\n    property, replacing the original method.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        try:\n            self.__doc__ = wrapped.__doc__",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "_CXString",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class _CXString(Structure):\n    \"\"\"Helper for transforming CXString results.\"\"\"\n    _fields_ = [(\"spelling\", c_char_p), (\"free\", c_int)]\n    def __del__(self):\n        conf.lib.clang_disposeString(self)\n    @staticmethod\n    def from_result(res, fn, args):\n        assert isinstance(res, _CXString)\n        return conf.lib.clang_getCString(res)\nclass SourceLocation(Structure):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "SourceLocation",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class SourceLocation(Structure):\n    \"\"\"\n    A SourceLocation represents a particular location within a source file.\n    \"\"\"\n    _fields_ = [(\"ptr_data\", c_void_p * 2), (\"int_data\", c_uint)]\n    _data = None\n    def _get_instantiation(self):\n        if self._data is None:\n            f, l, c, o = c_object_p(), c_uint(), c_uint(), c_uint()\n            conf.lib.clang_getInstantiationLocation(self, byref(f), byref(l),",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "SourceRange",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class SourceRange(Structure):\n    \"\"\"\n    A SourceRange describes a range of source locations within the source\n    code.\n    \"\"\"\n    _fields_ = [\n        (\"ptr_data\", c_void_p * 2),\n        (\"begin_int_data\", c_uint),\n        (\"end_int_data\", c_uint)]\n    # FIXME: Eliminate this and make normal constructor? Requires hiding ctypes",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "Diagnostic",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class Diagnostic(object):\n    \"\"\"\n    A Diagnostic is a single instance of a Clang diagnostic. It includes the\n    diagnostic severity, the message, the location the diagnostic occurred, as\n    well as additional source ranges and associated fix-it hints.\n    \"\"\"\n    Ignored = 0\n    Note    = 1\n    Warning = 2\n    Error   = 3",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "FixIt",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class FixIt(object):\n    \"\"\"\n    A FixIt represents a transformation to be applied to the source to\n    \"fix-it\". The fix-it shouldbe applied by replacing the given source range\n    with the given value.\n    \"\"\"\n    def __init__(self, range, value):\n        self.range = range\n        self.value = value\n    def __repr__(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TokenGroup",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class TokenGroup(object):\n    \"\"\"Helper class to facilitate token management.\n    Tokens are allocated from libclang in chunks. They must be disposed of as a\n    collective group.\n    One purpose of this class is for instances to represent groups of allocated\n    tokens. Each token in a group contains a reference back to an instance of\n    this class. When all tokens from a group are garbage collected, it allows\n    this class to be garbage collected. When this class is garbage collected,\n    it calls the libclang destructor which invalidates all tokens in the group.\n    You should not instantiate this class outside of this module.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TokenKind",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class TokenKind(object):\n    \"\"\"Describes a specific type of a Token.\"\"\"\n    _value_map = {} # int -> TokenKind\n    def __init__(self, value, name):\n        \"\"\"Create a new TokenKind instance from a numeric value and a name.\"\"\"\n        self.value = value\n        self.name = name\n    def __repr__(self):\n        return 'TokenKind.%s' % (self.name,)\n    @staticmethod",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "BaseEnumeration",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class BaseEnumeration(object):\n    \"\"\"\n    Common base class for named enumerations held in sync with Index.h values.\n    Subclasses must define their own _kinds and _name_map members, as:\n    _kinds = []\n    _name_map = None\n    These values hold the per-subclass instances and value-to-name mappings,\n    respectively.\n    \"\"\"\n    def __init__(self, value):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CursorKind(BaseEnumeration):\n    \"\"\"\n    A CursorKind describes the kind of entity that a cursor points to.\n    \"\"\"\n    # The required BaseEnumeration declarations.\n    _kinds = []\n    _name_map = None\n    @staticmethod\n    def get_all_kinds():\n        \"\"\"Return all CursorKind enumeration instances.\"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TemplateArgumentKind",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class TemplateArgumentKind(BaseEnumeration):\n    \"\"\"\n    A TemplateArgumentKind describes the kind of entity that a template argument\n    represents.\n    \"\"\"\n    # The required BaseEnumeration declarations.\n    _kinds = []\n    _name_map = None\nTemplateArgumentKind.NULL = TemplateArgumentKind(0)\nTemplateArgumentKind.TYPE = TemplateArgumentKind(1)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "Cursor",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class Cursor(Structure):\n    \"\"\"\n    The Cursor class represents a reference to an element within the AST. It\n    acts as a kind of iterator.\n    \"\"\"\n    _fields_ = [(\"_kind_id\", c_int), (\"xdata\", c_int), (\"data\", c_void_p * 3)]\n    @staticmethod\n    def from_location(tu, location):\n        # We store a reference to the TU in the instance so the TU won't get\n        # collected before the cursor.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class StorageClass(object):\n    \"\"\"\n    Describes the storage class of a declaration\n    \"\"\"\n    # The unique kind objects, index by id.\n    _kinds = []\n    _name_map = None\n    def __init__(self, value):\n        if value >= len(StorageClass._kinds):\n            StorageClass._kinds += [None] * (value - len(StorageClass._kinds) + 1)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "AccessSpecifier",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class AccessSpecifier(BaseEnumeration):\n    \"\"\"\n    Describes the access of a C++ class member\n    \"\"\"\n    # The unique kind objects, index by id.\n    _kinds = []\n    _name_map = None\n    def from_param(self):\n        return self.value\n    def __repr__(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class TypeKind(BaseEnumeration):\n    \"\"\"\n    Describes the kind of type.\n    \"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None\n    @property\n    def spelling(self):\n        \"\"\"Retrieve the spelling of this TypeKind.\"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "RefQualifierKind",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None\n    def from_param(self):\n        return self.value\n    def __repr__(self):\n        return 'RefQualifierKind.%s' % (self.name,)\nRefQualifierKind.NONE = RefQualifierKind(0)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "Type",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class Type(Structure):\n    \"\"\"\n    The type of an element in the abstract syntax tree.\n    \"\"\"\n    _fields_ = [(\"_kind_id\", c_int), (\"data\", c_void_p * 2)]\n    @property\n    def kind(self):\n        \"\"\"Return the kind of this type.\"\"\"\n        return TypeKind.from_id(self._kind_id)\n    def argument_types(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "ClangObject",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class ClangObject(object):\n    \"\"\"\n    A helper for Clang objects. This class helps act as an intermediary for\n    the ctypes library and the Clang CIndex library.\n    \"\"\"\n    def __init__(self, obj):\n        assert isinstance(obj, c_object_p) and obj\n        self.obj = self._as_parameter_ = obj\n    def from_param(self):\n        return self._as_parameter_",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "_CXUnsavedFile",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class _CXUnsavedFile(Structure):\n    \"\"\"Helper for passing unsaved file arguments.\"\"\"\n    _fields_ = [(\"name\", c_char_p), (\"contents\", c_char_p), ('length', c_ulong)]\n# Functions calls through the python interface are rather slow. Fortunately,\n# for most symboles, we do not need to perform a function call. Their spelling\n# never changes and is consequently provided by this spelling cache.\nSpellingCache = {\n            # 0: CompletionChunk.Kind(\"Optional\"),\n            # 1: CompletionChunk.Kind(\"TypedText\"),\n            # 2: CompletionChunk.Kind(\"Text\"),",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CompletionChunk",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CompletionChunk:\n    class Kind:\n        def __init__(self, name):\n            self.name = name\n        def __str__(self):\n            return self.name\n        def __repr__(self):\n            return \"<ChunkKind: %s>\" % self\n    def __init__(self, completionString, key):\n        self.cs = completionString",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CompletionString",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CompletionString(ClangObject):\n    class Availability:\n        def __init__(self, name):\n            self.name = name\n        def __str__(self):\n            return self.name\n        def __repr__(self):\n            return \"<Availability: %s>\" % self\n    def __len__(self):\n        return self.num_chunks",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CodeCompletionResult",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CodeCompletionResult(Structure):\n    _fields_ = [('cursorKind', c_int), ('completionString', c_object_p)]\n    def __repr__(self):\n        return str(CompletionString(self.completionString))\n    @property\n    def kind(self):\n        return CursorKind.from_id(self.cursorKind)\n    @property\n    def string(self):\n        return CompletionString(self.completionString)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CCRStructure",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CCRStructure(Structure):\n    _fields_ = [('results', POINTER(CodeCompletionResult)),\n                ('numResults', c_int)]\n    def __len__(self):\n        return self.numResults\n    def __getitem__(self, key):\n        if len(self) <= key:\n            raise IndexError\n        return self.results[key]\nclass CodeCompletionResults(ClangObject):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CodeCompletionResults",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CodeCompletionResults(ClangObject):\n    def __init__(self, ptr):\n        assert isinstance(ptr, POINTER(CCRStructure)) and ptr\n        self.ptr = self._as_parameter_ = ptr\n    def from_param(self):\n        return self._as_parameter_\n    def __del__(self):\n        conf.lib.clang_disposeCodeCompleteResults(self)\n    @property\n    def results(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "Index",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class Index(ClangObject):\n    \"\"\"\n    The Index type provides the primary interface to the Clang CIndex library,\n    primarily by providing an interface for reading and parsing translation\n    units.\n    \"\"\"\n    @staticmethod\n    def create(excludeDecls=False):\n        \"\"\"\n        Create a new Index.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TranslationUnit",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class TranslationUnit(ClangObject):\n    \"\"\"Represents a source code translation unit.\n    This is one of the main types in the API. Any time you wish to interact\n    with Clang's representation of a source file, you typically start with a\n    translation unit.\n    \"\"\"\n    # Default parsing mode.\n    PARSE_NONE = 0\n    # Instruct the parser to create a detailed processing record containing\n    # metadata not normally retained.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "File",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class File(ClangObject):\n    \"\"\"\n    The File class represents a particular source file that is part of a\n    translation unit.\n    \"\"\"\n    @staticmethod\n    def from_name(translation_unit, file_name):\n        \"\"\"Retrieve a file handle within the given translation unit.\"\"\"\n        return File(conf.lib.clang_getFile(translation_unit, file_name))\n    @property",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "FileInclusion",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class FileInclusion(object):\n    \"\"\"\n    The FileInclusion class represents the inclusion of one source file by\n    another via a '#include' directive or as the input file for the translation\n    unit. This class provides information about the included file, the including\n    file, the location of the '#include' directive and the depth of the included\n    file in the stack. Note that the input file has depth 0.\n    \"\"\"\n    def __init__(self, src, tgt, loc, depth):\n        self.source = src",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CompilationDatabaseError",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CompilationDatabaseError(Exception):\n    \"\"\"Represents an error that occurred when working with a CompilationDatabase\n    Each error is associated to an enumerated value, accessible under\n    e.cdb_error. Consumers can compare the value with one of the ERROR_\n    constants in this class.\n    \"\"\"\n    # An unknown error occurred\n    ERROR_UNKNOWN = 0\n    # The database could not be loaded\n    ERROR_CANNOTLOADDATABASE = 1",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CompileCommand",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CompileCommand(object):\n    \"\"\"Represents the compile command used to build a file\"\"\"\n    def __init__(self, cmd, ccmds):\n        self.cmd = cmd\n        # Keep a reference to the originating CompileCommands\n        # to prevent garbage collection\n        self.ccmds = ccmds\n    @property\n    def directory(self):\n        \"\"\"Get the working directory for this CompileCommand\"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CompileCommands",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CompileCommands(object):\n    \"\"\"\n    CompileCommands is an iterable object containing all CompileCommand\n    that can be used for building a specific file.\n    \"\"\"\n    def __init__(self, ccmds):\n        self.ccmds = ccmds\n    def __del__(self):\n        conf.lib.clang_CompileCommands_dispose(self.ccmds)\n    def __len__(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CompilationDatabase",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class CompilationDatabase(ClangObject):\n    \"\"\"\n    The CompilationDatabase is a wrapper class around\n    clang::tooling::CompilationDatabase\n    It enables querying how a specific source file can be built.\n    \"\"\"\n    def __del__(self):\n        conf.lib.clang_CompilationDatabase_dispose(self)\n    @staticmethod\n    def from_result(res, fn, args):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class Token(Structure):\n    \"\"\"Represents a single token from the preprocessor.\n    Tokens are effectively segments of source code. Source code is first parsed\n    into tokens before being converted into the AST and Cursors.\n    Tokens are obtained from parsed TranslationUnit instances. You currently\n    can't create tokens manually.\n    \"\"\"\n    _fields_ = [\n        ('int_data', c_uint * 4),\n        ('ptr_data', c_void_p)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "LibclangError",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class LibclangError(Exception):\n    def __init__(self, message):\n        self.m = message\n    def __str__(self):\n        return self.m\ndef register_function(lib, item, ignore_errors):\n    # A function may not exist, if these bindings are used with an older or\n    # incompatible version of libclang.so.\n    try:\n        func = getattr(lib, item[0])",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "class Config:\n    library_path = None\n    library_file = None\n    compatibility_check = False\n    loaded = False\n    @staticmethod\n    def set_library_path(path):\n        \"\"\"Set the path in which to search for libclang\"\"\"\n        if Config.loaded:\n            raise Exception(\"library path must be set before before using \" \\",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "register_function",
        "kind": 2,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "def register_function(lib, item, ignore_errors):\n    # A function may not exist, if these bindings are used with an older or\n    # incompatible version of libclang.so.\n    try:\n        func = getattr(lib, item[0])\n    except AttributeError as e:\n        msg = str(e) + \". Please ensure that your python bindings are \"\\\n                       \"compatible with your libclang.so version.\"\n        if ignore_errors:\n            return",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "register_functions",
        "kind": 2,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "def register_functions(lib, ignore_errors):\n    \"\"\"Register function prototypes with a libclang library instance.\n    This must be called as part of library instantiation so Python knows how\n    to call out to the shared library.\n    \"\"\"\n    def register(item):\n        return register_function(lib, item, ignore_errors)\n    for f in functionList:\n        register(f)\nclass Config:",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "register_enumerations",
        "kind": 2,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "def register_enumerations():\n    for name, value in clang.enumerations.TokenKinds:\n        TokenKind.register(value, name)\nconf = Config()\nregister_enumerations()\n__all__ = [\n    'Config',\n    'CodeCompletionResults',\n    'CompilationDatabase',\n    'CompileCommands',",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "c_object_p",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "c_object_p = POINTER(c_void_p)\ncallbacks = {}\n### Exception Classes ###\nclass TranslationUnitLoadError(Exception):\n    \"\"\"Represents an error that occurred when loading a TranslationUnit.\n    This is raised in the case where a TranslationUnit could not be\n    instantiated due to failure in the libclang library.\n    FIXME: Make libclang expose additional error information in this scenario.\n    \"\"\"\n    pass",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "callbacks = {}\n### Exception Classes ###\nclass TranslationUnitLoadError(Exception):\n    \"\"\"Represents an error that occurred when loading a TranslationUnit.\n    This is raised in the case where a TranslationUnit could not be\n    instantiated due to failure in the libclang library.\n    FIXME: Make libclang expose additional error information in this scenario.\n    \"\"\"\n    pass\nclass TranslationUnitSaveError(Exception):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.UNEXPOSED_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.UNEXPOSED_DECL = CursorKind(1)\n# A C or C++ struct.\nCursorKind.STRUCT_DECL = CursorKind(2)\n# A C or C++ union.\nCursorKind.UNION_DECL = CursorKind(3)\n# A C++ class.\nCursorKind.CLASS_DECL = CursorKind(4)\n# An enumeration.\nCursorKind.ENUM_DECL = CursorKind(5)\n# A field (in C) or non-static data member (in C++) in a struct, union, or C++",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.STRUCT_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.STRUCT_DECL = CursorKind(2)\n# A C or C++ union.\nCursorKind.UNION_DECL = CursorKind(3)\n# A C++ class.\nCursorKind.CLASS_DECL = CursorKind(4)\n# An enumeration.\nCursorKind.ENUM_DECL = CursorKind(5)\n# A field (in C) or non-static data member (in C++) in a struct, union, or C++\n# class.\nCursorKind.FIELD_DECL = CursorKind(6)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.UNION_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.UNION_DECL = CursorKind(3)\n# A C++ class.\nCursorKind.CLASS_DECL = CursorKind(4)\n# An enumeration.\nCursorKind.ENUM_DECL = CursorKind(5)\n# A field (in C) or non-static data member (in C++) in a struct, union, or C++\n# class.\nCursorKind.FIELD_DECL = CursorKind(6)\n# An enumerator constant.\nCursorKind.ENUM_CONSTANT_DECL = CursorKind(7)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CLASS_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CLASS_DECL = CursorKind(4)\n# An enumeration.\nCursorKind.ENUM_DECL = CursorKind(5)\n# A field (in C) or non-static data member (in C++) in a struct, union, or C++\n# class.\nCursorKind.FIELD_DECL = CursorKind(6)\n# An enumerator constant.\nCursorKind.ENUM_CONSTANT_DECL = CursorKind(7)\n# A function.\nCursorKind.FUNCTION_DECL = CursorKind(8)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.ENUM_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.ENUM_DECL = CursorKind(5)\n# A field (in C) or non-static data member (in C++) in a struct, union, or C++\n# class.\nCursorKind.FIELD_DECL = CursorKind(6)\n# An enumerator constant.\nCursorKind.ENUM_CONSTANT_DECL = CursorKind(7)\n# A function.\nCursorKind.FUNCTION_DECL = CursorKind(8)\n# A variable.\nCursorKind.VAR_DECL = CursorKind(9)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.FIELD_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.FIELD_DECL = CursorKind(6)\n# An enumerator constant.\nCursorKind.ENUM_CONSTANT_DECL = CursorKind(7)\n# A function.\nCursorKind.FUNCTION_DECL = CursorKind(8)\n# A variable.\nCursorKind.VAR_DECL = CursorKind(9)\n# A function or method parameter.\nCursorKind.PARM_DECL = CursorKind(10)\n# An Objective-C @interface.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.ENUM_CONSTANT_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.ENUM_CONSTANT_DECL = CursorKind(7)\n# A function.\nCursorKind.FUNCTION_DECL = CursorKind(8)\n# A variable.\nCursorKind.VAR_DECL = CursorKind(9)\n# A function or method parameter.\nCursorKind.PARM_DECL = CursorKind(10)\n# An Objective-C @interface.\nCursorKind.OBJC_INTERFACE_DECL = CursorKind(11)\n# An Objective-C @interface for a category.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.FUNCTION_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.FUNCTION_DECL = CursorKind(8)\n# A variable.\nCursorKind.VAR_DECL = CursorKind(9)\n# A function or method parameter.\nCursorKind.PARM_DECL = CursorKind(10)\n# An Objective-C @interface.\nCursorKind.OBJC_INTERFACE_DECL = CursorKind(11)\n# An Objective-C @interface for a category.\nCursorKind.OBJC_CATEGORY_DECL = CursorKind(12)\n# An Objective-C @protocol declaration.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.VAR_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.VAR_DECL = CursorKind(9)\n# A function or method parameter.\nCursorKind.PARM_DECL = CursorKind(10)\n# An Objective-C @interface.\nCursorKind.OBJC_INTERFACE_DECL = CursorKind(11)\n# An Objective-C @interface for a category.\nCursorKind.OBJC_CATEGORY_DECL = CursorKind(12)\n# An Objective-C @protocol declaration.\nCursorKind.OBJC_PROTOCOL_DECL = CursorKind(13)\n# An Objective-C @property declaration.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.PARM_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.PARM_DECL = CursorKind(10)\n# An Objective-C @interface.\nCursorKind.OBJC_INTERFACE_DECL = CursorKind(11)\n# An Objective-C @interface for a category.\nCursorKind.OBJC_CATEGORY_DECL = CursorKind(12)\n# An Objective-C @protocol declaration.\nCursorKind.OBJC_PROTOCOL_DECL = CursorKind(13)\n# An Objective-C @property declaration.\nCursorKind.OBJC_PROPERTY_DECL = CursorKind(14)\n# An Objective-C instance variable.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_INTERFACE_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_INTERFACE_DECL = CursorKind(11)\n# An Objective-C @interface for a category.\nCursorKind.OBJC_CATEGORY_DECL = CursorKind(12)\n# An Objective-C @protocol declaration.\nCursorKind.OBJC_PROTOCOL_DECL = CursorKind(13)\n# An Objective-C @property declaration.\nCursorKind.OBJC_PROPERTY_DECL = CursorKind(14)\n# An Objective-C instance variable.\nCursorKind.OBJC_IVAR_DECL = CursorKind(15)\n# An Objective-C instance method.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_CATEGORY_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_CATEGORY_DECL = CursorKind(12)\n# An Objective-C @protocol declaration.\nCursorKind.OBJC_PROTOCOL_DECL = CursorKind(13)\n# An Objective-C @property declaration.\nCursorKind.OBJC_PROPERTY_DECL = CursorKind(14)\n# An Objective-C instance variable.\nCursorKind.OBJC_IVAR_DECL = CursorKind(15)\n# An Objective-C instance method.\nCursorKind.OBJC_INSTANCE_METHOD_DECL = CursorKind(16)\n# An Objective-C class method.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_PROTOCOL_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_PROTOCOL_DECL = CursorKind(13)\n# An Objective-C @property declaration.\nCursorKind.OBJC_PROPERTY_DECL = CursorKind(14)\n# An Objective-C instance variable.\nCursorKind.OBJC_IVAR_DECL = CursorKind(15)\n# An Objective-C instance method.\nCursorKind.OBJC_INSTANCE_METHOD_DECL = CursorKind(16)\n# An Objective-C class method.\nCursorKind.OBJC_CLASS_METHOD_DECL = CursorKind(17)\n# An Objective-C @implementation.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_PROPERTY_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_PROPERTY_DECL = CursorKind(14)\n# An Objective-C instance variable.\nCursorKind.OBJC_IVAR_DECL = CursorKind(15)\n# An Objective-C instance method.\nCursorKind.OBJC_INSTANCE_METHOD_DECL = CursorKind(16)\n# An Objective-C class method.\nCursorKind.OBJC_CLASS_METHOD_DECL = CursorKind(17)\n# An Objective-C @implementation.\nCursorKind.OBJC_IMPLEMENTATION_DECL = CursorKind(18)\n# An Objective-C @implementation for a category.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_IVAR_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_IVAR_DECL = CursorKind(15)\n# An Objective-C instance method.\nCursorKind.OBJC_INSTANCE_METHOD_DECL = CursorKind(16)\n# An Objective-C class method.\nCursorKind.OBJC_CLASS_METHOD_DECL = CursorKind(17)\n# An Objective-C @implementation.\nCursorKind.OBJC_IMPLEMENTATION_DECL = CursorKind(18)\n# An Objective-C @implementation for a category.\nCursorKind.OBJC_CATEGORY_IMPL_DECL = CursorKind(19)\n# A typedef.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_INSTANCE_METHOD_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_INSTANCE_METHOD_DECL = CursorKind(16)\n# An Objective-C class method.\nCursorKind.OBJC_CLASS_METHOD_DECL = CursorKind(17)\n# An Objective-C @implementation.\nCursorKind.OBJC_IMPLEMENTATION_DECL = CursorKind(18)\n# An Objective-C @implementation for a category.\nCursorKind.OBJC_CATEGORY_IMPL_DECL = CursorKind(19)\n# A typedef.\nCursorKind.TYPEDEF_DECL = CursorKind(20)\n# A C++ class method.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_CLASS_METHOD_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_CLASS_METHOD_DECL = CursorKind(17)\n# An Objective-C @implementation.\nCursorKind.OBJC_IMPLEMENTATION_DECL = CursorKind(18)\n# An Objective-C @implementation for a category.\nCursorKind.OBJC_CATEGORY_IMPL_DECL = CursorKind(19)\n# A typedef.\nCursorKind.TYPEDEF_DECL = CursorKind(20)\n# A C++ class method.\nCursorKind.CXX_METHOD = CursorKind(21)\n# A C++ namespace.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_IMPLEMENTATION_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_IMPLEMENTATION_DECL = CursorKind(18)\n# An Objective-C @implementation for a category.\nCursorKind.OBJC_CATEGORY_IMPL_DECL = CursorKind(19)\n# A typedef.\nCursorKind.TYPEDEF_DECL = CursorKind(20)\n# A C++ class method.\nCursorKind.CXX_METHOD = CursorKind(21)\n# A C++ namespace.\nCursorKind.NAMESPACE = CursorKind(22)\n# A linkage specification, e.g. 'extern \"C\"'.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_CATEGORY_IMPL_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_CATEGORY_IMPL_DECL = CursorKind(19)\n# A typedef.\nCursorKind.TYPEDEF_DECL = CursorKind(20)\n# A C++ class method.\nCursorKind.CXX_METHOD = CursorKind(21)\n# A C++ namespace.\nCursorKind.NAMESPACE = CursorKind(22)\n# A linkage specification, e.g. 'extern \"C\"'.\nCursorKind.LINKAGE_SPEC = CursorKind(23)\n# A C++ constructor.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TYPEDEF_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TYPEDEF_DECL = CursorKind(20)\n# A C++ class method.\nCursorKind.CXX_METHOD = CursorKind(21)\n# A C++ namespace.\nCursorKind.NAMESPACE = CursorKind(22)\n# A linkage specification, e.g. 'extern \"C\"'.\nCursorKind.LINKAGE_SPEC = CursorKind(23)\n# A C++ constructor.\nCursorKind.CONSTRUCTOR = CursorKind(24)\n# A C++ destructor.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_METHOD",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_METHOD = CursorKind(21)\n# A C++ namespace.\nCursorKind.NAMESPACE = CursorKind(22)\n# A linkage specification, e.g. 'extern \"C\"'.\nCursorKind.LINKAGE_SPEC = CursorKind(23)\n# A C++ constructor.\nCursorKind.CONSTRUCTOR = CursorKind(24)\n# A C++ destructor.\nCursorKind.DESTRUCTOR = CursorKind(25)\n# A C++ conversion function.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.NAMESPACE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.NAMESPACE = CursorKind(22)\n# A linkage specification, e.g. 'extern \"C\"'.\nCursorKind.LINKAGE_SPEC = CursorKind(23)\n# A C++ constructor.\nCursorKind.CONSTRUCTOR = CursorKind(24)\n# A C++ destructor.\nCursorKind.DESTRUCTOR = CursorKind(25)\n# A C++ conversion function.\nCursorKind.CONVERSION_FUNCTION = CursorKind(26)\n# A C++ template type parameter",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.LINKAGE_SPEC",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.LINKAGE_SPEC = CursorKind(23)\n# A C++ constructor.\nCursorKind.CONSTRUCTOR = CursorKind(24)\n# A C++ destructor.\nCursorKind.DESTRUCTOR = CursorKind(25)\n# A C++ conversion function.\nCursorKind.CONVERSION_FUNCTION = CursorKind(26)\n# A C++ template type parameter\nCursorKind.TEMPLATE_TYPE_PARAMETER = CursorKind(27)\n# A C++ non-type template paramater.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CONSTRUCTOR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CONSTRUCTOR = CursorKind(24)\n# A C++ destructor.\nCursorKind.DESTRUCTOR = CursorKind(25)\n# A C++ conversion function.\nCursorKind.CONVERSION_FUNCTION = CursorKind(26)\n# A C++ template type parameter\nCursorKind.TEMPLATE_TYPE_PARAMETER = CursorKind(27)\n# A C++ non-type template paramater.\nCursorKind.TEMPLATE_NON_TYPE_PARAMETER = CursorKind(28)\n# A C++ template template parameter.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.DESTRUCTOR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.DESTRUCTOR = CursorKind(25)\n# A C++ conversion function.\nCursorKind.CONVERSION_FUNCTION = CursorKind(26)\n# A C++ template type parameter\nCursorKind.TEMPLATE_TYPE_PARAMETER = CursorKind(27)\n# A C++ non-type template paramater.\nCursorKind.TEMPLATE_NON_TYPE_PARAMETER = CursorKind(28)\n# A C++ template template parameter.\nCursorKind.TEMPLATE_TEMPLATE_PARAMETER = CursorKind(29)\n# A C++ function template.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CONVERSION_FUNCTION",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CONVERSION_FUNCTION = CursorKind(26)\n# A C++ template type parameter\nCursorKind.TEMPLATE_TYPE_PARAMETER = CursorKind(27)\n# A C++ non-type template paramater.\nCursorKind.TEMPLATE_NON_TYPE_PARAMETER = CursorKind(28)\n# A C++ template template parameter.\nCursorKind.TEMPLATE_TEMPLATE_PARAMETER = CursorKind(29)\n# A C++ function template.\nCursorKind.FUNCTION_TEMPLATE = CursorKind(30)\n# A C++ class template.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TEMPLATE_TYPE_PARAMETER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TEMPLATE_TYPE_PARAMETER = CursorKind(27)\n# A C++ non-type template paramater.\nCursorKind.TEMPLATE_NON_TYPE_PARAMETER = CursorKind(28)\n# A C++ template template parameter.\nCursorKind.TEMPLATE_TEMPLATE_PARAMETER = CursorKind(29)\n# A C++ function template.\nCursorKind.FUNCTION_TEMPLATE = CursorKind(30)\n# A C++ class template.\nCursorKind.CLASS_TEMPLATE = CursorKind(31)\n# A C++ class template partial specialization.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TEMPLATE_NON_TYPE_PARAMETER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TEMPLATE_NON_TYPE_PARAMETER = CursorKind(28)\n# A C++ template template parameter.\nCursorKind.TEMPLATE_TEMPLATE_PARAMETER = CursorKind(29)\n# A C++ function template.\nCursorKind.FUNCTION_TEMPLATE = CursorKind(30)\n# A C++ class template.\nCursorKind.CLASS_TEMPLATE = CursorKind(31)\n# A C++ class template partial specialization.\nCursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION = CursorKind(32)\n# A C++ namespace alias declaration.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TEMPLATE_TEMPLATE_PARAMETER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TEMPLATE_TEMPLATE_PARAMETER = CursorKind(29)\n# A C++ function template.\nCursorKind.FUNCTION_TEMPLATE = CursorKind(30)\n# A C++ class template.\nCursorKind.CLASS_TEMPLATE = CursorKind(31)\n# A C++ class template partial specialization.\nCursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION = CursorKind(32)\n# A C++ namespace alias declaration.\nCursorKind.NAMESPACE_ALIAS = CursorKind(33)\n# A C++ using directive",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.FUNCTION_TEMPLATE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.FUNCTION_TEMPLATE = CursorKind(30)\n# A C++ class template.\nCursorKind.CLASS_TEMPLATE = CursorKind(31)\n# A C++ class template partial specialization.\nCursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION = CursorKind(32)\n# A C++ namespace alias declaration.\nCursorKind.NAMESPACE_ALIAS = CursorKind(33)\n# A C++ using directive\nCursorKind.USING_DIRECTIVE = CursorKind(34)\n# A C++ using declaration",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CLASS_TEMPLATE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CLASS_TEMPLATE = CursorKind(31)\n# A C++ class template partial specialization.\nCursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION = CursorKind(32)\n# A C++ namespace alias declaration.\nCursorKind.NAMESPACE_ALIAS = CursorKind(33)\n# A C++ using directive\nCursorKind.USING_DIRECTIVE = CursorKind(34)\n# A C++ using declaration\nCursorKind.USING_DECLARATION = CursorKind(35)\n# A Type alias decl.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION = CursorKind(32)\n# A C++ namespace alias declaration.\nCursorKind.NAMESPACE_ALIAS = CursorKind(33)\n# A C++ using directive\nCursorKind.USING_DIRECTIVE = CursorKind(34)\n# A C++ using declaration\nCursorKind.USING_DECLARATION = CursorKind(35)\n# A Type alias decl.\nCursorKind.TYPE_ALIAS_DECL = CursorKind(36)\n# A Objective-C synthesize decl",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.NAMESPACE_ALIAS",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.NAMESPACE_ALIAS = CursorKind(33)\n# A C++ using directive\nCursorKind.USING_DIRECTIVE = CursorKind(34)\n# A C++ using declaration\nCursorKind.USING_DECLARATION = CursorKind(35)\n# A Type alias decl.\nCursorKind.TYPE_ALIAS_DECL = CursorKind(36)\n# A Objective-C synthesize decl\nCursorKind.OBJC_SYNTHESIZE_DECL = CursorKind(37)\n# A Objective-C dynamic decl",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.USING_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.USING_DIRECTIVE = CursorKind(34)\n# A C++ using declaration\nCursorKind.USING_DECLARATION = CursorKind(35)\n# A Type alias decl.\nCursorKind.TYPE_ALIAS_DECL = CursorKind(36)\n# A Objective-C synthesize decl\nCursorKind.OBJC_SYNTHESIZE_DECL = CursorKind(37)\n# A Objective-C dynamic decl\nCursorKind.OBJC_DYNAMIC_DECL = CursorKind(38)\n# A C++ access specifier decl.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.USING_DECLARATION",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.USING_DECLARATION = CursorKind(35)\n# A Type alias decl.\nCursorKind.TYPE_ALIAS_DECL = CursorKind(36)\n# A Objective-C synthesize decl\nCursorKind.OBJC_SYNTHESIZE_DECL = CursorKind(37)\n# A Objective-C dynamic decl\nCursorKind.OBJC_DYNAMIC_DECL = CursorKind(38)\n# A C++ access specifier decl.\nCursorKind.CXX_ACCESS_SPEC_DECL = CursorKind(39)\n###",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TYPE_ALIAS_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TYPE_ALIAS_DECL = CursorKind(36)\n# A Objective-C synthesize decl\nCursorKind.OBJC_SYNTHESIZE_DECL = CursorKind(37)\n# A Objective-C dynamic decl\nCursorKind.OBJC_DYNAMIC_DECL = CursorKind(38)\n# A C++ access specifier decl.\nCursorKind.CXX_ACCESS_SPEC_DECL = CursorKind(39)\n###\n# Reference Kinds\nCursorKind.OBJC_SUPER_CLASS_REF = CursorKind(40)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_SYNTHESIZE_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_SYNTHESIZE_DECL = CursorKind(37)\n# A Objective-C dynamic decl\nCursorKind.OBJC_DYNAMIC_DECL = CursorKind(38)\n# A C++ access specifier decl.\nCursorKind.CXX_ACCESS_SPEC_DECL = CursorKind(39)\n###\n# Reference Kinds\nCursorKind.OBJC_SUPER_CLASS_REF = CursorKind(40)\nCursorKind.OBJC_PROTOCOL_REF = CursorKind(41)\nCursorKind.OBJC_CLASS_REF = CursorKind(42)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_DYNAMIC_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_DYNAMIC_DECL = CursorKind(38)\n# A C++ access specifier decl.\nCursorKind.CXX_ACCESS_SPEC_DECL = CursorKind(39)\n###\n# Reference Kinds\nCursorKind.OBJC_SUPER_CLASS_REF = CursorKind(40)\nCursorKind.OBJC_PROTOCOL_REF = CursorKind(41)\nCursorKind.OBJC_CLASS_REF = CursorKind(42)\n# A reference to a type declaration.\n#",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_ACCESS_SPEC_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_ACCESS_SPEC_DECL = CursorKind(39)\n###\n# Reference Kinds\nCursorKind.OBJC_SUPER_CLASS_REF = CursorKind(40)\nCursorKind.OBJC_PROTOCOL_REF = CursorKind(41)\nCursorKind.OBJC_CLASS_REF = CursorKind(42)\n# A reference to a type declaration.\n#\n# A type reference occurs anywhere where a type is named but not\n# declared. For example, given:",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_SUPER_CLASS_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_SUPER_CLASS_REF = CursorKind(40)\nCursorKind.OBJC_PROTOCOL_REF = CursorKind(41)\nCursorKind.OBJC_CLASS_REF = CursorKind(42)\n# A reference to a type declaration.\n#\n# A type reference occurs anywhere where a type is named but not\n# declared. For example, given:\n#   typedef unsigned size_type;\n#   size_type size;\n#",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_PROTOCOL_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_PROTOCOL_REF = CursorKind(41)\nCursorKind.OBJC_CLASS_REF = CursorKind(42)\n# A reference to a type declaration.\n#\n# A type reference occurs anywhere where a type is named but not\n# declared. For example, given:\n#   typedef unsigned size_type;\n#   size_type size;\n#\n# The typedef is a declaration of size_type (CXCursor_TypedefDecl),",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_CLASS_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_CLASS_REF = CursorKind(42)\n# A reference to a type declaration.\n#\n# A type reference occurs anywhere where a type is named but not\n# declared. For example, given:\n#   typedef unsigned size_type;\n#   size_type size;\n#\n# The typedef is a declaration of size_type (CXCursor_TypedefDecl),\n# while the type of the variable \"size\" is referenced. The cursor",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TYPE_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TYPE_REF = CursorKind(43)\nCursorKind.CXX_BASE_SPECIFIER = CursorKind(44)\n# A reference to a class template, function template, template\n# template parameter, or class template partial specialization.\nCursorKind.TEMPLATE_REF = CursorKind(45)\n# A reference to a namespace or namepsace alias.\nCursorKind.NAMESPACE_REF = CursorKind(46)\n# A reference to a member of a struct, union, or class that occurs in\n# some non-expression context, e.g., a designated initializer.\nCursorKind.MEMBER_REF = CursorKind(47)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_BASE_SPECIFIER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_BASE_SPECIFIER = CursorKind(44)\n# A reference to a class template, function template, template\n# template parameter, or class template partial specialization.\nCursorKind.TEMPLATE_REF = CursorKind(45)\n# A reference to a namespace or namepsace alias.\nCursorKind.NAMESPACE_REF = CursorKind(46)\n# A reference to a member of a struct, union, or class that occurs in\n# some non-expression context, e.g., a designated initializer.\nCursorKind.MEMBER_REF = CursorKind(47)\n# A reference to a labeled statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TEMPLATE_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TEMPLATE_REF = CursorKind(45)\n# A reference to a namespace or namepsace alias.\nCursorKind.NAMESPACE_REF = CursorKind(46)\n# A reference to a member of a struct, union, or class that occurs in\n# some non-expression context, e.g., a designated initializer.\nCursorKind.MEMBER_REF = CursorKind(47)\n# A reference to a labeled statement.\nCursorKind.LABEL_REF = CursorKind(48)\n# A reference to a set of overloaded functions or function templates\n# that has not yet been resolved to a specific function or function template.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.NAMESPACE_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.NAMESPACE_REF = CursorKind(46)\n# A reference to a member of a struct, union, or class that occurs in\n# some non-expression context, e.g., a designated initializer.\nCursorKind.MEMBER_REF = CursorKind(47)\n# A reference to a labeled statement.\nCursorKind.LABEL_REF = CursorKind(48)\n# A reference to a set of overloaded functions or function templates\n# that has not yet been resolved to a specific function or function template.\nCursorKind.OVERLOADED_DECL_REF = CursorKind(49)\n# A reference to a variable that occurs in some non-expression",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.MEMBER_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.MEMBER_REF = CursorKind(47)\n# A reference to a labeled statement.\nCursorKind.LABEL_REF = CursorKind(48)\n# A reference to a set of overloaded functions or function templates\n# that has not yet been resolved to a specific function or function template.\nCursorKind.OVERLOADED_DECL_REF = CursorKind(49)\n# A reference to a variable that occurs in some non-expression\n# context, e.g., a C++ lambda capture list.\nCursorKind.VARIABLE_REF = CursorKind(50)\n###",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.LABEL_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.LABEL_REF = CursorKind(48)\n# A reference to a set of overloaded functions or function templates\n# that has not yet been resolved to a specific function or function template.\nCursorKind.OVERLOADED_DECL_REF = CursorKind(49)\n# A reference to a variable that occurs in some non-expression\n# context, e.g., a C++ lambda capture list.\nCursorKind.VARIABLE_REF = CursorKind(50)\n###\n# Invalid/Error Kinds\nCursorKind.INVALID_FILE = CursorKind(70)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OVERLOADED_DECL_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OVERLOADED_DECL_REF = CursorKind(49)\n# A reference to a variable that occurs in some non-expression\n# context, e.g., a C++ lambda capture list.\nCursorKind.VARIABLE_REF = CursorKind(50)\n###\n# Invalid/Error Kinds\nCursorKind.INVALID_FILE = CursorKind(70)\nCursorKind.NO_DECL_FOUND = CursorKind(71)\nCursorKind.NOT_IMPLEMENTED = CursorKind(72)\nCursorKind.INVALID_CODE = CursorKind(73)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.VARIABLE_REF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.VARIABLE_REF = CursorKind(50)\n###\n# Invalid/Error Kinds\nCursorKind.INVALID_FILE = CursorKind(70)\nCursorKind.NO_DECL_FOUND = CursorKind(71)\nCursorKind.NOT_IMPLEMENTED = CursorKind(72)\nCursorKind.INVALID_CODE = CursorKind(73)\n###\n# Expression Kinds\n# An expression whose specific kind is not exposed via this interface.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.INVALID_FILE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.INVALID_FILE = CursorKind(70)\nCursorKind.NO_DECL_FOUND = CursorKind(71)\nCursorKind.NOT_IMPLEMENTED = CursorKind(72)\nCursorKind.INVALID_CODE = CursorKind(73)\n###\n# Expression Kinds\n# An expression whose specific kind is not exposed via this interface.\n#\n# Unexposed expressions have the same operations as any other kind of\n# expression; one can extract their location information, spelling, children,",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.NO_DECL_FOUND",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.NO_DECL_FOUND = CursorKind(71)\nCursorKind.NOT_IMPLEMENTED = CursorKind(72)\nCursorKind.INVALID_CODE = CursorKind(73)\n###\n# Expression Kinds\n# An expression whose specific kind is not exposed via this interface.\n#\n# Unexposed expressions have the same operations as any other kind of\n# expression; one can extract their location information, spelling, children,\n# etc. However, the specific kind of the expression is not reported.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.NOT_IMPLEMENTED",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.NOT_IMPLEMENTED = CursorKind(72)\nCursorKind.INVALID_CODE = CursorKind(73)\n###\n# Expression Kinds\n# An expression whose specific kind is not exposed via this interface.\n#\n# Unexposed expressions have the same operations as any other kind of\n# expression; one can extract their location information, spelling, children,\n# etc. However, the specific kind of the expression is not reported.\nCursorKind.UNEXPOSED_EXPR = CursorKind(100)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.INVALID_CODE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.INVALID_CODE = CursorKind(73)\n###\n# Expression Kinds\n# An expression whose specific kind is not exposed via this interface.\n#\n# Unexposed expressions have the same operations as any other kind of\n# expression; one can extract their location information, spelling, children,\n# etc. However, the specific kind of the expression is not reported.\nCursorKind.UNEXPOSED_EXPR = CursorKind(100)\n# An expression that refers to some value declaration, such as a function,",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.UNEXPOSED_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.UNEXPOSED_EXPR = CursorKind(100)\n# An expression that refers to some value declaration, such as a function,\n# varible, or enumerator.\nCursorKind.DECL_REF_EXPR = CursorKind(101)\n# An expression that refers to a member of a struct, union, class, Objective-C\n# class, etc.\nCursorKind.MEMBER_REF_EXPR = CursorKind(102)\n# An expression that calls a function.\nCursorKind.CALL_EXPR = CursorKind(103)\n# An expression that sends a message to an Objective-C object or class.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.DECL_REF_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.DECL_REF_EXPR = CursorKind(101)\n# An expression that refers to a member of a struct, union, class, Objective-C\n# class, etc.\nCursorKind.MEMBER_REF_EXPR = CursorKind(102)\n# An expression that calls a function.\nCursorKind.CALL_EXPR = CursorKind(103)\n# An expression that sends a message to an Objective-C object or class.\nCursorKind.OBJC_MESSAGE_EXPR = CursorKind(104)\n# An expression that represents a block literal.\nCursorKind.BLOCK_EXPR = CursorKind(105)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.MEMBER_REF_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.MEMBER_REF_EXPR = CursorKind(102)\n# An expression that calls a function.\nCursorKind.CALL_EXPR = CursorKind(103)\n# An expression that sends a message to an Objective-C object or class.\nCursorKind.OBJC_MESSAGE_EXPR = CursorKind(104)\n# An expression that represents a block literal.\nCursorKind.BLOCK_EXPR = CursorKind(105)\n# An integer literal.\nCursorKind.INTEGER_LITERAL = CursorKind(106)\n# A floating point number literal.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CALL_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CALL_EXPR = CursorKind(103)\n# An expression that sends a message to an Objective-C object or class.\nCursorKind.OBJC_MESSAGE_EXPR = CursorKind(104)\n# An expression that represents a block literal.\nCursorKind.BLOCK_EXPR = CursorKind(105)\n# An integer literal.\nCursorKind.INTEGER_LITERAL = CursorKind(106)\n# A floating point number literal.\nCursorKind.FLOATING_LITERAL = CursorKind(107)\n# An imaginary number literal.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_MESSAGE_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_MESSAGE_EXPR = CursorKind(104)\n# An expression that represents a block literal.\nCursorKind.BLOCK_EXPR = CursorKind(105)\n# An integer literal.\nCursorKind.INTEGER_LITERAL = CursorKind(106)\n# A floating point number literal.\nCursorKind.FLOATING_LITERAL = CursorKind(107)\n# An imaginary number literal.\nCursorKind.IMAGINARY_LITERAL = CursorKind(108)\n# A string literal.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.BLOCK_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.BLOCK_EXPR = CursorKind(105)\n# An integer literal.\nCursorKind.INTEGER_LITERAL = CursorKind(106)\n# A floating point number literal.\nCursorKind.FLOATING_LITERAL = CursorKind(107)\n# An imaginary number literal.\nCursorKind.IMAGINARY_LITERAL = CursorKind(108)\n# A string literal.\nCursorKind.STRING_LITERAL = CursorKind(109)\n# A character literal.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.INTEGER_LITERAL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.INTEGER_LITERAL = CursorKind(106)\n# A floating point number literal.\nCursorKind.FLOATING_LITERAL = CursorKind(107)\n# An imaginary number literal.\nCursorKind.IMAGINARY_LITERAL = CursorKind(108)\n# A string literal.\nCursorKind.STRING_LITERAL = CursorKind(109)\n# A character literal.\nCursorKind.CHARACTER_LITERAL = CursorKind(110)\n# A parenthesized expression, e.g. \"(1)\".",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.FLOATING_LITERAL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.FLOATING_LITERAL = CursorKind(107)\n# An imaginary number literal.\nCursorKind.IMAGINARY_LITERAL = CursorKind(108)\n# A string literal.\nCursorKind.STRING_LITERAL = CursorKind(109)\n# A character literal.\nCursorKind.CHARACTER_LITERAL = CursorKind(110)\n# A parenthesized expression, e.g. \"(1)\".\n#\n# This AST node is only formed if full location information is requested.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.IMAGINARY_LITERAL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.IMAGINARY_LITERAL = CursorKind(108)\n# A string literal.\nCursorKind.STRING_LITERAL = CursorKind(109)\n# A character literal.\nCursorKind.CHARACTER_LITERAL = CursorKind(110)\n# A parenthesized expression, e.g. \"(1)\".\n#\n# This AST node is only formed if full location information is requested.\nCursorKind.PAREN_EXPR = CursorKind(111)\n# This represents the unary-expression's (except sizeof and",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.STRING_LITERAL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.STRING_LITERAL = CursorKind(109)\n# A character literal.\nCursorKind.CHARACTER_LITERAL = CursorKind(110)\n# A parenthesized expression, e.g. \"(1)\".\n#\n# This AST node is only formed if full location information is requested.\nCursorKind.PAREN_EXPR = CursorKind(111)\n# This represents the unary-expression's (except sizeof and\n# alignof).\nCursorKind.UNARY_OPERATOR = CursorKind(112)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CHARACTER_LITERAL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CHARACTER_LITERAL = CursorKind(110)\n# A parenthesized expression, e.g. \"(1)\".\n#\n# This AST node is only formed if full location information is requested.\nCursorKind.PAREN_EXPR = CursorKind(111)\n# This represents the unary-expression's (except sizeof and\n# alignof).\nCursorKind.UNARY_OPERATOR = CursorKind(112)\n# [C99 6.5.2.1] Array Subscripting.\nCursorKind.ARRAY_SUBSCRIPT_EXPR = CursorKind(113)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.PAREN_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.PAREN_EXPR = CursorKind(111)\n# This represents the unary-expression's (except sizeof and\n# alignof).\nCursorKind.UNARY_OPERATOR = CursorKind(112)\n# [C99 6.5.2.1] Array Subscripting.\nCursorKind.ARRAY_SUBSCRIPT_EXPR = CursorKind(113)\n# A builtin binary operation expression such as \"x + y\" or\n# \"x <= y\".\nCursorKind.BINARY_OPERATOR = CursorKind(114)\n# Compound assignment such as \"+=\".",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.UNARY_OPERATOR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.UNARY_OPERATOR = CursorKind(112)\n# [C99 6.5.2.1] Array Subscripting.\nCursorKind.ARRAY_SUBSCRIPT_EXPR = CursorKind(113)\n# A builtin binary operation expression such as \"x + y\" or\n# \"x <= y\".\nCursorKind.BINARY_OPERATOR = CursorKind(114)\n# Compound assignment such as \"+=\".\nCursorKind.COMPOUND_ASSIGNMENT_OPERATOR = CursorKind(115)\n# The ?: ternary operator.\nCursorKind.CONDITIONAL_OPERATOR = CursorKind(116)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.ARRAY_SUBSCRIPT_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.ARRAY_SUBSCRIPT_EXPR = CursorKind(113)\n# A builtin binary operation expression such as \"x + y\" or\n# \"x <= y\".\nCursorKind.BINARY_OPERATOR = CursorKind(114)\n# Compound assignment such as \"+=\".\nCursorKind.COMPOUND_ASSIGNMENT_OPERATOR = CursorKind(115)\n# The ?: ternary operator.\nCursorKind.CONDITIONAL_OPERATOR = CursorKind(116)\n# An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n# (C++ [expr.cast]), which uses the syntax (Type)expr.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.BINARY_OPERATOR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.BINARY_OPERATOR = CursorKind(114)\n# Compound assignment such as \"+=\".\nCursorKind.COMPOUND_ASSIGNMENT_OPERATOR = CursorKind(115)\n# The ?: ternary operator.\nCursorKind.CONDITIONAL_OPERATOR = CursorKind(116)\n# An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n# (C++ [expr.cast]), which uses the syntax (Type)expr.\n#\n# For example: (int)f.\nCursorKind.CSTYLE_CAST_EXPR = CursorKind(117)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.COMPOUND_ASSIGNMENT_OPERATOR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.COMPOUND_ASSIGNMENT_OPERATOR = CursorKind(115)\n# The ?: ternary operator.\nCursorKind.CONDITIONAL_OPERATOR = CursorKind(116)\n# An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n# (C++ [expr.cast]), which uses the syntax (Type)expr.\n#\n# For example: (int)f.\nCursorKind.CSTYLE_CAST_EXPR = CursorKind(117)\n# [C99 6.5.2.5]\nCursorKind.COMPOUND_LITERAL_EXPR = CursorKind(118)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CONDITIONAL_OPERATOR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CONDITIONAL_OPERATOR = CursorKind(116)\n# An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n# (C++ [expr.cast]), which uses the syntax (Type)expr.\n#\n# For example: (int)f.\nCursorKind.CSTYLE_CAST_EXPR = CursorKind(117)\n# [C99 6.5.2.5]\nCursorKind.COMPOUND_LITERAL_EXPR = CursorKind(118)\n# Describes an C or C++ initializer list.\nCursorKind.INIT_LIST_EXPR = CursorKind(119)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CSTYLE_CAST_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CSTYLE_CAST_EXPR = CursorKind(117)\n# [C99 6.5.2.5]\nCursorKind.COMPOUND_LITERAL_EXPR = CursorKind(118)\n# Describes an C or C++ initializer list.\nCursorKind.INIT_LIST_EXPR = CursorKind(119)\n# The GNU address of label extension, representing &&label.\nCursorKind.ADDR_LABEL_EXPR = CursorKind(120)\n# This is the GNU Statement Expression extension: ({int X=4; X;})\nCursorKind.StmtExpr = CursorKind(121)\n# Represents a C11 generic selection.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.COMPOUND_LITERAL_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.COMPOUND_LITERAL_EXPR = CursorKind(118)\n# Describes an C or C++ initializer list.\nCursorKind.INIT_LIST_EXPR = CursorKind(119)\n# The GNU address of label extension, representing &&label.\nCursorKind.ADDR_LABEL_EXPR = CursorKind(120)\n# This is the GNU Statement Expression extension: ({int X=4; X;})\nCursorKind.StmtExpr = CursorKind(121)\n# Represents a C11 generic selection.\nCursorKind.GENERIC_SELECTION_EXPR = CursorKind(122)\n# Implements the GNU __null extension, which is a name for a null",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.INIT_LIST_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.INIT_LIST_EXPR = CursorKind(119)\n# The GNU address of label extension, representing &&label.\nCursorKind.ADDR_LABEL_EXPR = CursorKind(120)\n# This is the GNU Statement Expression extension: ({int X=4; X;})\nCursorKind.StmtExpr = CursorKind(121)\n# Represents a C11 generic selection.\nCursorKind.GENERIC_SELECTION_EXPR = CursorKind(122)\n# Implements the GNU __null extension, which is a name for a null\n# pointer constant that has integral type (e.g., int or long) and is the same\n# size and alignment as a pointer.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.ADDR_LABEL_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.ADDR_LABEL_EXPR = CursorKind(120)\n# This is the GNU Statement Expression extension: ({int X=4; X;})\nCursorKind.StmtExpr = CursorKind(121)\n# Represents a C11 generic selection.\nCursorKind.GENERIC_SELECTION_EXPR = CursorKind(122)\n# Implements the GNU __null extension, which is a name for a null\n# pointer constant that has integral type (e.g., int or long) and is the same\n# size and alignment as a pointer.\n#\n# The __null extension is typically only used by system headers, which define",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.StmtExpr",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.StmtExpr = CursorKind(121)\n# Represents a C11 generic selection.\nCursorKind.GENERIC_SELECTION_EXPR = CursorKind(122)\n# Implements the GNU __null extension, which is a name for a null\n# pointer constant that has integral type (e.g., int or long) and is the same\n# size and alignment as a pointer.\n#\n# The __null extension is typically only used by system headers, which define\n# NULL as __null in C++ rather than using 0 (which is an integer that may not\n# match the size of a pointer).",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.GENERIC_SELECTION_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.GENERIC_SELECTION_EXPR = CursorKind(122)\n# Implements the GNU __null extension, which is a name for a null\n# pointer constant that has integral type (e.g., int or long) and is the same\n# size and alignment as a pointer.\n#\n# The __null extension is typically only used by system headers, which define\n# NULL as __null in C++ rather than using 0 (which is an integer that may not\n# match the size of a pointer).\nCursorKind.GNU_NULL_EXPR = CursorKind(123)\n# C++'s static_cast<> expression.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.GNU_NULL_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.GNU_NULL_EXPR = CursorKind(123)\n# C++'s static_cast<> expression.\nCursorKind.CXX_STATIC_CAST_EXPR = CursorKind(124)\n# C++'s dynamic_cast<> expression.\nCursorKind.CXX_DYNAMIC_CAST_EXPR = CursorKind(125)\n# C++'s reinterpret_cast<> expression.\nCursorKind.CXX_REINTERPRET_CAST_EXPR = CursorKind(126)\n# C++'s const_cast<> expression.\nCursorKind.CXX_CONST_CAST_EXPR = CursorKind(127)\n# Represents an explicit C++ type conversion that uses \"functional\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_STATIC_CAST_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_STATIC_CAST_EXPR = CursorKind(124)\n# C++'s dynamic_cast<> expression.\nCursorKind.CXX_DYNAMIC_CAST_EXPR = CursorKind(125)\n# C++'s reinterpret_cast<> expression.\nCursorKind.CXX_REINTERPRET_CAST_EXPR = CursorKind(126)\n# C++'s const_cast<> expression.\nCursorKind.CXX_CONST_CAST_EXPR = CursorKind(127)\n# Represents an explicit C++ type conversion that uses \"functional\"\n# notion (C++ [expr.type.conv]).\n#",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_DYNAMIC_CAST_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_DYNAMIC_CAST_EXPR = CursorKind(125)\n# C++'s reinterpret_cast<> expression.\nCursorKind.CXX_REINTERPRET_CAST_EXPR = CursorKind(126)\n# C++'s const_cast<> expression.\nCursorKind.CXX_CONST_CAST_EXPR = CursorKind(127)\n# Represents an explicit C++ type conversion that uses \"functional\"\n# notion (C++ [expr.type.conv]).\n#\n# Example:\n# \\code",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_REINTERPRET_CAST_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_REINTERPRET_CAST_EXPR = CursorKind(126)\n# C++'s const_cast<> expression.\nCursorKind.CXX_CONST_CAST_EXPR = CursorKind(127)\n# Represents an explicit C++ type conversion that uses \"functional\"\n# notion (C++ [expr.type.conv]).\n#\n# Example:\n# \\code\n#   x = int(0.5);\n# \\endcode",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_CONST_CAST_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_CONST_CAST_EXPR = CursorKind(127)\n# Represents an explicit C++ type conversion that uses \"functional\"\n# notion (C++ [expr.type.conv]).\n#\n# Example:\n# \\code\n#   x = int(0.5);\n# \\endcode\nCursorKind.CXX_FUNCTIONAL_CAST_EXPR = CursorKind(128)\n# A C++ typeid expression (C++ [expr.typeid]).",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_FUNCTIONAL_CAST_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_FUNCTIONAL_CAST_EXPR = CursorKind(128)\n# A C++ typeid expression (C++ [expr.typeid]).\nCursorKind.CXX_TYPEID_EXPR = CursorKind(129)\n# [C++ 2.13.5] C++ Boolean Literal.\nCursorKind.CXX_BOOL_LITERAL_EXPR = CursorKind(130)\n# [C++0x 2.14.7] C++ Pointer Literal.\nCursorKind.CXX_NULL_PTR_LITERAL_EXPR = CursorKind(131)\n# Represents the \"this\" expression in C++\nCursorKind.CXX_THIS_EXPR = CursorKind(132)\n# [C++ 15] C++ Throw Expression.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_TYPEID_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_TYPEID_EXPR = CursorKind(129)\n# [C++ 2.13.5] C++ Boolean Literal.\nCursorKind.CXX_BOOL_LITERAL_EXPR = CursorKind(130)\n# [C++0x 2.14.7] C++ Pointer Literal.\nCursorKind.CXX_NULL_PTR_LITERAL_EXPR = CursorKind(131)\n# Represents the \"this\" expression in C++\nCursorKind.CXX_THIS_EXPR = CursorKind(132)\n# [C++ 15] C++ Throw Expression.\n#\n# This handles 'throw' and 'throw' assignment-expression. When",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_BOOL_LITERAL_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_BOOL_LITERAL_EXPR = CursorKind(130)\n# [C++0x 2.14.7] C++ Pointer Literal.\nCursorKind.CXX_NULL_PTR_LITERAL_EXPR = CursorKind(131)\n# Represents the \"this\" expression in C++\nCursorKind.CXX_THIS_EXPR = CursorKind(132)\n# [C++ 15] C++ Throw Expression.\n#\n# This handles 'throw' and 'throw' assignment-expression. When\n# assignment-expression isn't present, Op will be null.\nCursorKind.CXX_THROW_EXPR = CursorKind(133)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_NULL_PTR_LITERAL_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_NULL_PTR_LITERAL_EXPR = CursorKind(131)\n# Represents the \"this\" expression in C++\nCursorKind.CXX_THIS_EXPR = CursorKind(132)\n# [C++ 15] C++ Throw Expression.\n#\n# This handles 'throw' and 'throw' assignment-expression. When\n# assignment-expression isn't present, Op will be null.\nCursorKind.CXX_THROW_EXPR = CursorKind(133)\n# A new expression for memory allocation and constructor calls, e.g:\n# \"new CXXNewExpr(foo)\".",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_THIS_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_THIS_EXPR = CursorKind(132)\n# [C++ 15] C++ Throw Expression.\n#\n# This handles 'throw' and 'throw' assignment-expression. When\n# assignment-expression isn't present, Op will be null.\nCursorKind.CXX_THROW_EXPR = CursorKind(133)\n# A new expression for memory allocation and constructor calls, e.g:\n# \"new CXXNewExpr(foo)\".\nCursorKind.CXX_NEW_EXPR = CursorKind(134)\n# A delete expression for memory deallocation and destructor calls,",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_THROW_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_THROW_EXPR = CursorKind(133)\n# A new expression for memory allocation and constructor calls, e.g:\n# \"new CXXNewExpr(foo)\".\nCursorKind.CXX_NEW_EXPR = CursorKind(134)\n# A delete expression for memory deallocation and destructor calls,\n# e.g. \"delete[] pArray\".\nCursorKind.CXX_DELETE_EXPR = CursorKind(135)\n# Represents a unary expression.\nCursorKind.CXX_UNARY_EXPR = CursorKind(136)\n# ObjCStringLiteral, used for Objective-C string literals i.e. \"foo\".",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_NEW_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_NEW_EXPR = CursorKind(134)\n# A delete expression for memory deallocation and destructor calls,\n# e.g. \"delete[] pArray\".\nCursorKind.CXX_DELETE_EXPR = CursorKind(135)\n# Represents a unary expression.\nCursorKind.CXX_UNARY_EXPR = CursorKind(136)\n# ObjCStringLiteral, used for Objective-C string literals i.e. \"foo\".\nCursorKind.OBJC_STRING_LITERAL = CursorKind(137)\n# ObjCEncodeExpr, used for in Objective-C.\nCursorKind.OBJC_ENCODE_EXPR = CursorKind(138)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_DELETE_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_DELETE_EXPR = CursorKind(135)\n# Represents a unary expression.\nCursorKind.CXX_UNARY_EXPR = CursorKind(136)\n# ObjCStringLiteral, used for Objective-C string literals i.e. \"foo\".\nCursorKind.OBJC_STRING_LITERAL = CursorKind(137)\n# ObjCEncodeExpr, used for in Objective-C.\nCursorKind.OBJC_ENCODE_EXPR = CursorKind(138)\n# ObjCSelectorExpr used for in Objective-C.\nCursorKind.OBJC_SELECTOR_EXPR = CursorKind(139)\n# Objective-C's protocol expression.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_UNARY_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_UNARY_EXPR = CursorKind(136)\n# ObjCStringLiteral, used for Objective-C string literals i.e. \"foo\".\nCursorKind.OBJC_STRING_LITERAL = CursorKind(137)\n# ObjCEncodeExpr, used for in Objective-C.\nCursorKind.OBJC_ENCODE_EXPR = CursorKind(138)\n# ObjCSelectorExpr used for in Objective-C.\nCursorKind.OBJC_SELECTOR_EXPR = CursorKind(139)\n# Objective-C's protocol expression.\nCursorKind.OBJC_PROTOCOL_EXPR = CursorKind(140)\n# An Objective-C \"bridged\" cast expression, which casts between",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_STRING_LITERAL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_STRING_LITERAL = CursorKind(137)\n# ObjCEncodeExpr, used for in Objective-C.\nCursorKind.OBJC_ENCODE_EXPR = CursorKind(138)\n# ObjCSelectorExpr used for in Objective-C.\nCursorKind.OBJC_SELECTOR_EXPR = CursorKind(139)\n# Objective-C's protocol expression.\nCursorKind.OBJC_PROTOCOL_EXPR = CursorKind(140)\n# An Objective-C \"bridged\" cast expression, which casts between\n# Objective-C pointers and C pointers, transferring ownership in the process.\n#",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_ENCODE_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_ENCODE_EXPR = CursorKind(138)\n# ObjCSelectorExpr used for in Objective-C.\nCursorKind.OBJC_SELECTOR_EXPR = CursorKind(139)\n# Objective-C's protocol expression.\nCursorKind.OBJC_PROTOCOL_EXPR = CursorKind(140)\n# An Objective-C \"bridged\" cast expression, which casts between\n# Objective-C pointers and C pointers, transferring ownership in the process.\n#\n# \\code\n#   NSString *str = (__bridge_transfer NSString *)CFCreateString();",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_SELECTOR_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_SELECTOR_EXPR = CursorKind(139)\n# Objective-C's protocol expression.\nCursorKind.OBJC_PROTOCOL_EXPR = CursorKind(140)\n# An Objective-C \"bridged\" cast expression, which casts between\n# Objective-C pointers and C pointers, transferring ownership in the process.\n#\n# \\code\n#   NSString *str = (__bridge_transfer NSString *)CFCreateString();\n# \\endcode\nCursorKind.OBJC_BRIDGE_CAST_EXPR = CursorKind(141)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_PROTOCOL_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_PROTOCOL_EXPR = CursorKind(140)\n# An Objective-C \"bridged\" cast expression, which casts between\n# Objective-C pointers and C pointers, transferring ownership in the process.\n#\n# \\code\n#   NSString *str = (__bridge_transfer NSString *)CFCreateString();\n# \\endcode\nCursorKind.OBJC_BRIDGE_CAST_EXPR = CursorKind(141)\n# Represents a C++0x pack expansion that produces a sequence of\n# expressions.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_BRIDGE_CAST_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_BRIDGE_CAST_EXPR = CursorKind(141)\n# Represents a C++0x pack expansion that produces a sequence of\n# expressions.\n#\n# A pack expansion expression contains a pattern (which itself is an\n# expression) followed by an ellipsis. For example:\nCursorKind.PACK_EXPANSION_EXPR = CursorKind(142)\n# Represents an expression that computes the length of a parameter\n# pack.\nCursorKind.SIZE_OF_PACK_EXPR = CursorKind(143)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.PACK_EXPANSION_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.PACK_EXPANSION_EXPR = CursorKind(142)\n# Represents an expression that computes the length of a parameter\n# pack.\nCursorKind.SIZE_OF_PACK_EXPR = CursorKind(143)\n# Represents a C++ lambda expression that produces a local function\n# object.\n#\n#  \\code\n#  void abssort(float *x, unsigned N) {\n#    std::sort(x, x + N,",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.SIZE_OF_PACK_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.SIZE_OF_PACK_EXPR = CursorKind(143)\n# Represents a C++ lambda expression that produces a local function\n# object.\n#\n#  \\code\n#  void abssort(float *x, unsigned N) {\n#    std::sort(x, x + N,\n#              [](float a, float b) {\n#                return std::abs(a) < std::abs(b);\n#              });",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.LAMBDA_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.LAMBDA_EXPR = CursorKind(144)\n# Objective-c Boolean Literal.\nCursorKind.OBJ_BOOL_LITERAL_EXPR = CursorKind(145)\n# Represents the \"self\" expression in a ObjC method.\nCursorKind.OBJ_SELF_EXPR = CursorKind(146)\n# A statement whose specific kind is not exposed via this interface.\n#\n# Unexposed statements have the same operations as any other kind of statement;\n# one can extract their location information, spelling, children, etc. However,\n# the specific kind of the statement is not reported.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJ_BOOL_LITERAL_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJ_BOOL_LITERAL_EXPR = CursorKind(145)\n# Represents the \"self\" expression in a ObjC method.\nCursorKind.OBJ_SELF_EXPR = CursorKind(146)\n# A statement whose specific kind is not exposed via this interface.\n#\n# Unexposed statements have the same operations as any other kind of statement;\n# one can extract their location information, spelling, children, etc. However,\n# the specific kind of the statement is not reported.\nCursorKind.UNEXPOSED_STMT = CursorKind(200)\n# A labelled statement in a function.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJ_SELF_EXPR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJ_SELF_EXPR = CursorKind(146)\n# A statement whose specific kind is not exposed via this interface.\n#\n# Unexposed statements have the same operations as any other kind of statement;\n# one can extract their location information, spelling, children, etc. However,\n# the specific kind of the statement is not reported.\nCursorKind.UNEXPOSED_STMT = CursorKind(200)\n# A labelled statement in a function.\nCursorKind.LABEL_STMT = CursorKind(201)\n# A compound statement",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.UNEXPOSED_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.UNEXPOSED_STMT = CursorKind(200)\n# A labelled statement in a function.\nCursorKind.LABEL_STMT = CursorKind(201)\n# A compound statement\nCursorKind.COMPOUND_STMT = CursorKind(202)\n# A case statement.\nCursorKind.CASE_STMT = CursorKind(203)\n# A default statement.\nCursorKind.DEFAULT_STMT = CursorKind(204)\n# An if statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.LABEL_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.LABEL_STMT = CursorKind(201)\n# A compound statement\nCursorKind.COMPOUND_STMT = CursorKind(202)\n# A case statement.\nCursorKind.CASE_STMT = CursorKind(203)\n# A default statement.\nCursorKind.DEFAULT_STMT = CursorKind(204)\n# An if statement.\nCursorKind.IF_STMT = CursorKind(205)\n# A switch statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.COMPOUND_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.COMPOUND_STMT = CursorKind(202)\n# A case statement.\nCursorKind.CASE_STMT = CursorKind(203)\n# A default statement.\nCursorKind.DEFAULT_STMT = CursorKind(204)\n# An if statement.\nCursorKind.IF_STMT = CursorKind(205)\n# A switch statement.\nCursorKind.SWITCH_STMT = CursorKind(206)\n# A while statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CASE_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CASE_STMT = CursorKind(203)\n# A default statement.\nCursorKind.DEFAULT_STMT = CursorKind(204)\n# An if statement.\nCursorKind.IF_STMT = CursorKind(205)\n# A switch statement.\nCursorKind.SWITCH_STMT = CursorKind(206)\n# A while statement.\nCursorKind.WHILE_STMT = CursorKind(207)\n# A do statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.DEFAULT_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.DEFAULT_STMT = CursorKind(204)\n# An if statement.\nCursorKind.IF_STMT = CursorKind(205)\n# A switch statement.\nCursorKind.SWITCH_STMT = CursorKind(206)\n# A while statement.\nCursorKind.WHILE_STMT = CursorKind(207)\n# A do statement.\nCursorKind.DO_STMT = CursorKind(208)\n# A for statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.IF_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.IF_STMT = CursorKind(205)\n# A switch statement.\nCursorKind.SWITCH_STMT = CursorKind(206)\n# A while statement.\nCursorKind.WHILE_STMT = CursorKind(207)\n# A do statement.\nCursorKind.DO_STMT = CursorKind(208)\n# A for statement.\nCursorKind.FOR_STMT = CursorKind(209)\n# A goto statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.SWITCH_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.SWITCH_STMT = CursorKind(206)\n# A while statement.\nCursorKind.WHILE_STMT = CursorKind(207)\n# A do statement.\nCursorKind.DO_STMT = CursorKind(208)\n# A for statement.\nCursorKind.FOR_STMT = CursorKind(209)\n# A goto statement.\nCursorKind.GOTO_STMT = CursorKind(210)\n# An indirect goto statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.WHILE_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.WHILE_STMT = CursorKind(207)\n# A do statement.\nCursorKind.DO_STMT = CursorKind(208)\n# A for statement.\nCursorKind.FOR_STMT = CursorKind(209)\n# A goto statement.\nCursorKind.GOTO_STMT = CursorKind(210)\n# An indirect goto statement.\nCursorKind.INDIRECT_GOTO_STMT = CursorKind(211)\n# A continue statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.DO_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.DO_STMT = CursorKind(208)\n# A for statement.\nCursorKind.FOR_STMT = CursorKind(209)\n# A goto statement.\nCursorKind.GOTO_STMT = CursorKind(210)\n# An indirect goto statement.\nCursorKind.INDIRECT_GOTO_STMT = CursorKind(211)\n# A continue statement.\nCursorKind.CONTINUE_STMT = CursorKind(212)\n# A break statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.FOR_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.FOR_STMT = CursorKind(209)\n# A goto statement.\nCursorKind.GOTO_STMT = CursorKind(210)\n# An indirect goto statement.\nCursorKind.INDIRECT_GOTO_STMT = CursorKind(211)\n# A continue statement.\nCursorKind.CONTINUE_STMT = CursorKind(212)\n# A break statement.\nCursorKind.BREAK_STMT = CursorKind(213)\n# A return statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.GOTO_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.GOTO_STMT = CursorKind(210)\n# An indirect goto statement.\nCursorKind.INDIRECT_GOTO_STMT = CursorKind(211)\n# A continue statement.\nCursorKind.CONTINUE_STMT = CursorKind(212)\n# A break statement.\nCursorKind.BREAK_STMT = CursorKind(213)\n# A return statement.\nCursorKind.RETURN_STMT = CursorKind(214)\n# A GNU-style inline assembler statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.INDIRECT_GOTO_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.INDIRECT_GOTO_STMT = CursorKind(211)\n# A continue statement.\nCursorKind.CONTINUE_STMT = CursorKind(212)\n# A break statement.\nCursorKind.BREAK_STMT = CursorKind(213)\n# A return statement.\nCursorKind.RETURN_STMT = CursorKind(214)\n# A GNU-style inline assembler statement.\nCursorKind.ASM_STMT = CursorKind(215)\n# Objective-C's overall @try-@catch-@finally statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CONTINUE_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CONTINUE_STMT = CursorKind(212)\n# A break statement.\nCursorKind.BREAK_STMT = CursorKind(213)\n# A return statement.\nCursorKind.RETURN_STMT = CursorKind(214)\n# A GNU-style inline assembler statement.\nCursorKind.ASM_STMT = CursorKind(215)\n# Objective-C's overall @try-@catch-@finally statement.\nCursorKind.OBJC_AT_TRY_STMT = CursorKind(216)\n# Objective-C's @catch statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.BREAK_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.BREAK_STMT = CursorKind(213)\n# A return statement.\nCursorKind.RETURN_STMT = CursorKind(214)\n# A GNU-style inline assembler statement.\nCursorKind.ASM_STMT = CursorKind(215)\n# Objective-C's overall @try-@catch-@finally statement.\nCursorKind.OBJC_AT_TRY_STMT = CursorKind(216)\n# Objective-C's @catch statement.\nCursorKind.OBJC_AT_CATCH_STMT = CursorKind(217)\n# Objective-C's @finally statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.RETURN_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.RETURN_STMT = CursorKind(214)\n# A GNU-style inline assembler statement.\nCursorKind.ASM_STMT = CursorKind(215)\n# Objective-C's overall @try-@catch-@finally statement.\nCursorKind.OBJC_AT_TRY_STMT = CursorKind(216)\n# Objective-C's @catch statement.\nCursorKind.OBJC_AT_CATCH_STMT = CursorKind(217)\n# Objective-C's @finally statement.\nCursorKind.OBJC_AT_FINALLY_STMT = CursorKind(218)\n# Objective-C's @throw statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.ASM_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.ASM_STMT = CursorKind(215)\n# Objective-C's overall @try-@catch-@finally statement.\nCursorKind.OBJC_AT_TRY_STMT = CursorKind(216)\n# Objective-C's @catch statement.\nCursorKind.OBJC_AT_CATCH_STMT = CursorKind(217)\n# Objective-C's @finally statement.\nCursorKind.OBJC_AT_FINALLY_STMT = CursorKind(218)\n# Objective-C's @throw statement.\nCursorKind.OBJC_AT_THROW_STMT = CursorKind(219)\n# Objective-C's @synchronized statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_AT_TRY_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_AT_TRY_STMT = CursorKind(216)\n# Objective-C's @catch statement.\nCursorKind.OBJC_AT_CATCH_STMT = CursorKind(217)\n# Objective-C's @finally statement.\nCursorKind.OBJC_AT_FINALLY_STMT = CursorKind(218)\n# Objective-C's @throw statement.\nCursorKind.OBJC_AT_THROW_STMT = CursorKind(219)\n# Objective-C's @synchronized statement.\nCursorKind.OBJC_AT_SYNCHRONIZED_STMT = CursorKind(220)\n# Objective-C's autorealease pool statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_AT_CATCH_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_AT_CATCH_STMT = CursorKind(217)\n# Objective-C's @finally statement.\nCursorKind.OBJC_AT_FINALLY_STMT = CursorKind(218)\n# Objective-C's @throw statement.\nCursorKind.OBJC_AT_THROW_STMT = CursorKind(219)\n# Objective-C's @synchronized statement.\nCursorKind.OBJC_AT_SYNCHRONIZED_STMT = CursorKind(220)\n# Objective-C's autorealease pool statement.\nCursorKind.OBJC_AUTORELEASE_POOL_STMT = CursorKind(221)\n# Objective-C's for collection statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_AT_FINALLY_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_AT_FINALLY_STMT = CursorKind(218)\n# Objective-C's @throw statement.\nCursorKind.OBJC_AT_THROW_STMT = CursorKind(219)\n# Objective-C's @synchronized statement.\nCursorKind.OBJC_AT_SYNCHRONIZED_STMT = CursorKind(220)\n# Objective-C's autorealease pool statement.\nCursorKind.OBJC_AUTORELEASE_POOL_STMT = CursorKind(221)\n# Objective-C's for collection statement.\nCursorKind.OBJC_FOR_COLLECTION_STMT = CursorKind(222)\n# C++'s catch statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_AT_THROW_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_AT_THROW_STMT = CursorKind(219)\n# Objective-C's @synchronized statement.\nCursorKind.OBJC_AT_SYNCHRONIZED_STMT = CursorKind(220)\n# Objective-C's autorealease pool statement.\nCursorKind.OBJC_AUTORELEASE_POOL_STMT = CursorKind(221)\n# Objective-C's for collection statement.\nCursorKind.OBJC_FOR_COLLECTION_STMT = CursorKind(222)\n# C++'s catch statement.\nCursorKind.CXX_CATCH_STMT = CursorKind(223)\n# C++'s try statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_AT_SYNCHRONIZED_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_AT_SYNCHRONIZED_STMT = CursorKind(220)\n# Objective-C's autorealease pool statement.\nCursorKind.OBJC_AUTORELEASE_POOL_STMT = CursorKind(221)\n# Objective-C's for collection statement.\nCursorKind.OBJC_FOR_COLLECTION_STMT = CursorKind(222)\n# C++'s catch statement.\nCursorKind.CXX_CATCH_STMT = CursorKind(223)\n# C++'s try statement.\nCursorKind.CXX_TRY_STMT = CursorKind(224)\n# C++'s for (* : *) statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_AUTORELEASE_POOL_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_AUTORELEASE_POOL_STMT = CursorKind(221)\n# Objective-C's for collection statement.\nCursorKind.OBJC_FOR_COLLECTION_STMT = CursorKind(222)\n# C++'s catch statement.\nCursorKind.CXX_CATCH_STMT = CursorKind(223)\n# C++'s try statement.\nCursorKind.CXX_TRY_STMT = CursorKind(224)\n# C++'s for (* : *) statement.\nCursorKind.CXX_FOR_RANGE_STMT = CursorKind(225)\n# Windows Structured Exception Handling's try statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OBJC_FOR_COLLECTION_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OBJC_FOR_COLLECTION_STMT = CursorKind(222)\n# C++'s catch statement.\nCursorKind.CXX_CATCH_STMT = CursorKind(223)\n# C++'s try statement.\nCursorKind.CXX_TRY_STMT = CursorKind(224)\n# C++'s for (* : *) statement.\nCursorKind.CXX_FOR_RANGE_STMT = CursorKind(225)\n# Windows Structured Exception Handling's try statement.\nCursorKind.SEH_TRY_STMT = CursorKind(226)\n# Windows Structured Exception Handling's except statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_CATCH_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_CATCH_STMT = CursorKind(223)\n# C++'s try statement.\nCursorKind.CXX_TRY_STMT = CursorKind(224)\n# C++'s for (* : *) statement.\nCursorKind.CXX_FOR_RANGE_STMT = CursorKind(225)\n# Windows Structured Exception Handling's try statement.\nCursorKind.SEH_TRY_STMT = CursorKind(226)\n# Windows Structured Exception Handling's except statement.\nCursorKind.SEH_EXCEPT_STMT = CursorKind(227)\n# Windows Structured Exception Handling's finally statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_TRY_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_TRY_STMT = CursorKind(224)\n# C++'s for (* : *) statement.\nCursorKind.CXX_FOR_RANGE_STMT = CursorKind(225)\n# Windows Structured Exception Handling's try statement.\nCursorKind.SEH_TRY_STMT = CursorKind(226)\n# Windows Structured Exception Handling's except statement.\nCursorKind.SEH_EXCEPT_STMT = CursorKind(227)\n# Windows Structured Exception Handling's finally statement.\nCursorKind.SEH_FINALLY_STMT = CursorKind(228)\n# A MS inline assembly statement extension.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_FOR_RANGE_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_FOR_RANGE_STMT = CursorKind(225)\n# Windows Structured Exception Handling's try statement.\nCursorKind.SEH_TRY_STMT = CursorKind(226)\n# Windows Structured Exception Handling's except statement.\nCursorKind.SEH_EXCEPT_STMT = CursorKind(227)\n# Windows Structured Exception Handling's finally statement.\nCursorKind.SEH_FINALLY_STMT = CursorKind(228)\n# A MS inline assembly statement extension.\nCursorKind.MS_ASM_STMT = CursorKind(229)\n# The null statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.SEH_TRY_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.SEH_TRY_STMT = CursorKind(226)\n# Windows Structured Exception Handling's except statement.\nCursorKind.SEH_EXCEPT_STMT = CursorKind(227)\n# Windows Structured Exception Handling's finally statement.\nCursorKind.SEH_FINALLY_STMT = CursorKind(228)\n# A MS inline assembly statement extension.\nCursorKind.MS_ASM_STMT = CursorKind(229)\n# The null statement.\nCursorKind.NULL_STMT = CursorKind(230)\n# Adaptor class for mixing declarations with statements and expressions.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.SEH_EXCEPT_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.SEH_EXCEPT_STMT = CursorKind(227)\n# Windows Structured Exception Handling's finally statement.\nCursorKind.SEH_FINALLY_STMT = CursorKind(228)\n# A MS inline assembly statement extension.\nCursorKind.MS_ASM_STMT = CursorKind(229)\n# The null statement.\nCursorKind.NULL_STMT = CursorKind(230)\n# Adaptor class for mixing declarations with statements and expressions.\nCursorKind.DECL_STMT = CursorKind(231)\n# OpenMP parallel directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.SEH_FINALLY_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.SEH_FINALLY_STMT = CursorKind(228)\n# A MS inline assembly statement extension.\nCursorKind.MS_ASM_STMT = CursorKind(229)\n# The null statement.\nCursorKind.NULL_STMT = CursorKind(230)\n# Adaptor class for mixing declarations with statements and expressions.\nCursorKind.DECL_STMT = CursorKind(231)\n# OpenMP parallel directive.\nCursorKind.OMP_PARALLEL_DIRECTIVE = CursorKind(232)\n# OpenMP SIMD directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.MS_ASM_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.MS_ASM_STMT = CursorKind(229)\n# The null statement.\nCursorKind.NULL_STMT = CursorKind(230)\n# Adaptor class for mixing declarations with statements and expressions.\nCursorKind.DECL_STMT = CursorKind(231)\n# OpenMP parallel directive.\nCursorKind.OMP_PARALLEL_DIRECTIVE = CursorKind(232)\n# OpenMP SIMD directive.\nCursorKind.OMP_SIMD_DIRECTIVE = CursorKind(233)\n# OpenMP for directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.NULL_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.NULL_STMT = CursorKind(230)\n# Adaptor class for mixing declarations with statements and expressions.\nCursorKind.DECL_STMT = CursorKind(231)\n# OpenMP parallel directive.\nCursorKind.OMP_PARALLEL_DIRECTIVE = CursorKind(232)\n# OpenMP SIMD directive.\nCursorKind.OMP_SIMD_DIRECTIVE = CursorKind(233)\n# OpenMP for directive.\nCursorKind.OMP_FOR_DIRECTIVE = CursorKind(234)\n# OpenMP sections directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.DECL_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.DECL_STMT = CursorKind(231)\n# OpenMP parallel directive.\nCursorKind.OMP_PARALLEL_DIRECTIVE = CursorKind(232)\n# OpenMP SIMD directive.\nCursorKind.OMP_SIMD_DIRECTIVE = CursorKind(233)\n# OpenMP for directive.\nCursorKind.OMP_FOR_DIRECTIVE = CursorKind(234)\n# OpenMP sections directive.\nCursorKind.OMP_SECTIONS_DIRECTIVE = CursorKind(235)\n# OpenMP section directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_PARALLEL_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_PARALLEL_DIRECTIVE = CursorKind(232)\n# OpenMP SIMD directive.\nCursorKind.OMP_SIMD_DIRECTIVE = CursorKind(233)\n# OpenMP for directive.\nCursorKind.OMP_FOR_DIRECTIVE = CursorKind(234)\n# OpenMP sections directive.\nCursorKind.OMP_SECTIONS_DIRECTIVE = CursorKind(235)\n# OpenMP section directive.\nCursorKind.OMP_SECTION_DIRECTIVE = CursorKind(236)\n# OpenMP single directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_SIMD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_SIMD_DIRECTIVE = CursorKind(233)\n# OpenMP for directive.\nCursorKind.OMP_FOR_DIRECTIVE = CursorKind(234)\n# OpenMP sections directive.\nCursorKind.OMP_SECTIONS_DIRECTIVE = CursorKind(235)\n# OpenMP section directive.\nCursorKind.OMP_SECTION_DIRECTIVE = CursorKind(236)\n# OpenMP single directive.\nCursorKind.OMP_SINGLE_DIRECTIVE = CursorKind(237)\n# OpenMP parallel for directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_FOR_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_FOR_DIRECTIVE = CursorKind(234)\n# OpenMP sections directive.\nCursorKind.OMP_SECTIONS_DIRECTIVE = CursorKind(235)\n# OpenMP section directive.\nCursorKind.OMP_SECTION_DIRECTIVE = CursorKind(236)\n# OpenMP single directive.\nCursorKind.OMP_SINGLE_DIRECTIVE = CursorKind(237)\n# OpenMP parallel for directive.\nCursorKind.OMP_PARALLEL_FOR_DIRECTIVE = CursorKind(238)\n# OpenMP parallel sections directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_SECTIONS_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_SECTIONS_DIRECTIVE = CursorKind(235)\n# OpenMP section directive.\nCursorKind.OMP_SECTION_DIRECTIVE = CursorKind(236)\n# OpenMP single directive.\nCursorKind.OMP_SINGLE_DIRECTIVE = CursorKind(237)\n# OpenMP parallel for directive.\nCursorKind.OMP_PARALLEL_FOR_DIRECTIVE = CursorKind(238)\n# OpenMP parallel sections directive.\nCursorKind.OMP_PARALLEL_SECTIONS_DIRECTIVE = CursorKind(239)\n# OpenMP task directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_SECTION_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_SECTION_DIRECTIVE = CursorKind(236)\n# OpenMP single directive.\nCursorKind.OMP_SINGLE_DIRECTIVE = CursorKind(237)\n# OpenMP parallel for directive.\nCursorKind.OMP_PARALLEL_FOR_DIRECTIVE = CursorKind(238)\n# OpenMP parallel sections directive.\nCursorKind.OMP_PARALLEL_SECTIONS_DIRECTIVE = CursorKind(239)\n# OpenMP task directive.\nCursorKind.OMP_TASK_DIRECTIVE = CursorKind(240)\n# OpenMP master directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_SINGLE_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_SINGLE_DIRECTIVE = CursorKind(237)\n# OpenMP parallel for directive.\nCursorKind.OMP_PARALLEL_FOR_DIRECTIVE = CursorKind(238)\n# OpenMP parallel sections directive.\nCursorKind.OMP_PARALLEL_SECTIONS_DIRECTIVE = CursorKind(239)\n# OpenMP task directive.\nCursorKind.OMP_TASK_DIRECTIVE = CursorKind(240)\n# OpenMP master directive.\nCursorKind.OMP_MASTER_DIRECTIVE = CursorKind(241)\n# OpenMP critical directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_PARALLEL_FOR_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_PARALLEL_FOR_DIRECTIVE = CursorKind(238)\n# OpenMP parallel sections directive.\nCursorKind.OMP_PARALLEL_SECTIONS_DIRECTIVE = CursorKind(239)\n# OpenMP task directive.\nCursorKind.OMP_TASK_DIRECTIVE = CursorKind(240)\n# OpenMP master directive.\nCursorKind.OMP_MASTER_DIRECTIVE = CursorKind(241)\n# OpenMP critical directive.\nCursorKind.OMP_CRITICAL_DIRECTIVE = CursorKind(242)\n# OpenMP taskyield directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_PARALLEL_SECTIONS_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_PARALLEL_SECTIONS_DIRECTIVE = CursorKind(239)\n# OpenMP task directive.\nCursorKind.OMP_TASK_DIRECTIVE = CursorKind(240)\n# OpenMP master directive.\nCursorKind.OMP_MASTER_DIRECTIVE = CursorKind(241)\n# OpenMP critical directive.\nCursorKind.OMP_CRITICAL_DIRECTIVE = CursorKind(242)\n# OpenMP taskyield directive.\nCursorKind.OMP_TASKYIELD_DIRECTIVE = CursorKind(243)\n# OpenMP barrier directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TASK_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TASK_DIRECTIVE = CursorKind(240)\n# OpenMP master directive.\nCursorKind.OMP_MASTER_DIRECTIVE = CursorKind(241)\n# OpenMP critical directive.\nCursorKind.OMP_CRITICAL_DIRECTIVE = CursorKind(242)\n# OpenMP taskyield directive.\nCursorKind.OMP_TASKYIELD_DIRECTIVE = CursorKind(243)\n# OpenMP barrier directive.\nCursorKind.OMP_BARRIER_DIRECTIVE = CursorKind(244)\n# OpenMP taskwait directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_MASTER_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_MASTER_DIRECTIVE = CursorKind(241)\n# OpenMP critical directive.\nCursorKind.OMP_CRITICAL_DIRECTIVE = CursorKind(242)\n# OpenMP taskyield directive.\nCursorKind.OMP_TASKYIELD_DIRECTIVE = CursorKind(243)\n# OpenMP barrier directive.\nCursorKind.OMP_BARRIER_DIRECTIVE = CursorKind(244)\n# OpenMP taskwait directive.\nCursorKind.OMP_TASKWAIT_DIRECTIVE = CursorKind(245)\n# OpenMP flush directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_CRITICAL_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_CRITICAL_DIRECTIVE = CursorKind(242)\n# OpenMP taskyield directive.\nCursorKind.OMP_TASKYIELD_DIRECTIVE = CursorKind(243)\n# OpenMP barrier directive.\nCursorKind.OMP_BARRIER_DIRECTIVE = CursorKind(244)\n# OpenMP taskwait directive.\nCursorKind.OMP_TASKWAIT_DIRECTIVE = CursorKind(245)\n# OpenMP flush directive.\nCursorKind.OMP_FLUSH_DIRECTIVE = CursorKind(246)\n# Windows Structured Exception Handling's leave statement.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TASKYIELD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TASKYIELD_DIRECTIVE = CursorKind(243)\n# OpenMP barrier directive.\nCursorKind.OMP_BARRIER_DIRECTIVE = CursorKind(244)\n# OpenMP taskwait directive.\nCursorKind.OMP_TASKWAIT_DIRECTIVE = CursorKind(245)\n# OpenMP flush directive.\nCursorKind.OMP_FLUSH_DIRECTIVE = CursorKind(246)\n# Windows Structured Exception Handling's leave statement.\nCursorKind.SEH_LEAVE_STMT = CursorKind(247)\n# OpenMP ordered directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_BARRIER_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_BARRIER_DIRECTIVE = CursorKind(244)\n# OpenMP taskwait directive.\nCursorKind.OMP_TASKWAIT_DIRECTIVE = CursorKind(245)\n# OpenMP flush directive.\nCursorKind.OMP_FLUSH_DIRECTIVE = CursorKind(246)\n# Windows Structured Exception Handling's leave statement.\nCursorKind.SEH_LEAVE_STMT = CursorKind(247)\n# OpenMP ordered directive.\nCursorKind.OMP_ORDERED_DIRECTIVE = CursorKind(248)\n# OpenMP atomic directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TASKWAIT_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TASKWAIT_DIRECTIVE = CursorKind(245)\n# OpenMP flush directive.\nCursorKind.OMP_FLUSH_DIRECTIVE = CursorKind(246)\n# Windows Structured Exception Handling's leave statement.\nCursorKind.SEH_LEAVE_STMT = CursorKind(247)\n# OpenMP ordered directive.\nCursorKind.OMP_ORDERED_DIRECTIVE = CursorKind(248)\n# OpenMP atomic directive.\nCursorKind.OMP_ATOMIC_DIRECTIVE = CursorKind(249)\n# OpenMP for SIMD directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_FLUSH_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_FLUSH_DIRECTIVE = CursorKind(246)\n# Windows Structured Exception Handling's leave statement.\nCursorKind.SEH_LEAVE_STMT = CursorKind(247)\n# OpenMP ordered directive.\nCursorKind.OMP_ORDERED_DIRECTIVE = CursorKind(248)\n# OpenMP atomic directive.\nCursorKind.OMP_ATOMIC_DIRECTIVE = CursorKind(249)\n# OpenMP for SIMD directive.\nCursorKind.OMP_FOR_SIMD_DIRECTIVE = CursorKind(250)\n# OpenMP parallel for SIMD directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.SEH_LEAVE_STMT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.SEH_LEAVE_STMT = CursorKind(247)\n# OpenMP ordered directive.\nCursorKind.OMP_ORDERED_DIRECTIVE = CursorKind(248)\n# OpenMP atomic directive.\nCursorKind.OMP_ATOMIC_DIRECTIVE = CursorKind(249)\n# OpenMP for SIMD directive.\nCursorKind.OMP_FOR_SIMD_DIRECTIVE = CursorKind(250)\n# OpenMP parallel for SIMD directive.\nCursorKind.OMP_PARALLELFORSIMD_DIRECTIVE = CursorKind(251)\n# OpenMP target directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_ORDERED_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_ORDERED_DIRECTIVE = CursorKind(248)\n# OpenMP atomic directive.\nCursorKind.OMP_ATOMIC_DIRECTIVE = CursorKind(249)\n# OpenMP for SIMD directive.\nCursorKind.OMP_FOR_SIMD_DIRECTIVE = CursorKind(250)\n# OpenMP parallel for SIMD directive.\nCursorKind.OMP_PARALLELFORSIMD_DIRECTIVE = CursorKind(251)\n# OpenMP target directive.\nCursorKind.OMP_TARGET_DIRECTIVE = CursorKind(252)\n# OpenMP teams directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_ATOMIC_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_ATOMIC_DIRECTIVE = CursorKind(249)\n# OpenMP for SIMD directive.\nCursorKind.OMP_FOR_SIMD_DIRECTIVE = CursorKind(250)\n# OpenMP parallel for SIMD directive.\nCursorKind.OMP_PARALLELFORSIMD_DIRECTIVE = CursorKind(251)\n# OpenMP target directive.\nCursorKind.OMP_TARGET_DIRECTIVE = CursorKind(252)\n# OpenMP teams directive.\nCursorKind.OMP_TEAMS_DIRECTIVE = CursorKind(253)\n# OpenMP taskgroup directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_FOR_SIMD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_FOR_SIMD_DIRECTIVE = CursorKind(250)\n# OpenMP parallel for SIMD directive.\nCursorKind.OMP_PARALLELFORSIMD_DIRECTIVE = CursorKind(251)\n# OpenMP target directive.\nCursorKind.OMP_TARGET_DIRECTIVE = CursorKind(252)\n# OpenMP teams directive.\nCursorKind.OMP_TEAMS_DIRECTIVE = CursorKind(253)\n# OpenMP taskgroup directive.\nCursorKind.OMP_TASKGROUP_DIRECTIVE = CursorKind(254)\n# OpenMP cancellation point directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_PARALLELFORSIMD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_PARALLELFORSIMD_DIRECTIVE = CursorKind(251)\n# OpenMP target directive.\nCursorKind.OMP_TARGET_DIRECTIVE = CursorKind(252)\n# OpenMP teams directive.\nCursorKind.OMP_TEAMS_DIRECTIVE = CursorKind(253)\n# OpenMP taskgroup directive.\nCursorKind.OMP_TASKGROUP_DIRECTIVE = CursorKind(254)\n# OpenMP cancellation point directive.\nCursorKind.OMP_CANCELLATION_POINT_DIRECTIVE = CursorKind(255)\n# OpenMP cancel directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_DIRECTIVE = CursorKind(252)\n# OpenMP teams directive.\nCursorKind.OMP_TEAMS_DIRECTIVE = CursorKind(253)\n# OpenMP taskgroup directive.\nCursorKind.OMP_TASKGROUP_DIRECTIVE = CursorKind(254)\n# OpenMP cancellation point directive.\nCursorKind.OMP_CANCELLATION_POINT_DIRECTIVE = CursorKind(255)\n# OpenMP cancel directive.\nCursorKind.OMP_CANCEL_DIRECTIVE = CursorKind(256)\n# OpenMP target data directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TEAMS_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TEAMS_DIRECTIVE = CursorKind(253)\n# OpenMP taskgroup directive.\nCursorKind.OMP_TASKGROUP_DIRECTIVE = CursorKind(254)\n# OpenMP cancellation point directive.\nCursorKind.OMP_CANCELLATION_POINT_DIRECTIVE = CursorKind(255)\n# OpenMP cancel directive.\nCursorKind.OMP_CANCEL_DIRECTIVE = CursorKind(256)\n# OpenMP target data directive.\nCursorKind.OMP_TARGET_DATA_DIRECTIVE = CursorKind(257)\n# OpenMP taskloop directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TASKGROUP_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TASKGROUP_DIRECTIVE = CursorKind(254)\n# OpenMP cancellation point directive.\nCursorKind.OMP_CANCELLATION_POINT_DIRECTIVE = CursorKind(255)\n# OpenMP cancel directive.\nCursorKind.OMP_CANCEL_DIRECTIVE = CursorKind(256)\n# OpenMP target data directive.\nCursorKind.OMP_TARGET_DATA_DIRECTIVE = CursorKind(257)\n# OpenMP taskloop directive.\nCursorKind.OMP_TASK_LOOP_DIRECTIVE = CursorKind(258)\n# OpenMP taskloop simd directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_CANCELLATION_POINT_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_CANCELLATION_POINT_DIRECTIVE = CursorKind(255)\n# OpenMP cancel directive.\nCursorKind.OMP_CANCEL_DIRECTIVE = CursorKind(256)\n# OpenMP target data directive.\nCursorKind.OMP_TARGET_DATA_DIRECTIVE = CursorKind(257)\n# OpenMP taskloop directive.\nCursorKind.OMP_TASK_LOOP_DIRECTIVE = CursorKind(258)\n# OpenMP taskloop simd directive.\nCursorKind.OMP_TASK_LOOP_SIMD_DIRECTIVE = CursorKind(259)\n# OpenMP distribute directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_CANCEL_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_CANCEL_DIRECTIVE = CursorKind(256)\n# OpenMP target data directive.\nCursorKind.OMP_TARGET_DATA_DIRECTIVE = CursorKind(257)\n# OpenMP taskloop directive.\nCursorKind.OMP_TASK_LOOP_DIRECTIVE = CursorKind(258)\n# OpenMP taskloop simd directive.\nCursorKind.OMP_TASK_LOOP_SIMD_DIRECTIVE = CursorKind(259)\n# OpenMP distribute directive.\nCursorKind.OMP_DISTRIBUTE_DIRECTIVE = CursorKind(260)\n# OpenMP target enter data directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_DATA_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_DATA_DIRECTIVE = CursorKind(257)\n# OpenMP taskloop directive.\nCursorKind.OMP_TASK_LOOP_DIRECTIVE = CursorKind(258)\n# OpenMP taskloop simd directive.\nCursorKind.OMP_TASK_LOOP_SIMD_DIRECTIVE = CursorKind(259)\n# OpenMP distribute directive.\nCursorKind.OMP_DISTRIBUTE_DIRECTIVE = CursorKind(260)\n# OpenMP target enter data directive.\nCursorKind.OMP_TARGET_ENTER_DATA_DIRECTIVE = CursorKind(261)\n# OpenMP target exit data directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TASK_LOOP_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TASK_LOOP_DIRECTIVE = CursorKind(258)\n# OpenMP taskloop simd directive.\nCursorKind.OMP_TASK_LOOP_SIMD_DIRECTIVE = CursorKind(259)\n# OpenMP distribute directive.\nCursorKind.OMP_DISTRIBUTE_DIRECTIVE = CursorKind(260)\n# OpenMP target enter data directive.\nCursorKind.OMP_TARGET_ENTER_DATA_DIRECTIVE = CursorKind(261)\n# OpenMP target exit data directive.\nCursorKind.OMP_TARGET_EXIT_DATA_DIRECTIVE = CursorKind(262)\n# OpenMP target parallel directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TASK_LOOP_SIMD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TASK_LOOP_SIMD_DIRECTIVE = CursorKind(259)\n# OpenMP distribute directive.\nCursorKind.OMP_DISTRIBUTE_DIRECTIVE = CursorKind(260)\n# OpenMP target enter data directive.\nCursorKind.OMP_TARGET_ENTER_DATA_DIRECTIVE = CursorKind(261)\n# OpenMP target exit data directive.\nCursorKind.OMP_TARGET_EXIT_DATA_DIRECTIVE = CursorKind(262)\n# OpenMP target parallel directive.\nCursorKind.OMP_TARGET_PARALLEL_DIRECTIVE = CursorKind(263)\n# OpenMP target parallel for directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_DISTRIBUTE_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_DISTRIBUTE_DIRECTIVE = CursorKind(260)\n# OpenMP target enter data directive.\nCursorKind.OMP_TARGET_ENTER_DATA_DIRECTIVE = CursorKind(261)\n# OpenMP target exit data directive.\nCursorKind.OMP_TARGET_EXIT_DATA_DIRECTIVE = CursorKind(262)\n# OpenMP target parallel directive.\nCursorKind.OMP_TARGET_PARALLEL_DIRECTIVE = CursorKind(263)\n# OpenMP target parallel for directive.\nCursorKind.OMP_TARGET_PARALLELFOR_DIRECTIVE = CursorKind(264)\n# OpenMP target update directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_ENTER_DATA_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_ENTER_DATA_DIRECTIVE = CursorKind(261)\n# OpenMP target exit data directive.\nCursorKind.OMP_TARGET_EXIT_DATA_DIRECTIVE = CursorKind(262)\n# OpenMP target parallel directive.\nCursorKind.OMP_TARGET_PARALLEL_DIRECTIVE = CursorKind(263)\n# OpenMP target parallel for directive.\nCursorKind.OMP_TARGET_PARALLELFOR_DIRECTIVE = CursorKind(264)\n# OpenMP target update directive.\nCursorKind.OMP_TARGET_UPDATE_DIRECTIVE = CursorKind(265)\n# OpenMP distribute parallel for directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_EXIT_DATA_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_EXIT_DATA_DIRECTIVE = CursorKind(262)\n# OpenMP target parallel directive.\nCursorKind.OMP_TARGET_PARALLEL_DIRECTIVE = CursorKind(263)\n# OpenMP target parallel for directive.\nCursorKind.OMP_TARGET_PARALLELFOR_DIRECTIVE = CursorKind(264)\n# OpenMP target update directive.\nCursorKind.OMP_TARGET_UPDATE_DIRECTIVE = CursorKind(265)\n# OpenMP distribute parallel for directive.\nCursorKind.OMP_DISTRIBUTE_PARALLELFOR_DIRECTIVE = CursorKind(266)\n# OpenMP distribute parallel for simd directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_PARALLEL_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_PARALLEL_DIRECTIVE = CursorKind(263)\n# OpenMP target parallel for directive.\nCursorKind.OMP_TARGET_PARALLELFOR_DIRECTIVE = CursorKind(264)\n# OpenMP target update directive.\nCursorKind.OMP_TARGET_UPDATE_DIRECTIVE = CursorKind(265)\n# OpenMP distribute parallel for directive.\nCursorKind.OMP_DISTRIBUTE_PARALLELFOR_DIRECTIVE = CursorKind(266)\n# OpenMP distribute parallel for simd directive.\nCursorKind.OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(267)\n# OpenMP distribute simd directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_PARALLELFOR_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_PARALLELFOR_DIRECTIVE = CursorKind(264)\n# OpenMP target update directive.\nCursorKind.OMP_TARGET_UPDATE_DIRECTIVE = CursorKind(265)\n# OpenMP distribute parallel for directive.\nCursorKind.OMP_DISTRIBUTE_PARALLELFOR_DIRECTIVE = CursorKind(266)\n# OpenMP distribute parallel for simd directive.\nCursorKind.OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(267)\n# OpenMP distribute simd directive.\nCursorKind.OMP_DISTRIBUTE_SIMD_DIRECTIVE = CursorKind(268)\n# OpenMP target parallel for simd directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_UPDATE_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_UPDATE_DIRECTIVE = CursorKind(265)\n# OpenMP distribute parallel for directive.\nCursorKind.OMP_DISTRIBUTE_PARALLELFOR_DIRECTIVE = CursorKind(266)\n# OpenMP distribute parallel for simd directive.\nCursorKind.OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(267)\n# OpenMP distribute simd directive.\nCursorKind.OMP_DISTRIBUTE_SIMD_DIRECTIVE = CursorKind(268)\n# OpenMP target parallel for simd directive.\nCursorKind.OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(269)\n# OpenMP target simd directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_DISTRIBUTE_PARALLELFOR_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_DISTRIBUTE_PARALLELFOR_DIRECTIVE = CursorKind(266)\n# OpenMP distribute parallel for simd directive.\nCursorKind.OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(267)\n# OpenMP distribute simd directive.\nCursorKind.OMP_DISTRIBUTE_SIMD_DIRECTIVE = CursorKind(268)\n# OpenMP target parallel for simd directive.\nCursorKind.OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(269)\n# OpenMP target simd directive.\nCursorKind.OMP_TARGET_SIMD_DIRECTIVE = CursorKind(270)\n# OpenMP teams distribute directive.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(267)\n# OpenMP distribute simd directive.\nCursorKind.OMP_DISTRIBUTE_SIMD_DIRECTIVE = CursorKind(268)\n# OpenMP target parallel for simd directive.\nCursorKind.OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(269)\n# OpenMP target simd directive.\nCursorKind.OMP_TARGET_SIMD_DIRECTIVE = CursorKind(270)\n# OpenMP teams distribute directive.\nCursorKind.OMP_TEAMS_DISTRIBUTE_DIRECTIVE = CursorKind(271)\n###",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_DISTRIBUTE_SIMD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_DISTRIBUTE_SIMD_DIRECTIVE = CursorKind(268)\n# OpenMP target parallel for simd directive.\nCursorKind.OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(269)\n# OpenMP target simd directive.\nCursorKind.OMP_TARGET_SIMD_DIRECTIVE = CursorKind(270)\n# OpenMP teams distribute directive.\nCursorKind.OMP_TEAMS_DISTRIBUTE_DIRECTIVE = CursorKind(271)\n###\n# Other Kinds\n# Cursor that represents the translation unit itself.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE = CursorKind(269)\n# OpenMP target simd directive.\nCursorKind.OMP_TARGET_SIMD_DIRECTIVE = CursorKind(270)\n# OpenMP teams distribute directive.\nCursorKind.OMP_TEAMS_DISTRIBUTE_DIRECTIVE = CursorKind(271)\n###\n# Other Kinds\n# Cursor that represents the translation unit itself.\n#\n# The translation unit cursor exists primarily to act as the root cursor for",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TARGET_SIMD_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TARGET_SIMD_DIRECTIVE = CursorKind(270)\n# OpenMP teams distribute directive.\nCursorKind.OMP_TEAMS_DISTRIBUTE_DIRECTIVE = CursorKind(271)\n###\n# Other Kinds\n# Cursor that represents the translation unit itself.\n#\n# The translation unit cursor exists primarily to act as the root cursor for\n# traversing the contents of a translation unit.\nCursorKind.TRANSLATION_UNIT = CursorKind(300)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OMP_TEAMS_DISTRIBUTE_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OMP_TEAMS_DISTRIBUTE_DIRECTIVE = CursorKind(271)\n###\n# Other Kinds\n# Cursor that represents the translation unit itself.\n#\n# The translation unit cursor exists primarily to act as the root cursor for\n# traversing the contents of a translation unit.\nCursorKind.TRANSLATION_UNIT = CursorKind(300)\n###\n# Attributes",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TRANSLATION_UNIT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TRANSLATION_UNIT = CursorKind(300)\n###\n# Attributes\n# An attribute whoe specific kind is note exposed via this interface\nCursorKind.UNEXPOSED_ATTR = CursorKind(400)\nCursorKind.IB_ACTION_ATTR = CursorKind(401)\nCursorKind.IB_OUTLET_ATTR = CursorKind(402)\nCursorKind.IB_OUTLET_COLLECTION_ATTR = CursorKind(403)\nCursorKind.CXX_FINAL_ATTR = CursorKind(404)\nCursorKind.CXX_OVERRIDE_ATTR = CursorKind(405)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.UNEXPOSED_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.UNEXPOSED_ATTR = CursorKind(400)\nCursorKind.IB_ACTION_ATTR = CursorKind(401)\nCursorKind.IB_OUTLET_ATTR = CursorKind(402)\nCursorKind.IB_OUTLET_COLLECTION_ATTR = CursorKind(403)\nCursorKind.CXX_FINAL_ATTR = CursorKind(404)\nCursorKind.CXX_OVERRIDE_ATTR = CursorKind(405)\nCursorKind.ANNOTATE_ATTR = CursorKind(406)\nCursorKind.ASM_LABEL_ATTR = CursorKind(407)\nCursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.IB_ACTION_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.IB_ACTION_ATTR = CursorKind(401)\nCursorKind.IB_OUTLET_ATTR = CursorKind(402)\nCursorKind.IB_OUTLET_COLLECTION_ATTR = CursorKind(403)\nCursorKind.CXX_FINAL_ATTR = CursorKind(404)\nCursorKind.CXX_OVERRIDE_ATTR = CursorKind(405)\nCursorKind.ANNOTATE_ATTR = CursorKind(406)\nCursorKind.ASM_LABEL_ATTR = CursorKind(407)\nCursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.IB_OUTLET_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.IB_OUTLET_ATTR = CursorKind(402)\nCursorKind.IB_OUTLET_COLLECTION_ATTR = CursorKind(403)\nCursorKind.CXX_FINAL_ATTR = CursorKind(404)\nCursorKind.CXX_OVERRIDE_ATTR = CursorKind(405)\nCursorKind.ANNOTATE_ATTR = CursorKind(406)\nCursorKind.ASM_LABEL_ATTR = CursorKind(407)\nCursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.IB_OUTLET_COLLECTION_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.IB_OUTLET_COLLECTION_ATTR = CursorKind(403)\nCursorKind.CXX_FINAL_ATTR = CursorKind(404)\nCursorKind.CXX_OVERRIDE_ATTR = CursorKind(405)\nCursorKind.ANNOTATE_ATTR = CursorKind(406)\nCursorKind.ASM_LABEL_ATTR = CursorKind(407)\nCursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_FINAL_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_FINAL_ATTR = CursorKind(404)\nCursorKind.CXX_OVERRIDE_ATTR = CursorKind(405)\nCursorKind.ANNOTATE_ATTR = CursorKind(406)\nCursorKind.ASM_LABEL_ATTR = CursorKind(407)\nCursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CXX_OVERRIDE_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CXX_OVERRIDE_ATTR = CursorKind(405)\nCursorKind.ANNOTATE_ATTR = CursorKind(406)\nCursorKind.ASM_LABEL_ATTR = CursorKind(407)\nCursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.ANNOTATE_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.ANNOTATE_ATTR = CursorKind(406)\nCursorKind.ASM_LABEL_ATTR = CursorKind(407)\nCursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.ASM_LABEL_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.ASM_LABEL_ATTR = CursorKind(407)\nCursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.PACKED_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.PACKED_ATTR = CursorKind(408)\nCursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.PURE_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.PURE_ATTR = CursorKind(409)\nCursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CONST_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CONST_ATTR = CursorKind(410)\nCursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.NODUPLICATE_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.NODUPLICATE_ATTR = CursorKind(411)\nCursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CUDACONSTANT_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CUDACONSTANT_ATTR = CursorKind(412)\nCursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###\n# Preprocessing",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CUDADEVICE_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CUDADEVICE_ATTR = CursorKind(413)\nCursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###\n# Preprocessing\nCursorKind.PREPROCESSING_DIRECTIVE = CursorKind(500)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CUDAGLOBAL_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CUDAGLOBAL_ATTR = CursorKind(414)\nCursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###\n# Preprocessing\nCursorKind.PREPROCESSING_DIRECTIVE = CursorKind(500)\nCursorKind.MACRO_DEFINITION = CursorKind(501)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CUDAHOST_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CUDAHOST_ATTR = CursorKind(415)\nCursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###\n# Preprocessing\nCursorKind.PREPROCESSING_DIRECTIVE = CursorKind(500)\nCursorKind.MACRO_DEFINITION = CursorKind(501)\nCursorKind.MACRO_INSTANTIATION = CursorKind(502)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.CUDASHARED_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.CUDASHARED_ATTR = CursorKind(416)\nCursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###\n# Preprocessing\nCursorKind.PREPROCESSING_DIRECTIVE = CursorKind(500)\nCursorKind.MACRO_DEFINITION = CursorKind(501)\nCursorKind.MACRO_INSTANTIATION = CursorKind(502)\nCursorKind.INCLUSION_DIRECTIVE = CursorKind(503)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.VISIBILITY_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.VISIBILITY_ATTR = CursorKind(417)\nCursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###\n# Preprocessing\nCursorKind.PREPROCESSING_DIRECTIVE = CursorKind(500)\nCursorKind.MACRO_DEFINITION = CursorKind(501)\nCursorKind.MACRO_INSTANTIATION = CursorKind(502)\nCursorKind.INCLUSION_DIRECTIVE = CursorKind(503)\n###",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.DLLEXPORT_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.DLLEXPORT_ATTR = CursorKind(418)\nCursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###\n# Preprocessing\nCursorKind.PREPROCESSING_DIRECTIVE = CursorKind(500)\nCursorKind.MACRO_DEFINITION = CursorKind(501)\nCursorKind.MACRO_INSTANTIATION = CursorKind(502)\nCursorKind.INCLUSION_DIRECTIVE = CursorKind(503)\n###\n# Extra declaration",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.DLLIMPORT_ATTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.DLLIMPORT_ATTR = CursorKind(419)\n###\n# Preprocessing\nCursorKind.PREPROCESSING_DIRECTIVE = CursorKind(500)\nCursorKind.MACRO_DEFINITION = CursorKind(501)\nCursorKind.MACRO_INSTANTIATION = CursorKind(502)\nCursorKind.INCLUSION_DIRECTIVE = CursorKind(503)\n###\n# Extra declaration\n# A module import declaration.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.PREPROCESSING_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.PREPROCESSING_DIRECTIVE = CursorKind(500)\nCursorKind.MACRO_DEFINITION = CursorKind(501)\nCursorKind.MACRO_INSTANTIATION = CursorKind(502)\nCursorKind.INCLUSION_DIRECTIVE = CursorKind(503)\n###\n# Extra declaration\n# A module import declaration.\nCursorKind.MODULE_IMPORT_DECL = CursorKind(600)\n# A type alias template declaration\nCursorKind.TYPE_ALIAS_TEMPLATE_DECL = CursorKind(601)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.MACRO_DEFINITION",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.MACRO_DEFINITION = CursorKind(501)\nCursorKind.MACRO_INSTANTIATION = CursorKind(502)\nCursorKind.INCLUSION_DIRECTIVE = CursorKind(503)\n###\n# Extra declaration\n# A module import declaration.\nCursorKind.MODULE_IMPORT_DECL = CursorKind(600)\n# A type alias template declaration\nCursorKind.TYPE_ALIAS_TEMPLATE_DECL = CursorKind(601)\n# A static_assert or _Static_assert node",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.MACRO_INSTANTIATION",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.MACRO_INSTANTIATION = CursorKind(502)\nCursorKind.INCLUSION_DIRECTIVE = CursorKind(503)\n###\n# Extra declaration\n# A module import declaration.\nCursorKind.MODULE_IMPORT_DECL = CursorKind(600)\n# A type alias template declaration\nCursorKind.TYPE_ALIAS_TEMPLATE_DECL = CursorKind(601)\n# A static_assert or _Static_assert node\nCursorKind.STATIC_ASSERT = CursorKind(602)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.INCLUSION_DIRECTIVE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.INCLUSION_DIRECTIVE = CursorKind(503)\n###\n# Extra declaration\n# A module import declaration.\nCursorKind.MODULE_IMPORT_DECL = CursorKind(600)\n# A type alias template declaration\nCursorKind.TYPE_ALIAS_TEMPLATE_DECL = CursorKind(601)\n# A static_assert or _Static_assert node\nCursorKind.STATIC_ASSERT = CursorKind(602)\n# A friend declaration",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.MODULE_IMPORT_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.MODULE_IMPORT_DECL = CursorKind(600)\n# A type alias template declaration\nCursorKind.TYPE_ALIAS_TEMPLATE_DECL = CursorKind(601)\n# A static_assert or _Static_assert node\nCursorKind.STATIC_ASSERT = CursorKind(602)\n# A friend declaration\nCursorKind.FRIEND_DECL = CursorKind(603)\n# A code completion overload candidate.\nCursorKind.OVERLOAD_CANDIDATE = CursorKind(700)\n### Template Argument Kinds ###",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.TYPE_ALIAS_TEMPLATE_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.TYPE_ALIAS_TEMPLATE_DECL = CursorKind(601)\n# A static_assert or _Static_assert node\nCursorKind.STATIC_ASSERT = CursorKind(602)\n# A friend declaration\nCursorKind.FRIEND_DECL = CursorKind(603)\n# A code completion overload candidate.\nCursorKind.OVERLOAD_CANDIDATE = CursorKind(700)\n### Template Argument Kinds ###\nclass TemplateArgumentKind(BaseEnumeration):\n    \"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.STATIC_ASSERT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.STATIC_ASSERT = CursorKind(602)\n# A friend declaration\nCursorKind.FRIEND_DECL = CursorKind(603)\n# A code completion overload candidate.\nCursorKind.OVERLOAD_CANDIDATE = CursorKind(700)\n### Template Argument Kinds ###\nclass TemplateArgumentKind(BaseEnumeration):\n    \"\"\"\n    A TemplateArgumentKind describes the kind of entity that a template argument\n    represents.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.FRIEND_DECL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.FRIEND_DECL = CursorKind(603)\n# A code completion overload candidate.\nCursorKind.OVERLOAD_CANDIDATE = CursorKind(700)\n### Template Argument Kinds ###\nclass TemplateArgumentKind(BaseEnumeration):\n    \"\"\"\n    A TemplateArgumentKind describes the kind of entity that a template argument\n    represents.\n    \"\"\"\n    # The required BaseEnumeration declarations.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "CursorKind.OVERLOAD_CANDIDATE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "CursorKind.OVERLOAD_CANDIDATE = CursorKind(700)\n### Template Argument Kinds ###\nclass TemplateArgumentKind(BaseEnumeration):\n    \"\"\"\n    A TemplateArgumentKind describes the kind of entity that a template argument\n    represents.\n    \"\"\"\n    # The required BaseEnumeration declarations.\n    _kinds = []\n    _name_map = None",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TemplateArgumentKind.NULL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TemplateArgumentKind.NULL = TemplateArgumentKind(0)\nTemplateArgumentKind.TYPE = TemplateArgumentKind(1)\nTemplateArgumentKind.DECLARATION = TemplateArgumentKind(2)\nTemplateArgumentKind.NULLPTR = TemplateArgumentKind(3)\nTemplateArgumentKind.INTEGRAL = TemplateArgumentKind(4)\n### Cursors ###\nclass Cursor(Structure):\n    \"\"\"\n    The Cursor class represents a reference to an element within the AST. It\n    acts as a kind of iterator.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TemplateArgumentKind.TYPE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TemplateArgumentKind.TYPE = TemplateArgumentKind(1)\nTemplateArgumentKind.DECLARATION = TemplateArgumentKind(2)\nTemplateArgumentKind.NULLPTR = TemplateArgumentKind(3)\nTemplateArgumentKind.INTEGRAL = TemplateArgumentKind(4)\n### Cursors ###\nclass Cursor(Structure):\n    \"\"\"\n    The Cursor class represents a reference to an element within the AST. It\n    acts as a kind of iterator.\n    \"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TemplateArgumentKind.DECLARATION",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TemplateArgumentKind.DECLARATION = TemplateArgumentKind(2)\nTemplateArgumentKind.NULLPTR = TemplateArgumentKind(3)\nTemplateArgumentKind.INTEGRAL = TemplateArgumentKind(4)\n### Cursors ###\nclass Cursor(Structure):\n    \"\"\"\n    The Cursor class represents a reference to an element within the AST. It\n    acts as a kind of iterator.\n    \"\"\"\n    _fields_ = [(\"_kind_id\", c_int), (\"xdata\", c_int), (\"data\", c_void_p * 3)]",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TemplateArgumentKind.NULLPTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TemplateArgumentKind.NULLPTR = TemplateArgumentKind(3)\nTemplateArgumentKind.INTEGRAL = TemplateArgumentKind(4)\n### Cursors ###\nclass Cursor(Structure):\n    \"\"\"\n    The Cursor class represents a reference to an element within the AST. It\n    acts as a kind of iterator.\n    \"\"\"\n    _fields_ = [(\"_kind_id\", c_int), (\"xdata\", c_int), (\"data\", c_void_p * 3)]\n    @staticmethod",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TemplateArgumentKind.INTEGRAL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TemplateArgumentKind.INTEGRAL = TemplateArgumentKind(4)\n### Cursors ###\nclass Cursor(Structure):\n    \"\"\"\n    The Cursor class represents a reference to an element within the AST. It\n    acts as a kind of iterator.\n    \"\"\"\n    _fields_ = [(\"_kind_id\", c_int), (\"xdata\", c_int), (\"data\", c_void_p * 3)]\n    @staticmethod\n    def from_location(tu, location):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass.INVALID",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "StorageClass.INVALID = StorageClass(0)\nStorageClass.NONE = StorageClass(1)\nStorageClass.EXTERN = StorageClass(2)\nStorageClass.STATIC = StorageClass(3)\nStorageClass.PRIVATEEXTERN = StorageClass(4)\nStorageClass.OPENCLWORKGROUPLOCAL = StorageClass(5)\nStorageClass.AUTO = StorageClass(6)\nStorageClass.REGISTER = StorageClass(7)\n### C++ access specifiers ###\nclass AccessSpecifier(BaseEnumeration):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass.NONE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "StorageClass.NONE = StorageClass(1)\nStorageClass.EXTERN = StorageClass(2)\nStorageClass.STATIC = StorageClass(3)\nStorageClass.PRIVATEEXTERN = StorageClass(4)\nStorageClass.OPENCLWORKGROUPLOCAL = StorageClass(5)\nStorageClass.AUTO = StorageClass(6)\nStorageClass.REGISTER = StorageClass(7)\n### C++ access specifiers ###\nclass AccessSpecifier(BaseEnumeration):\n    \"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass.EXTERN",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "StorageClass.EXTERN = StorageClass(2)\nStorageClass.STATIC = StorageClass(3)\nStorageClass.PRIVATEEXTERN = StorageClass(4)\nStorageClass.OPENCLWORKGROUPLOCAL = StorageClass(5)\nStorageClass.AUTO = StorageClass(6)\nStorageClass.REGISTER = StorageClass(7)\n### C++ access specifiers ###\nclass AccessSpecifier(BaseEnumeration):\n    \"\"\"\n    Describes the access of a C++ class member",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass.STATIC",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "StorageClass.STATIC = StorageClass(3)\nStorageClass.PRIVATEEXTERN = StorageClass(4)\nStorageClass.OPENCLWORKGROUPLOCAL = StorageClass(5)\nStorageClass.AUTO = StorageClass(6)\nStorageClass.REGISTER = StorageClass(7)\n### C++ access specifiers ###\nclass AccessSpecifier(BaseEnumeration):\n    \"\"\"\n    Describes the access of a C++ class member\n    \"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass.PRIVATEEXTERN",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "StorageClass.PRIVATEEXTERN = StorageClass(4)\nStorageClass.OPENCLWORKGROUPLOCAL = StorageClass(5)\nStorageClass.AUTO = StorageClass(6)\nStorageClass.REGISTER = StorageClass(7)\n### C++ access specifiers ###\nclass AccessSpecifier(BaseEnumeration):\n    \"\"\"\n    Describes the access of a C++ class member\n    \"\"\"\n    # The unique kind objects, index by id.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass.OPENCLWORKGROUPLOCAL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "StorageClass.OPENCLWORKGROUPLOCAL = StorageClass(5)\nStorageClass.AUTO = StorageClass(6)\nStorageClass.REGISTER = StorageClass(7)\n### C++ access specifiers ###\nclass AccessSpecifier(BaseEnumeration):\n    \"\"\"\n    Describes the access of a C++ class member\n    \"\"\"\n    # The unique kind objects, index by id.\n    _kinds = []",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass.AUTO",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "StorageClass.AUTO = StorageClass(6)\nStorageClass.REGISTER = StorageClass(7)\n### C++ access specifiers ###\nclass AccessSpecifier(BaseEnumeration):\n    \"\"\"\n    Describes the access of a C++ class member\n    \"\"\"\n    # The unique kind objects, index by id.\n    _kinds = []\n    _name_map = None",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "StorageClass.REGISTER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "StorageClass.REGISTER = StorageClass(7)\n### C++ access specifiers ###\nclass AccessSpecifier(BaseEnumeration):\n    \"\"\"\n    Describes the access of a C++ class member\n    \"\"\"\n    # The unique kind objects, index by id.\n    _kinds = []\n    _name_map = None\n    def from_param(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "AccessSpecifier.INVALID",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "AccessSpecifier.INVALID = AccessSpecifier(0)\nAccessSpecifier.PUBLIC = AccessSpecifier(1)\nAccessSpecifier.PROTECTED = AccessSpecifier(2)\nAccessSpecifier.PRIVATE = AccessSpecifier(3)\nAccessSpecifier.NONE = AccessSpecifier(4)\n### Type Kinds ###\nclass TypeKind(BaseEnumeration):\n    \"\"\"\n    Describes the kind of type.\n    \"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "AccessSpecifier.PUBLIC",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "AccessSpecifier.PUBLIC = AccessSpecifier(1)\nAccessSpecifier.PROTECTED = AccessSpecifier(2)\nAccessSpecifier.PRIVATE = AccessSpecifier(3)\nAccessSpecifier.NONE = AccessSpecifier(4)\n### Type Kinds ###\nclass TypeKind(BaseEnumeration):\n    \"\"\"\n    Describes the kind of type.\n    \"\"\"\n    # The unique kind objects, indexed by id.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "AccessSpecifier.PROTECTED",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "AccessSpecifier.PROTECTED = AccessSpecifier(2)\nAccessSpecifier.PRIVATE = AccessSpecifier(3)\nAccessSpecifier.NONE = AccessSpecifier(4)\n### Type Kinds ###\nclass TypeKind(BaseEnumeration):\n    \"\"\"\n    Describes the kind of type.\n    \"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "AccessSpecifier.PRIVATE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "AccessSpecifier.PRIVATE = AccessSpecifier(3)\nAccessSpecifier.NONE = AccessSpecifier(4)\n### Type Kinds ###\nclass TypeKind(BaseEnumeration):\n    \"\"\"\n    Describes the kind of type.\n    \"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "AccessSpecifier.NONE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "AccessSpecifier.NONE = AccessSpecifier(4)\n### Type Kinds ###\nclass TypeKind(BaseEnumeration):\n    \"\"\"\n    Describes the kind of type.\n    \"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None\n    @property",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.INVALID",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.INVALID = TypeKind(0)\nTypeKind.UNEXPOSED = TypeKind(1)\nTypeKind.VOID = TypeKind(2)\nTypeKind.BOOL = TypeKind(3)\nTypeKind.CHAR_U = TypeKind(4)\nTypeKind.UCHAR = TypeKind(5)\nTypeKind.CHAR16 = TypeKind(6)\nTypeKind.CHAR32 = TypeKind(7)\nTypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.UNEXPOSED",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.UNEXPOSED = TypeKind(1)\nTypeKind.VOID = TypeKind(2)\nTypeKind.BOOL = TypeKind(3)\nTypeKind.CHAR_U = TypeKind(4)\nTypeKind.UCHAR = TypeKind(5)\nTypeKind.CHAR16 = TypeKind(6)\nTypeKind.CHAR32 = TypeKind(7)\nTypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.VOID",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.VOID = TypeKind(2)\nTypeKind.BOOL = TypeKind(3)\nTypeKind.CHAR_U = TypeKind(4)\nTypeKind.UCHAR = TypeKind(5)\nTypeKind.CHAR16 = TypeKind(6)\nTypeKind.CHAR32 = TypeKind(7)\nTypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.BOOL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.BOOL = TypeKind(3)\nTypeKind.CHAR_U = TypeKind(4)\nTypeKind.UCHAR = TypeKind(5)\nTypeKind.CHAR16 = TypeKind(6)\nTypeKind.CHAR32 = TypeKind(7)\nTypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.CHAR_U",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.CHAR_U = TypeKind(4)\nTypeKind.UCHAR = TypeKind(5)\nTypeKind.CHAR16 = TypeKind(6)\nTypeKind.CHAR32 = TypeKind(7)\nTypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.UCHAR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.UCHAR = TypeKind(5)\nTypeKind.CHAR16 = TypeKind(6)\nTypeKind.CHAR32 = TypeKind(7)\nTypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.CHAR16",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.CHAR16 = TypeKind(6)\nTypeKind.CHAR32 = TypeKind(7)\nTypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.CHAR32",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.CHAR32 = TypeKind(7)\nTypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.USHORT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.USHORT = TypeKind(8)\nTypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.UINT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.UINT = TypeKind(9)\nTypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.ULONG",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.ULONG = TypeKind(10)\nTypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.ULONGLONG",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.ULONGLONG = TypeKind(11)\nTypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.UINT128",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.UINT128 = TypeKind(12)\nTypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.CHAR_S",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.CHAR_S = TypeKind(13)\nTypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.SCHAR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.SCHAR = TypeKind(14)\nTypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.WCHAR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.WCHAR = TypeKind(15)\nTypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.SHORT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.SHORT = TypeKind(16)\nTypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.INT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.INT = TypeKind(17)\nTypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.LONG",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.LONG = TypeKind(18)\nTypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.LONGLONG",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.LONGLONG = TypeKind(19)\nTypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.INT128",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.INT128 = TypeKind(20)\nTypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.FLOAT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.FLOAT = TypeKind(21)\nTypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.DOUBLE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.DOUBLE = TypeKind(22)\nTypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.LONGDOUBLE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.LONGDOUBLE = TypeKind(23)\nTypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.NULLPTR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.NULLPTR = TypeKind(24)\nTypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.OVERLOAD",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.OVERLOAD = TypeKind(25)\nTypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.DEPENDENT",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.DEPENDENT = TypeKind(26)\nTypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.OBJCID",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.OBJCID = TypeKind(27)\nTypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.OBJCCLASS",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.OBJCCLASS = TypeKind(28)\nTypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.OBJCSEL",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.OBJCSEL = TypeKind(29)\nTypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.FLOAT128",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.FLOAT128 = TypeKind(30)\nTypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.HALF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.HALF = TypeKind(31)\nTypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.COMPLEX",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.COMPLEX = TypeKind(100)\nTypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.POINTER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.POINTER = TypeKind(101)\nTypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.BLOCKPOINTER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.BLOCKPOINTER = TypeKind(102)\nTypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.LVALUEREFERENCE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.LVALUEREFERENCE = TypeKind(103)\nTypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.RVALUEREFERENCE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.RVALUEREFERENCE = TypeKind(104)\nTypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.RECORD",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.RECORD = TypeKind(105)\nTypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.ENUM",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.ENUM = TypeKind(106)\nTypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.TYPEDEF",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.TYPEDEF = TypeKind(107)\nTypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.OBJCINTERFACE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.OBJCINTERFACE = TypeKind(108)\nTypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.OBJCOBJECTPOINTER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.OBJCOBJECTPOINTER = TypeKind(109)\nTypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.FUNCTIONNOPROTO",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.FUNCTIONNOPROTO = TypeKind(110)\nTypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.FUNCTIONPROTO",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.FUNCTIONPROTO = TypeKind(111)\nTypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.CONSTANTARRAY",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.CONSTANTARRAY = TypeKind(112)\nTypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.VECTOR",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.VECTOR = TypeKind(113)\nTypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"\n    # The unique kind objects, indexed by id.",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.INCOMPLETEARRAY",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.INCOMPLETEARRAY = TypeKind(114)\nTypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.VARIABLEARRAY",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.VARIABLEARRAY = TypeKind(115)\nTypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.DEPENDENTSIZEDARRAY",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.DEPENDENTSIZEDARRAY = TypeKind(116)\nTypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None\n    def from_param(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.MEMBERPOINTER",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.MEMBERPOINTER = TypeKind(117)\nTypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None\n    def from_param(self):\n        return self.value",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.AUTO",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.AUTO = TypeKind(118)\nTypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None\n    def from_param(self):\n        return self.value\n    def __repr__(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TypeKind.ELABORATED",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "TypeKind.ELABORATED = TypeKind(119)\nclass RefQualifierKind(BaseEnumeration):\n    \"\"\"Describes a specific ref-qualifier of a type.\"\"\"\n    # The unique kind objects, indexed by id.\n    _kinds = []\n    _name_map = None\n    def from_param(self):\n        return self.value\n    def __repr__(self):\n        return 'RefQualifierKind.%s' % (self.name,)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "RefQualifierKind.NONE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "RefQualifierKind.NONE = RefQualifierKind(0)\nRefQualifierKind.LVALUE = RefQualifierKind(1)\nRefQualifierKind.RVALUE = RefQualifierKind(2)\nclass Type(Structure):\n    \"\"\"\n    The type of an element in the abstract syntax tree.\n    \"\"\"\n    _fields_ = [(\"_kind_id\", c_int), (\"data\", c_void_p * 2)]\n    @property\n    def kind(self):",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "RefQualifierKind.LVALUE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "RefQualifierKind.LVALUE = RefQualifierKind(1)\nRefQualifierKind.RVALUE = RefQualifierKind(2)\nclass Type(Structure):\n    \"\"\"\n    The type of an element in the abstract syntax tree.\n    \"\"\"\n    _fields_ = [(\"_kind_id\", c_int), (\"data\", c_void_p * 2)]\n    @property\n    def kind(self):\n        \"\"\"Return the kind of this type.\"\"\"",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "RefQualifierKind.RVALUE",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "RefQualifierKind.RVALUE = RefQualifierKind(2)\nclass Type(Structure):\n    \"\"\"\n    The type of an element in the abstract syntax tree.\n    \"\"\"\n    _fields_ = [(\"_kind_id\", c_int), (\"data\", c_void_p * 2)]\n    @property\n    def kind(self):\n        \"\"\"Return the kind of this type.\"\"\"\n        return TypeKind.from_id(self._kind_id)",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "SpellingCache",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "SpellingCache = {\n            # 0: CompletionChunk.Kind(\"Optional\"),\n            # 1: CompletionChunk.Kind(\"TypedText\"),\n            # 2: CompletionChunk.Kind(\"Text\"),\n            # 3: CompletionChunk.Kind(\"Placeholder\"),\n            # 4: CompletionChunk.Kind(\"Informative\"),\n            # 5 : CompletionChunk.Kind(\"CurrentParameter\"),\n            6: '(',   # CompletionChunk.Kind(\"LeftParen\"),\n            7: ')',   # CompletionChunk.Kind(\"RightParen\"),\n            8: '[',   # CompletionChunk.Kind(\"LeftBracket\"),",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "completionChunkKindMap",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "completionChunkKindMap = {\n            0: CompletionChunk.Kind(\"Optional\"),\n            1: CompletionChunk.Kind(\"TypedText\"),\n            2: CompletionChunk.Kind(\"Text\"),\n            3: CompletionChunk.Kind(\"Placeholder\"),\n            4: CompletionChunk.Kind(\"Informative\"),\n            5: CompletionChunk.Kind(\"CurrentParameter\"),\n            6: CompletionChunk.Kind(\"LeftParen\"),\n            7: CompletionChunk.Kind(\"RightParen\"),\n            8: CompletionChunk.Kind(\"LeftBracket\"),",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "availabilityKinds",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "availabilityKinds = {\n            0: CompletionChunk.Kind(\"Available\"),\n            1: CompletionChunk.Kind(\"Deprecated\"),\n            2: CompletionChunk.Kind(\"NotAvailable\"),\n            3: CompletionChunk.Kind(\"NotAccessible\")}\nclass CodeCompletionResult(Structure):\n    _fields_ = [('cursorKind', c_int), ('completionString', c_object_p)]\n    def __repr__(self):\n        return str(CompletionString(self.completionString))\n    @property",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "callbacks['translation_unit_includes']",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "callbacks['translation_unit_includes'] = CFUNCTYPE(None, c_object_p,\n        POINTER(SourceLocation), c_uint, py_object)\ncallbacks['cursor_visit'] = CFUNCTYPE(c_int, Cursor, Cursor, py_object)\ncallbacks['fields_visit'] = CFUNCTYPE(c_int, Cursor, py_object)\n# Functions strictly alphabetical order.\nfunctionList = [\n  (\"clang_annotateTokens\",\n   [TranslationUnit, POINTER(Token), c_uint, POINTER(Cursor)]),\n  (\"clang_CompilationDatabase_dispose\",\n   [c_object_p]),",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "callbacks['cursor_visit']",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "callbacks['cursor_visit'] = CFUNCTYPE(c_int, Cursor, Cursor, py_object)\ncallbacks['fields_visit'] = CFUNCTYPE(c_int, Cursor, py_object)\n# Functions strictly alphabetical order.\nfunctionList = [\n  (\"clang_annotateTokens\",\n   [TranslationUnit, POINTER(Token), c_uint, POINTER(Cursor)]),\n  (\"clang_CompilationDatabase_dispose\",\n   [c_object_p]),\n  (\"clang_CompilationDatabase_fromDirectory\",\n   [c_char_p, POINTER(c_uint)],",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "callbacks['fields_visit']",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "callbacks['fields_visit'] = CFUNCTYPE(c_int, Cursor, py_object)\n# Functions strictly alphabetical order.\nfunctionList = [\n  (\"clang_annotateTokens\",\n   [TranslationUnit, POINTER(Token), c_uint, POINTER(Cursor)]),\n  (\"clang_CompilationDatabase_dispose\",\n   [c_object_p]),\n  (\"clang_CompilationDatabase_fromDirectory\",\n   [c_char_p, POINTER(c_uint)],\n   c_object_p,",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "functionList",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "functionList = [\n  (\"clang_annotateTokens\",\n   [TranslationUnit, POINTER(Token), c_uint, POINTER(Cursor)]),\n  (\"clang_CompilationDatabase_dispose\",\n   [c_object_p]),\n  (\"clang_CompilationDatabase_fromDirectory\",\n   [c_char_p, POINTER(c_uint)],\n   c_object_p,\n   CompilationDatabase.from_result),\n  (\"clang_CompilationDatabase_getAllCompileCommands\",",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "conf",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "conf = Config()\nregister_enumerations()\n__all__ = [\n    'Config',\n    'CodeCompletionResults',\n    'CompilationDatabase',\n    'CompileCommands',\n    'CompileCommand',\n    'CursorKind',\n    'Cursor',",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pybind11.tools.clang.cindex",
        "description": "pybind11.tools.clang.cindex",
        "peekOfCode": "__all__ = [\n    'Config',\n    'CodeCompletionResults',\n    'CompilationDatabase',\n    'CompileCommands',\n    'CompileCommand',\n    'CursorKind',\n    'Cursor',\n    'Diagnostic',\n    'File',",
        "detail": "pybind11.tools.clang.cindex",
        "documentation": {}
    },
    {
        "label": "TokenKinds",
        "kind": 5,
        "importPath": "pybind11.tools.clang.enumerations",
        "description": "pybind11.tools.clang.enumerations",
        "peekOfCode": "TokenKinds = [\n    ('PUNCTUATION', 0),\n    ('KEYWORD', 1),\n    ('IDENTIFIER', 2),\n    ('LITERAL', 3),\n    ('COMMENT', 4),\n]\n__all__ = ['TokenKinds']",
        "detail": "pybind11.tools.clang.enumerations",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pybind11.tools.clang.enumerations",
        "description": "pybind11.tools.clang.enumerations",
        "peekOfCode": "__all__ = ['TokenKinds']",
        "detail": "pybind11.tools.clang.enumerations",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "pybind11.tools.libsize",
        "description": "pybind11.tools.libsize",
        "peekOfCode": "lib = sys.argv[1]\nsave = sys.argv[2]\nif not os.path.exists(lib):\n    sys.exit(\"Error: requested file ({}) does not exist\".format(lib))\nlibsize = os.path.getsize(lib)\nprint(\"------\", os.path.basename(lib), \"file size:\", libsize, end='')\nif os.path.exists(save):\n    with open(save) as sf:\n        oldsize = int(sf.readline())\n    if oldsize > 0:",
        "detail": "pybind11.tools.libsize",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 5,
        "importPath": "pybind11.tools.libsize",
        "description": "pybind11.tools.libsize",
        "peekOfCode": "save = sys.argv[2]\nif not os.path.exists(lib):\n    sys.exit(\"Error: requested file ({}) does not exist\".format(lib))\nlibsize = os.path.getsize(lib)\nprint(\"------\", os.path.basename(lib), \"file size:\", libsize, end='')\nif os.path.exists(save):\n    with open(save) as sf:\n        oldsize = int(sf.readline())\n    if oldsize > 0:\n        change = libsize - oldsize",
        "detail": "pybind11.tools.libsize",
        "documentation": {}
    },
    {
        "label": "libsize",
        "kind": 5,
        "importPath": "pybind11.tools.libsize",
        "description": "pybind11.tools.libsize",
        "peekOfCode": "libsize = os.path.getsize(lib)\nprint(\"------\", os.path.basename(lib), \"file size:\", libsize, end='')\nif os.path.exists(save):\n    with open(save) as sf:\n        oldsize = int(sf.readline())\n    if oldsize > 0:\n        change = libsize - oldsize\n        if change == 0:\n            print(\" (no change)\")\n        else:",
        "detail": "pybind11.tools.libsize",
        "documentation": {}
    },
    {
        "label": "NoFilenamesError",
        "kind": 6,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "class NoFilenamesError(ValueError):\n    pass\ndef d(s):\n    return s if isinstance(s, str) else s.decode('utf8')\ndef sanitize_name(name):\n    name = re.sub(r'type-parameter-0-([0-9]+)', r'T\\1', name)\n    for k, v in CPP_OPERATORS.items():\n        name = name.replace('operator%s' % k, 'operator_%s' % v)\n    name = re.sub('<.*>', '', name)\n    name = ''.join([ch if ch.isalnum() else '_' for ch in name])",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "ExtractionThread",
        "kind": 6,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "class ExtractionThread(Thread):\n    def __init__(self, filename, parameters, output):\n        Thread.__init__(self)\n        self.filename = filename\n        self.parameters = parameters\n        self.output = output\n        job_semaphore.acquire()\n    def run(self):\n        print('Processing \"%s\" ..' % self.filename, file=sys.stderr)\n        try:",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 2,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "def d(s):\n    return s if isinstance(s, str) else s.decode('utf8')\ndef sanitize_name(name):\n    name = re.sub(r'type-parameter-0-([0-9]+)', r'T\\1', name)\n    for k, v in CPP_OPERATORS.items():\n        name = name.replace('operator%s' % k, 'operator_%s' % v)\n    name = re.sub('<.*>', '', name)\n    name = ''.join([ch if ch.isalnum() else '_' for ch in name])\n    name = re.sub('_$', '', re.sub('_+', '_', name))\n    return '__doc_' + name",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "sanitize_name",
        "kind": 2,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "def sanitize_name(name):\n    name = re.sub(r'type-parameter-0-([0-9]+)', r'T\\1', name)\n    for k, v in CPP_OPERATORS.items():\n        name = name.replace('operator%s' % k, 'operator_%s' % v)\n    name = re.sub('<.*>', '', name)\n    name = ''.join([ch if ch.isalnum() else '_' for ch in name])\n    name = re.sub('_$', '', re.sub('_+', '_', name))\n    return '__doc_' + name\ndef process_comment(comment):\n    result = ''",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "process_comment",
        "kind": 2,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "def process_comment(comment):\n    result = ''\n    # Remove C++ comment syntax\n    leading_spaces = float('inf')\n    for s in comment.expandtabs(tabsize=4).splitlines():\n        s = s.strip()\n        if s.startswith('/*'):\n            s = s[2:].lstrip('*')\n        elif s.endswith('*/'):\n            s = s[:-2].rstrip('*')",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "extract",
        "kind": 2,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "def extract(filename, node, prefix, output):\n    if not (node.location.file is None or\n            os.path.samefile(d(node.location.file.name), filename)):\n        return 0\n    if node.kind in RECURSE_LIST:\n        sub_prefix = prefix\n        if node.kind not in PREFIX_BLACKLIST:\n            if len(sub_prefix) > 0:\n                sub_prefix += '_'\n            sub_prefix += d(node.spelling)",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "read_args",
        "kind": 2,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "def read_args(args):\n    parameters = []\n    filenames = []\n    if \"-x\" not in args:\n        parameters.extend(['-x', 'c++'])\n    if not any(it.startswith(\"-std=\") for it in args):\n        parameters.append('-std=c++11')\n    if platform.system() == 'Darwin':\n        dev_path = '/Applications/Xcode.app/Contents/Developer/'\n        lib_dir = dev_path + 'Toolchains/XcodeDefault.xctoolchain/usr/lib/'",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "extract_all",
        "kind": 2,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "def extract_all(args):\n    parameters, filenames = read_args(args)\n    output = []\n    for filename in filenames:\n        thr = ExtractionThread(filename, parameters, output)\n        thr.start()\n    print('Waiting for jobs to finish ..', file=sys.stderr)\n    for i in range(job_count):\n        job_semaphore.acquire()\n    return output",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "write_header",
        "kind": 2,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "def write_header(comments, out_file=sys.stdout):\n    print('''/*\n  This file contains docstrings for the Python bindings.\n  Do not edit! These were automatically extracted by mkdoc.py\n */\n#define __EXPAND(x)                                      x\n#define __COUNT(_1, _2, _3, _4, _5, _6, _7, COUNT, ...)  COUNT\n#define __VA_SIZE(...)                                   __EXPAND(__COUNT(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1))\n#define __CAT1(a, b)                                     a ## b\n#define __CAT2(a, b)                                     __CAT1(a, b)",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "mkdoc",
        "kind": 2,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "def mkdoc(args):\n    args = list(args)\n    out_path = None\n    for idx, arg in enumerate(args):\n        if arg.startswith(\"-o\"):\n            args.remove(arg)\n            try:\n                out_path = arg[2:] or args.pop(idx)\n            except IndexError:\n                print(\"-o flag requires an argument\")",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "RECURSE_LIST",
        "kind": 5,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "RECURSE_LIST = [\n    CursorKind.TRANSLATION_UNIT,\n    CursorKind.NAMESPACE,\n    CursorKind.CLASS_DECL,\n    CursorKind.STRUCT_DECL,\n    CursorKind.ENUM_DECL,\n    CursorKind.CLASS_TEMPLATE\n]\nPRINT_LIST = [\n    CursorKind.CLASS_DECL,",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "PRINT_LIST",
        "kind": 5,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "PRINT_LIST = [\n    CursorKind.CLASS_DECL,\n    CursorKind.STRUCT_DECL,\n    CursorKind.ENUM_DECL,\n    CursorKind.ENUM_CONSTANT_DECL,\n    CursorKind.CLASS_TEMPLATE,\n    CursorKind.FUNCTION_DECL,\n    CursorKind.FUNCTION_TEMPLATE,\n    CursorKind.CONVERSION_FUNCTION,\n    CursorKind.CXX_METHOD,",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "PREFIX_BLACKLIST",
        "kind": 5,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "PREFIX_BLACKLIST = [\n    CursorKind.TRANSLATION_UNIT\n]\nCPP_OPERATORS = {\n    '<=': 'le', '>=': 'ge', '==': 'eq', '!=': 'ne', '[]': 'array',\n    '+=': 'iadd', '-=': 'isub', '*=': 'imul', '/=': 'idiv', '%=':\n    'imod', '&=': 'iand', '|=': 'ior', '^=': 'ixor', '<<=': 'ilshift',\n    '>>=': 'irshift', '++': 'inc', '--': 'dec', '<<': 'lshift', '>>':\n    'rshift', '&&': 'land', '||': 'lor', '!': 'lnot', '~': 'bnot',\n    '&': 'band', '|': 'bor', '+': 'add', '-': 'sub', '*': 'mul', '/':",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "CPP_OPERATORS",
        "kind": 5,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "CPP_OPERATORS = {\n    '<=': 'le', '>=': 'ge', '==': 'eq', '!=': 'ne', '[]': 'array',\n    '+=': 'iadd', '-=': 'isub', '*=': 'imul', '/=': 'idiv', '%=':\n    'imod', '&=': 'iand', '|=': 'ior', '^=': 'ixor', '<<=': 'ilshift',\n    '>>=': 'irshift', '++': 'inc', '--': 'dec', '<<': 'lshift', '>>':\n    'rshift', '&&': 'land', '||': 'lor', '!': 'lnot', '~': 'bnot',\n    '&': 'band', '|': 'bor', '+': 'add', '-': 'sub', '*': 'mul', '/':\n    'div', '%': 'mod', '<': 'lt', '>': 'gt', '=': 'assign', '()': 'call'\n}\nCPP_OPERATORS = OrderedDict(",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "CPP_OPERATORS",
        "kind": 5,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "CPP_OPERATORS = OrderedDict(\n    sorted(CPP_OPERATORS.items(), key=lambda t: -len(t[0])))\njob_count = cpu_count()\njob_semaphore = Semaphore(job_count)\nclass NoFilenamesError(ValueError):\n    pass\ndef d(s):\n    return s if isinstance(s, str) else s.decode('utf8')\ndef sanitize_name(name):\n    name = re.sub(r'type-parameter-0-([0-9]+)', r'T\\1', name)",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "job_count",
        "kind": 5,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "job_count = cpu_count()\njob_semaphore = Semaphore(job_count)\nclass NoFilenamesError(ValueError):\n    pass\ndef d(s):\n    return s if isinstance(s, str) else s.decode('utf8')\ndef sanitize_name(name):\n    name = re.sub(r'type-parameter-0-([0-9]+)', r'T\\1', name)\n    for k, v in CPP_OPERATORS.items():\n        name = name.replace('operator%s' % k, 'operator_%s' % v)",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "job_semaphore",
        "kind": 5,
        "importPath": "pybind11.tools.mkdoc",
        "description": "pybind11.tools.mkdoc",
        "peekOfCode": "job_semaphore = Semaphore(job_count)\nclass NoFilenamesError(ValueError):\n    pass\ndef d(s):\n    return s if isinstance(s, str) else s.decode('utf8')\ndef sanitize_name(name):\n    name = re.sub(r'type-parameter-0-([0-9]+)', r'T\\1', name)\n    for k, v in CPP_OPERATORS.items():\n        name = name.replace('operator%s' % k, 'operator_%s' % v)\n    name = re.sub('<.*>', '', name)",
        "detail": "pybind11.tools.mkdoc",
        "documentation": {}
    },
    {
        "label": "InstallHeaders",
        "kind": 6,
        "importPath": "pybind11.setup",
        "description": "pybind11.setup",
        "peekOfCode": "class InstallHeaders(install_headers):\n    \"\"\"Use custom header installer because the default one flattens subdirectories\"\"\"\n    def run(self):\n        if not self.distribution.headers:\n            return\n        for header in self.distribution.headers:\n            subdir = os.path.dirname(os.path.relpath(header, 'include/pybind11'))\n            install_dir = os.path.join(self.install_dir, subdir)\n            self.mkpath(install_dir)\n            (out, _) = self.copy_file(header, install_dir)",
        "detail": "pybind11.setup",
        "documentation": {}
    },
    {
        "label": "BuildPy",
        "kind": 6,
        "importPath": "pybind11.setup",
        "description": "pybind11.setup",
        "peekOfCode": "class BuildPy(build_py):\n    def build_package_data(self):\n        build_py.build_package_data(self)\n        for header in package_data:\n            target = os.path.join(self.build_lib, 'pybind11', header)\n            self.mkpath(os.path.dirname(target))\n            self.copy_file(header, target, preserve_mode=False)\n    def get_outputs(self, include_bytecode=1):\n        outputs = build_py.get_outputs(self, include_bytecode=include_bytecode)\n        for header in package_data:",
        "detail": "pybind11.setup",
        "documentation": {}
    },
    {
        "label": "package_data",
        "kind": 5,
        "importPath": "pybind11.setup",
        "description": "pybind11.setup",
        "peekOfCode": "package_data = [\n    'include/pybind11/detail/class.h',\n    'include/pybind11/detail/common.h',\n    'include/pybind11/detail/descr.h',\n    'include/pybind11/detail/init.h',\n    'include/pybind11/detail/internals.h',\n    'include/pybind11/detail/typeid.h',\n    'include/pybind11/attr.h',\n    'include/pybind11/buffer_info.h',\n    'include/pybind11/cast.h',",
        "detail": "pybind11.setup",
        "documentation": {}
    },
    {
        "label": "LinearGradient",
        "kind": 6,
        "importPath": "pydiffvg.color",
        "description": "pydiffvg.color",
        "peekOfCode": "class LinearGradient:\n    def __init__(self,\n                 begin = torch.tensor([0.0, 0.0]),\n                 end = torch.tensor([0.0, 0.0]),\n                 offsets = torch.tensor([0.0]),\n                 stop_colors = torch.tensor([0.0, 0.0, 0.0, 0.0])):\n        self.begin = begin\n        self.end = end\n        self.offsets = offsets\n        self.stop_colors = stop_colors",
        "detail": "pydiffvg.color",
        "documentation": {}
    },
    {
        "label": "RadialGradient",
        "kind": 6,
        "importPath": "pydiffvg.color",
        "description": "pydiffvg.color",
        "peekOfCode": "class RadialGradient:\n    def __init__(self,\n                 center = torch.tensor([0.0, 0.0]),\n                 radius = torch.tensor([0.0, 0.0]),\n                 offsets = torch.tensor([0.0]),\n                 stop_colors = torch.tensor([0.0, 0.0, 0.0, 0.0])):\n        self.center = center\n        self.radius = radius\n        self.offsets = offsets\n        self.stop_colors = stop_colors",
        "detail": "pydiffvg.color",
        "documentation": {}
    },
    {
        "label": "set_use_gpu",
        "kind": 2,
        "importPath": "pydiffvg.device",
        "description": "pydiffvg.device",
        "peekOfCode": "def set_use_gpu(v):\n    global use_gpu\n    global device\n    use_gpu = v\n    if not use_gpu:\n        device = torch.device('cpu')\ndef get_use_gpu():\n    global use_gpu\n    return use_gpu\ndef set_device(d):",
        "detail": "pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "get_use_gpu",
        "kind": 2,
        "importPath": "pydiffvg.device",
        "description": "pydiffvg.device",
        "peekOfCode": "def get_use_gpu():\n    global use_gpu\n    return use_gpu\ndef set_device(d):\n    global device\n    global use_gpu\n    device = d\n    use_gpu = device.type == 'cuda'\ndef get_device():\n    global device",
        "detail": "pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "set_device",
        "kind": 2,
        "importPath": "pydiffvg.device",
        "description": "pydiffvg.device",
        "peekOfCode": "def set_device(d):\n    global device\n    global use_gpu\n    device = d\n    use_gpu = device.type == 'cuda'\ndef get_device():\n    global device\n    return device",
        "detail": "pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "get_device",
        "kind": 2,
        "importPath": "pydiffvg.device",
        "description": "pydiffvg.device",
        "peekOfCode": "def get_device():\n    global device\n    return device",
        "detail": "pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "use_gpu",
        "kind": 5,
        "importPath": "pydiffvg.device",
        "description": "pydiffvg.device",
        "peekOfCode": "use_gpu = torch.cuda.is_available()\ndevice = torch.device('cuda') if use_gpu else torch.device('cpu')\ndef set_use_gpu(v):\n    global use_gpu\n    global device\n    use_gpu = v\n    if not use_gpu:\n        device = torch.device('cpu')\ndef get_use_gpu():\n    global use_gpu",
        "detail": "pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "pydiffvg.device",
        "description": "pydiffvg.device",
        "peekOfCode": "device = torch.device('cuda') if use_gpu else torch.device('cpu')\ndef set_use_gpu(v):\n    global use_gpu\n    global device\n    use_gpu = v\n    if not use_gpu:\n        device = torch.device('cpu')\ndef get_use_gpu():\n    global use_gpu\n    return use_gpu",
        "detail": "pydiffvg.device",
        "documentation": {}
    },
    {
        "label": "imwrite",
        "kind": 2,
        "importPath": "pydiffvg.image",
        "description": "pydiffvg.image",
        "peekOfCode": "def imwrite(img, filename, gamma = 2.2, normalize = False):\n    directory = os.path.dirname(filename)\n    if directory != '' and not os.path.exists(directory):\n        os.makedirs(directory)\n    if not isinstance(img, np.ndarray):\n        img = img.data.numpy()\n    if normalize:\n        img_rng = np.max(img) - np.min(img)\n        if img_rng > 0:\n            img = (img - np.min(img)) / img_rng",
        "detail": "pydiffvg.image",
        "documentation": {}
    },
    {
        "label": "SvgOptimizationSettings",
        "kind": 6,
        "importPath": "pydiffvg.optimize_svg",
        "description": "pydiffvg.optimize_svg",
        "peekOfCode": "class SvgOptimizationSettings:\n    default_params = {\n        \"optimize_color\": True,\n        \"color_lr\": 2e-3,\n        \"optimize_alpha\": False,\n        \"alpha_lr\": 2e-3,\n        \"optimizer\": \"Adam\",\n        \"transforms\": {\n            \"optimize_transforms\":True,\n            \"transform_mode\":\"rigid\",",
        "detail": "pydiffvg.optimize_svg",
        "documentation": {}
    },
    {
        "label": "OptimizableSvg",
        "kind": 6,
        "importPath": "pydiffvg.optimize_svg",
        "description": "pydiffvg.optimize_svg",
        "peekOfCode": "class OptimizableSvg:\n    class TransformTools:\n        @staticmethod\n        def parse_matrix(vals):\n            assert(len(vals)==6)\n            return np.array([[vals[0],vals[2],vals[4]],[vals[1], vals[3], vals[5]],[0,0,1]])\n        @staticmethod\n        def parse_translate(vals):\n            assert(len(vals)>=1 and len(vals)<=2)\n            mat=np.eye(3)",
        "detail": "pydiffvg.optimize_svg",
        "documentation": {}
    },
    {
        "label": "remove_namespaces",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def remove_namespaces(s):\n    \"\"\"\n        {...} ... -> ...\n    \"\"\"\n    return re.sub('{.*}', '', s)\ndef parse_style(s, defs):\n    style_dict = {}\n    for e in s.split(';'):\n        key_value = e.split(':')\n        if len(key_value) == 2:",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_style",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_style(s, defs):\n    style_dict = {}\n    for e in s.split(';'):\n        key_value = e.split(':')\n        if len(key_value) == 2:\n            key = key_value[0].strip()\n            value = key_value[1].strip()\n            if key == 'fill' or key == 'stroke':\n                # Special case: convert colors into tensor in definitions so\n                # that different shapes can share the same color",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_hex",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_hex(s):\n    \"\"\"\n        Hex to tuple\n    \"\"\"\n    s = s.lstrip('#')\n    if len(s) == 3:\n        s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2]\n    rgb = tuple(int(s[i:i+2], 16) for i in (0, 2, 4))\n    # sRGB to RGB\n    # return torch.pow(torch.tensor([rgb[0] / 255.0, rgb[1] / 255.0, rgb[2] / 255.0]), 2.2)",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_int",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_int(s):\n    \"\"\"\n        trim alphabets\n    \"\"\"\n    return int(float(''.join(i for i in s if (not i.isalpha()))))\ndef parse_color(s, defs):\n    if s is None:\n        return None\n    if isinstance(s, torch.Tensor):\n        return s",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_color",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_color(s, defs):\n    if s is None:\n        return None\n    if isinstance(s, torch.Tensor):\n        return s\n    s = s.lstrip(' ')\n    color = torch.tensor([0.0, 0.0, 0.0, 1.0])\n    if s[0] == '#':\n        color[:3] = parse_hex(s)\n    elif s[:3] == 'url':",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_transform",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_transform(transform_str):\n    \"\"\"\n        Converts a valid SVG transformation string into a 3x3 matrix.\n        If the string is empty or null, this returns a 3x3 identity matrix\n    \"\"\"\n    if not transform_str:\n        return np.identity(3)\n    elif not isinstance(transform_str, str):\n        raise TypeError('Must provide a string to parse')\n    total_transform = np.identity(3)",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_linear_gradient",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_linear_gradient(node, transform, defs):\n    begin = torch.tensor([0.0, 0.0])\n    end = torch.tensor([0.0, 0.0])\n    offsets = []\n    stop_colors = []\n    # Inherit from parent\n    for key in node.attrib:\n        if remove_namespaces(key) == 'href':\n            value = node.attrib[key]\n            parent = defs[value.lstrip('#')]",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_radial_gradient",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_radial_gradient(node, transform, defs):\n    begin = torch.tensor([0.0, 0.0])\n    end = torch.tensor([0.0, 0.0])\n    center = torch.tensor([0.0, 0.0])\n    radius = torch.tensor([0.0, 0.0])\n    offsets = []\n    stop_colors = []\n    # Inherit from parent\n    for key in node.attrib:\n        if remove_namespaces(key) == 'href':",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_stylesheet",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_stylesheet(node, transform, defs):\n    # collect CSS classes\n    sheet = cssutils.parseString(node.text)\n    for rule in sheet:\n        if hasattr(rule, 'selectorText') and hasattr(rule, 'style'):\n            name = rule.selectorText\n            if len(name) >= 2 and name[0] == '.':\n                defs[name[1:]] = parse_style(rule.style.getCssText(), defs)\n    return defs\ndef parse_defs(node, transform, defs):",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_defs",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_defs(node, transform, defs):\n    for child in node:\n        tag = remove_namespaces(child.tag)\n        if tag == 'linearGradient':\n            if 'id' in child.attrib:\n                defs[child.attrib['id']] = parse_linear_gradient(child, transform, defs)\n        elif tag == 'radialGradient':\n            if 'id' in child.attrib:\n                defs[child.attrib['id']] = parse_radial_gradient(child, transform, defs)\n        elif tag == 'style':",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_common_attrib",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_common_attrib(node, transform, fill_color, defs):\n    attribs = {}\n    if 'class' in node.attrib:\n        attribs.update(defs[node.attrib['class']])\n    attribs.update(node.attrib)\n    name = ''\n    if 'id' in node.attrib:\n        name = node.attrib['id']\n    stroke_color = None\n    stroke_width = torch.tensor(0.5)",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "is_shape",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def is_shape(tag):\n    return tag == 'path' or tag == 'polygon' or tag == 'line' or tag == 'circle' or tag == 'rect'\ndef parse_shape(node, transform, fill_color, shapes, shape_groups, defs):\n    tag = remove_namespaces(node.tag)\n    new_transform, new_fill_color, stroke_color, stroke_width, use_even_odd_rule = \\\n        parse_common_attrib(node, transform, fill_color, defs)\n    if tag == 'path':\n        d = node.attrib['d']\n        name = ''\n        if 'id' in node.attrib:",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_shape",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_shape(node, transform, fill_color, shapes, shape_groups, defs):\n    tag = remove_namespaces(node.tag)\n    new_transform, new_fill_color, stroke_color, stroke_width, use_even_odd_rule = \\\n        parse_common_attrib(node, transform, fill_color, defs)\n    if tag == 'path':\n        d = node.attrib['d']\n        name = ''\n        if 'id' in node.attrib:\n            name = node.attrib['id']\n        force_closing = new_fill_color is not None",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_group",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_group(node, transform, fill_color, shapes, shape_groups, defs):\n    if 'transform' in node.attrib:\n        transform = transform @ parse_transform(node.attrib['transform'])\n    if 'fill' in node.attrib:\n        fill_color = parse_color(node.attrib['fill'], defs)\n    for child in node:\n        tag = remove_namespaces(child.tag)\n        if is_shape(tag):\n            shapes, shape_groups = parse_shape(\\\n                child, transform, fill_color, shapes, shape_groups, defs)",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "parse_scene",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def parse_scene(node):\n    canvas_width = -1\n    canvas_height = -1\n    defs = {}\n    shapes = []\n    shape_groups = []\n    fill_color = torch.tensor([0.0, 0.0, 0.0, 1.0])\n    transform = torch.eye(3)\n    if 'viewBox' in node.attrib:\n        view_box_array = node.attrib['viewBox'].split()",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "svg_to_scene",
        "kind": 2,
        "importPath": "pydiffvg.parse_svg",
        "description": "pydiffvg.parse_svg",
        "peekOfCode": "def svg_to_scene(filename):\n    \"\"\"\n        Load from a SVG file and convert to PyTorch tensors.\n    \"\"\"\n    tree = etree.parse(filename)\n    root = tree.getroot()\n    cwd = os.getcwd()\n    if (os.path.dirname(filename) != ''):\n        os.chdir(os.path.dirname(filename))\n    ret = parse_scene(root)",
        "detail": "pydiffvg.parse_svg",
        "documentation": {}
    },
    {
        "label": "PixelFilter",
        "kind": 6,
        "importPath": "pydiffvg.pixel_filter",
        "description": "pydiffvg.pixel_filter",
        "peekOfCode": "class PixelFilter:\n    def __init__(self,\n                 type,\n                 radius = torch.tensor(0.5)):\n        self.type = type\n        self.radius = radius",
        "detail": "pydiffvg.pixel_filter",
        "documentation": {}
    },
    {
        "label": "OutputType",
        "kind": 6,
        "importPath": "pydiffvg.render_pytorch",
        "description": "pydiffvg.render_pytorch",
        "peekOfCode": "class OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass RenderFunction(torch.autograd.Function):\n    \"\"\"\n        The PyTorch interface of diffvg.\n    \"\"\"\n    @staticmethod\n    def serialize_scene(canvas_width,\n                        canvas_height,",
        "detail": "pydiffvg.render_pytorch",
        "documentation": {}
    },
    {
        "label": "RenderFunction",
        "kind": 6,
        "importPath": "pydiffvg.render_pytorch",
        "description": "pydiffvg.render_pytorch",
        "peekOfCode": "class RenderFunction(torch.autograd.Function):\n    \"\"\"\n        The PyTorch interface of diffvg.\n    \"\"\"\n    @staticmethod\n    def serialize_scene(canvas_width,\n                        canvas_height,\n                        shapes,\n                        shape_groups,\n                        filter = pydiffvg.PixelFilter(type = diffvg.FilterType.box,",
        "detail": "pydiffvg.render_pytorch",
        "documentation": {}
    },
    {
        "label": "set_print_timing",
        "kind": 2,
        "importPath": "pydiffvg.render_pytorch",
        "description": "pydiffvg.render_pytorch",
        "peekOfCode": "def set_print_timing(val):\n    global print_timing\n    print_timing=val\nclass OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass RenderFunction(torch.autograd.Function):\n    \"\"\"\n        The PyTorch interface of diffvg.\n    \"\"\"",
        "detail": "pydiffvg.render_pytorch",
        "documentation": {}
    },
    {
        "label": "print_timing",
        "kind": 5,
        "importPath": "pydiffvg.render_pytorch",
        "description": "pydiffvg.render_pytorch",
        "peekOfCode": "print_timing = False\ndef set_print_timing(val):\n    global print_timing\n    print_timing=val\nclass OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass RenderFunction(torch.autograd.Function):\n    \"\"\"\n        The PyTorch interface of diffvg.",
        "detail": "pydiffvg.render_pytorch",
        "documentation": {}
    },
    {
        "label": "prettify",
        "kind": 2,
        "importPath": "pydiffvg.save_svg",
        "description": "pydiffvg.save_svg",
        "peekOfCode": "def prettify(elem):\n    \"\"\"Return a pretty-printed XML string for the Element.\n    \"\"\"\n    rough_string = etree.tostring(elem, 'utf-8')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent=\"  \")\ndef save_svg(filename, width, height, shapes, shape_groups, use_gamma = False):\n    root = etree.Element('svg')\n    root.set('version', '1.1')\n    root.set('xmlns', 'http://www.w3.org/2000/svg')",
        "detail": "pydiffvg.save_svg",
        "documentation": {}
    },
    {
        "label": "save_svg",
        "kind": 2,
        "importPath": "pydiffvg.save_svg",
        "description": "pydiffvg.save_svg",
        "peekOfCode": "def save_svg(filename, width, height, shapes, shape_groups, use_gamma = False):\n    root = etree.Element('svg')\n    root.set('version', '1.1')\n    root.set('xmlns', 'http://www.w3.org/2000/svg')\n    root.set('width', str(width))\n    root.set('height', str(height))\n    defs = etree.SubElement(root, 'defs')\n    g = etree.SubElement(root, 'g')\n    if use_gamma:\n        f = etree.SubElement(defs, 'filter')",
        "detail": "pydiffvg.save_svg",
        "documentation": {}
    },
    {
        "label": "Circle",
        "kind": 6,
        "importPath": "pydiffvg.shape",
        "description": "pydiffvg.shape",
        "peekOfCode": "class Circle:\n    def __init__(self, radius, center, stroke_width = torch.tensor(1.0), id = ''):\n        self.radius = radius\n        self.center = center\n        self.stroke_width = stroke_width\n        self.id = id\nclass Ellipse:\n    def __init__(self, radius, center, stroke_width = torch.tensor(1.0), id = ''):\n        self.radius = radius\n        self.center = center",
        "detail": "pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "Ellipse",
        "kind": 6,
        "importPath": "pydiffvg.shape",
        "description": "pydiffvg.shape",
        "peekOfCode": "class Ellipse:\n    def __init__(self, radius, center, stroke_width = torch.tensor(1.0), id = ''):\n        self.radius = radius\n        self.center = center\n        self.stroke_width = stroke_width\n        self.id = id\nclass Path:\n    def __init__(self,\n                 num_control_points,\n                 points,",
        "detail": "pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "Path",
        "kind": 6,
        "importPath": "pydiffvg.shape",
        "description": "pydiffvg.shape",
        "peekOfCode": "class Path:\n    def __init__(self,\n                 num_control_points,\n                 points,\n                 is_closed,\n                 stroke_width = torch.tensor(1.0),\n                 id = '',\n                 use_distance_approx = False):\n        self.num_control_points = num_control_points\n        self.points = points",
        "detail": "pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "kind": 6,
        "importPath": "pydiffvg.shape",
        "description": "pydiffvg.shape",
        "peekOfCode": "class Polygon:\n    def __init__(self, points, is_closed, stroke_width = torch.tensor(1.0), id = ''):\n        self.points = points\n        self.is_closed = is_closed\n        self.stroke_width = stroke_width\n        self.id = id\nclass Rect:\n    def __init__(self, p_min, p_max, stroke_width = torch.tensor(1.0), id = ''):\n        self.p_min = p_min\n        self.p_max = p_max",
        "detail": "pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "Rect",
        "kind": 6,
        "importPath": "pydiffvg.shape",
        "description": "pydiffvg.shape",
        "peekOfCode": "class Rect:\n    def __init__(self, p_min, p_max, stroke_width = torch.tensor(1.0), id = ''):\n        self.p_min = p_min\n        self.p_max = p_max\n        self.stroke_width = stroke_width\n        self.id = id\nclass ShapeGroup:\n    def __init__(self,\n                 shape_ids,\n                 fill_color,",
        "detail": "pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "ShapeGroup",
        "kind": 6,
        "importPath": "pydiffvg.shape",
        "description": "pydiffvg.shape",
        "peekOfCode": "class ShapeGroup:\n    def __init__(self,\n                 shape_ids,\n                 fill_color,\n                 use_even_odd_rule = True,\n                 stroke_color = None,\n                 shape_to_canvas = torch.eye(3),\n                 id = ''):\n        self.shape_ids = shape_ids\n        self.fill_color = fill_color",
        "detail": "pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "from_svg_path",
        "kind": 2,
        "importPath": "pydiffvg.shape",
        "description": "pydiffvg.shape",
        "peekOfCode": "def from_svg_path(path_str, shape_to_canvas = torch.eye(3), force_close = False):\n    path = svgpathtools.parse_path(path_str)\n    if len(path) == 0:\n        return []\n    ret_paths = []\n    subpaths = path.continuous_subpaths()\n    for subpath in subpaths:\n        if subpath.isclosed():\n            if len(subpath) > 1 and isinstance(subpath[-1], svgpathtools.Line) and subpath[-1].length() < 1e-5:\n                subpath.remove(subpath[-1])",
        "detail": "pydiffvg.shape",
        "documentation": {}
    },
    {
        "label": "LinearGradient",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.color",
        "description": "pydiffvg_tensorflow.color",
        "peekOfCode": "class LinearGradient:\n    def __init__(self,\n                 begin = tf.constant([0.0, 0.0]),\n                 end = tf.constant([0.0, 0.0]),\n                 offsets = tf.constant([0.0]),\n                 stop_colors = tf.constant([0.0, 0.0, 0.0, 0.0])):\n        self.begin = begin\n        self.end = end\n        self.offsets = offsets\n        self.stop_colors = stop_colors",
        "detail": "pydiffvg_tensorflow.color",
        "documentation": {}
    },
    {
        "label": "RadialGradient",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.color",
        "description": "pydiffvg_tensorflow.color",
        "peekOfCode": "class RadialGradient:\n    def __init__(self,\n                 center = tf.constant([0.0, 0.0]),\n                 radius = tf.constant([0.0, 0.0]),\n                 offsets = tf.constant([0.0]),\n                 stop_colors = tf.constant([0.0, 0.0, 0.0, 0.0])):\n        self.center = center\n        self.radius = radius\n        self.offsets = offsets\n        self.stop_colors = stop_colors",
        "detail": "pydiffvg_tensorflow.color",
        "documentation": {}
    },
    {
        "label": "get_device_name",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "def get_device_name():\n    \"\"\"\n        Get the current tensorflow device name we are using.\n    \"\"\"\n    global use_gpu\n    global cpu_device_id\n    global gpu_device_id\n    return '/device:gpu:' + str(gpu_device_id) if use_gpu else '/device:cpu:' + str(cpu_device_id)\ndef set_use_gpu(v: bool):\n    \"\"\"",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "set_use_gpu",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "def set_use_gpu(v: bool):\n    \"\"\"\n        Set whether to use CUDA or not.\n    \"\"\"\n    global use_gpu\n    use_gpu = v\ndef get_use_gpu():\n    \"\"\"\n        Get whether we are using CUDA or not.\n    \"\"\"",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "get_use_gpu",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "def get_use_gpu():\n    \"\"\"\n        Get whether we are using CUDA or not.\n    \"\"\"\n    global use_gpu\n    return use_gpu\ndef set_cpu_device_id(did: int):\n    \"\"\"\n        Set the cpu device id we are using.\n    \"\"\"",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "set_cpu_device_id",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "def set_cpu_device_id(did: int):\n    \"\"\"\n        Set the cpu device id we are using.\n    \"\"\"\n    global cpu_device_id\n    cpu_device_id = did\ndef get_cpu_device_id():\n    \"\"\"\n        Get the cpu device id we are using.\n    \"\"\"",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "get_cpu_device_id",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "def get_cpu_device_id():\n    \"\"\"\n        Get the cpu device id we are using.\n    \"\"\"\n    global cpu_device_id\n    return cpu_device_id\ndef set_gpu_device_id(did: int):\n    \"\"\"\n        Set the gpu device id we are using.\n    \"\"\"",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "set_gpu_device_id",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "def set_gpu_device_id(did: int):\n    \"\"\"\n        Set the gpu device id we are using.\n    \"\"\"\n    global gpu_device_id\n    gpu_device_id = did\ndef get_gpu_device_id():\n    \"\"\"\n        Get the gpu device id we are using.\n    \"\"\"",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "get_gpu_device_id",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "def get_gpu_device_id():\n    \"\"\"\n        Get the gpu device id we are using.\n    \"\"\"\n    global gpu_device_id\n    return gpu_device_id",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "use_gpu",
        "kind": 5,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "use_gpu = tf.test.is_gpu_available(\n    cuda_only=True,\n    min_cuda_compute_capability=None\n)\ncpu_device_id = 0\ngpu_device_id = 0\ndef get_device_name():\n    \"\"\"\n        Get the current tensorflow device name we are using.\n    \"\"\"",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "cpu_device_id",
        "kind": 5,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "cpu_device_id = 0\ngpu_device_id = 0\ndef get_device_name():\n    \"\"\"\n        Get the current tensorflow device name we are using.\n    \"\"\"\n    global use_gpu\n    global cpu_device_id\n    global gpu_device_id\n    return '/device:gpu:' + str(gpu_device_id) if use_gpu else '/device:cpu:' + str(cpu_device_id)",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "gpu_device_id",
        "kind": 5,
        "importPath": "pydiffvg_tensorflow.device",
        "description": "pydiffvg_tensorflow.device",
        "peekOfCode": "gpu_device_id = 0\ndef get_device_name():\n    \"\"\"\n        Get the current tensorflow device name we are using.\n    \"\"\"\n    global use_gpu\n    global cpu_device_id\n    global gpu_device_id\n    return '/device:gpu:' + str(gpu_device_id) if use_gpu else '/device:cpu:' + str(cpu_device_id)\ndef set_use_gpu(v: bool):",
        "detail": "pydiffvg_tensorflow.device",
        "documentation": {}
    },
    {
        "label": "imwrite",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.image",
        "description": "pydiffvg_tensorflow.image",
        "peekOfCode": "def imwrite(img, filename, gamma = 2.2, normalize = False):\n    directory = os.path.dirname(filename)\n    if directory != '' and not os.path.exists(directory):\n        os.makedirs(directory)\n    if not isinstance(img, np.ndarray):\n        img = img.numpy()\n    if normalize:\n        img_rng = np.max(img) - np.min(img)\n        if img_rng > 0:\n            img = (img - np.min(img)) / img_rng",
        "detail": "pydiffvg_tensorflow.image",
        "documentation": {}
    },
    {
        "label": "PixelFilter",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.pixel_filter",
        "description": "pydiffvg_tensorflow.pixel_filter",
        "peekOfCode": "class PixelFilter:\n    def __init__(self,\n                 type,\n                 radius = tf.constant(0.5)):\n        self.type = type\n        self.radius = radius",
        "detail": "pydiffvg_tensorflow.pixel_filter",
        "documentation": {}
    },
    {
        "label": "OutputType",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "class OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass ShapeType:\n    __shapetypes = [\n        diffvg.ShapeType.circle,\n        diffvg.ShapeType.ellipse,\n        diffvg.ShapeType.path,\n        diffvg.ShapeType.rect\n    ]",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "ShapeType",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "class ShapeType:\n    __shapetypes = [\n        diffvg.ShapeType.circle,\n        diffvg.ShapeType.ellipse,\n        diffvg.ShapeType.path,\n        diffvg.ShapeType.rect\n    ]\n    @staticmethod\n    def asTensor(type):\n        for i in range(len(ShapeType.__shapetypes)):",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "ColorType",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "class ColorType:\n    __colortypes = [\n        diffvg.ColorType.constant,\n        diffvg.ColorType.linear_gradient,\n        diffvg.ColorType.radial_gradient\n    ]\n    @staticmethod\n    def asTensor(type):\n        for i in range(len(ColorType.__colortypes)):\n            if ColorType.__colortypes[i] == type:",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "FilterType",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "class FilterType:\n    __filtertypes = [\n        diffvg.FilterType.box,\n        diffvg.FilterType.tent,\n        diffvg.FilterType.hann\n    ]\n    @staticmethod\n    def asTensor(type):\n        for i in range(len(FilterType.__filtertypes)):\n            if FilterType.__filtertypes[i] == type:",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "Context",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "class Context: pass\ndef forward(width,\n            height,\n            num_samples_x,\n            num_samples_y,\n            seed,\n            *args):\n    \"\"\"\n        Forward rendering pass: given a serialized scene and output an image.\n    \"\"\"",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "is_empty_tensor",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "def is_empty_tensor(tensor):\n    return  tf.equal(tf.size(tensor), 0)\ndef set_print_timing(val):\n    global print_timing\n    print_timing=val\nclass OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass ShapeType:\n    __shapetypes = [",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "set_print_timing",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "def set_print_timing(val):\n    global print_timing\n    print_timing=val\nclass OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass ShapeType:\n    __shapetypes = [\n        diffvg.ShapeType.circle,\n        diffvg.ShapeType.ellipse,",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "serialize_scene",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "def serialize_scene(canvas_width,\n                    canvas_height,\n                    shapes,\n                    shape_groups,\n                    filter = pydiffvg.PixelFilter(type = diffvg.FilterType.box,\n                                                  radius = tf.constant(0.5)),\n                    output_type = OutputType.color,\n                    use_prefiltering = False):\n    \"\"\"\n        Given a list of shapes, convert them to a linear list of argument,",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "forward",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "def forward(width,\n            height,\n            num_samples_x,\n            num_samples_y,\n            seed,\n            *args):\n    \"\"\"\n        Forward rendering pass: given a serialized scene and output an image.\n    \"\"\"\n    # Unpack arguments",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "def render(*x):\n    \"\"\"\n        The main TensorFlow interface of C++ diffvg.\n    \"\"\"\n    assert(tf.executing_eagerly())\n    if pydiffvg.get_use_gpu() and os.environ.get('TF_FORCE_GPU_ALLOW_GROWTH') != 'true':\n        print('******************** WARNING ********************')\n        print('Tensorflow by default allocates all GPU memory,')\n        print('causing huge amount of page faults when rendering.')\n        print('Please set the environment variable TF_FORCE_GPU_ALLOW_GROWTH to true,')",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "print_timing",
        "kind": 5,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "print_timing = False\n__EMPTY_TENSOR = tf.constant([])\ndef is_empty_tensor(tensor):\n    return  tf.equal(tf.size(tensor), 0)\ndef set_print_timing(val):\n    global print_timing\n    print_timing=val\nclass OutputType(IntEnum):\n    color = 1\n    sdf = 2",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "__EMPTY_TENSOR",
        "kind": 5,
        "importPath": "pydiffvg_tensorflow.render_tensorflow",
        "description": "pydiffvg_tensorflow.render_tensorflow",
        "peekOfCode": "__EMPTY_TENSOR = tf.constant([])\ndef is_empty_tensor(tensor):\n    return  tf.equal(tf.size(tensor), 0)\ndef set_print_timing(val):\n    global print_timing\n    print_timing=val\nclass OutputType(IntEnum):\n    color = 1\n    sdf = 2\nclass ShapeType:",
        "detail": "pydiffvg_tensorflow.render_tensorflow",
        "documentation": {}
    },
    {
        "label": "Circle",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.shape",
        "description": "pydiffvg_tensorflow.shape",
        "peekOfCode": "class Circle:\n    def __init__(self, radius, center, stroke_width = tf.constant(1.0), id = ''):\n        self.radius = radius\n        self.center = center\n        self.stroke_width = stroke_width\n        self.id = id\nclass Ellipse:\n    def __init__(self, radius, center, stroke_width = tf.constant(1.0), id = ''):\n        self.radius = radius\n        self.center = center",
        "detail": "pydiffvg_tensorflow.shape",
        "documentation": {}
    },
    {
        "label": "Ellipse",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.shape",
        "description": "pydiffvg_tensorflow.shape",
        "peekOfCode": "class Ellipse:\n    def __init__(self, radius, center, stroke_width = tf.constant(1.0), id = ''):\n        self.radius = radius\n        self.center = center\n        self.stroke_width = stroke_width\n        self.id = id\nclass Path:\n    def __init__(self, num_control_points, points, is_closed, stroke_width = tf.constant(1.0), id = '', use_distance_approx = False):\n        self.num_control_points = num_control_points\n        self.points = points",
        "detail": "pydiffvg_tensorflow.shape",
        "documentation": {}
    },
    {
        "label": "Path",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.shape",
        "description": "pydiffvg_tensorflow.shape",
        "peekOfCode": "class Path:\n    def __init__(self, num_control_points, points, is_closed, stroke_width = tf.constant(1.0), id = '', use_distance_approx = False):\n        self.num_control_points = num_control_points\n        self.points = points\n        self.is_closed = is_closed\n        self.stroke_width = stroke_width\n        self.id = id\n        self.use_distance_approx = use_distance_approx\nclass Polygon:\n    def __init__(self, points, is_closed, stroke_width = tf.constant(1.0), id = ''):",
        "detail": "pydiffvg_tensorflow.shape",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.shape",
        "description": "pydiffvg_tensorflow.shape",
        "peekOfCode": "class Polygon:\n    def __init__(self, points, is_closed, stroke_width = tf.constant(1.0), id = ''):\n        self.points = points\n        self.is_closed = is_closed\n        self.stroke_width = stroke_width\n        self.id = id\nclass Rect:\n    def __init__(self, p_min, p_max, stroke_width = tf.constant(1.0), id = ''):\n        self.p_min = p_min\n        self.p_max = p_max",
        "detail": "pydiffvg_tensorflow.shape",
        "documentation": {}
    },
    {
        "label": "Rect",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.shape",
        "description": "pydiffvg_tensorflow.shape",
        "peekOfCode": "class Rect:\n    def __init__(self, p_min, p_max, stroke_width = tf.constant(1.0), id = ''):\n        self.p_min = p_min\n        self.p_max = p_max\n        self.stroke_width = stroke_width\n        self.id = id\nclass ShapeGroup:\n    def __init__(self,\n                 shape_ids,\n                 fill_color,",
        "detail": "pydiffvg_tensorflow.shape",
        "documentation": {}
    },
    {
        "label": "ShapeGroup",
        "kind": 6,
        "importPath": "pydiffvg_tensorflow.shape",
        "description": "pydiffvg_tensorflow.shape",
        "peekOfCode": "class ShapeGroup:\n    def __init__(self,\n                 shape_ids,\n                 fill_color,\n                 use_even_odd_rule = True,\n                 stroke_color = None,\n                 shape_to_canvas = tf.eye(3),\n                 id = ''):\n        self.shape_ids = shape_ids\n        self.fill_color = fill_color",
        "detail": "pydiffvg_tensorflow.shape",
        "documentation": {}
    },
    {
        "label": "measured_variable",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "class measured_variable(object):\n  \"\"\"A meta-variable representing measured data. It is composed of three raw\n  variables plus units meta-data.\n  Attributes:\n    quantity (`str`) :\n      Name of the quantity variable of this object.\n    uncertainty (`str`) :\n      Name of the uncertainty variable of this object.\n    sample_size (`str`) :\n      Name of the sample size variable of this object.",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "measured_value",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "class measured_value(object):\n  \"\"\"An object that represents a value determined by multiple measurements.\n  Attributes:\n    quantity (scalar) :\n      The quantity of the value, e.g. the arithmetic mean.\n    uncertainty (scalar) :\n      The measurement uncertainty, e.g. the sample standard deviation.\n    sample_size (`int`) :\n      The number of observations contributing to the value.\n    units (units class or `None`) :",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "io_manager",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "class io_manager(object):\n  \"\"\"Manages I/O operations and represents the input data as an `Iterable`\n  sequence of `dict`s.\n  It is `Iterable` and an `Iterator`. It can be used with `with`.\n  Attributes:\n    preserve_whitespace (`bool`) :\n      If `False`, leading and trailing whitespace is stripped from each CSV cell.\n    writer (`csv_dict_writer`) :\n      CSV writer object that the output is written to.\n    output_file (`file` or `stdout`) :",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "dependent_variable_parser",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "class dependent_variable_parser(object):\n  \"\"\"Parses a `--dependent-variable=AVG,STDEV,TRIALS` command line argument.\"\"\"\n  #############################################################################\n  # Grammar\n  # Parse a variable_name.\n  variable_name_rule = r'[^,]+'\n  # Parse a variable classification.        \n  dependent_variable_rule = r'(' + variable_name_rule + r')'   \\\n                          + r','                               \\\n                          + r'(' + variable_name_rule + r')'   \\",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "record_aggregator",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "class record_aggregator(object):\n  \"\"\"Consumes and combines records and represents the result as an `Iterable`\n  sequence of `dict`s.\n  It is `Iterable` and an `Iterator`.\n  Attributes:\n    dependent_variables (`list` of `measured_variable`s) :\n      A list of dependent variables provided on the command line.\n    dataset (`dict`) :\n      A mapping of distinguishing (e.g. control + independent) values (`tuple`s\n      of variable-quantity pairs) to `list`s of dependent values (`dict`s from ",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "unpack_tuple",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def unpack_tuple(f):\n  \"\"\"Return a unary function that calls `f` with its argument unpacked.\"\"\"\n  return lambda args: f(*iter(args))\ndef strip_dict(d):\n  \"\"\"Strip leading and trailing whitespace from all keys and values in `d`.\"\"\"\n  d.update({key: value.strip() for (key, value) in d.items()})\ndef merge_dicts(d0, d1):\n  \"\"\"Create a new `dict` that is the union of `dict`s `d0` and `d1`.\"\"\"\n  d = d0.copy()\n  d.update(d1)",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "strip_dict",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def strip_dict(d):\n  \"\"\"Strip leading and trailing whitespace from all keys and values in `d`.\"\"\"\n  d.update({key: value.strip() for (key, value) in d.items()})\ndef merge_dicts(d0, d1):\n  \"\"\"Create a new `dict` that is the union of `dict`s `d0` and `d1`.\"\"\"\n  d = d0.copy()\n  d.update(d1)\n  return d\ndef strip_list(l):\n  \"\"\"Strip leading and trailing whitespace from all values in `l`.\"\"\"",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "merge_dicts",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def merge_dicts(d0, d1):\n  \"\"\"Create a new `dict` that is the union of `dict`s `d0` and `d1`.\"\"\"\n  d = d0.copy()\n  d.update(d1)\n  return d\ndef strip_list(l):\n  \"\"\"Strip leading and trailing whitespace from all values in `l`.\"\"\"\n  for i, value in enumerate(l): l[i] = value.strip()\n###############################################################################\ndef int_or_float(x):",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "strip_list",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def strip_list(l):\n  \"\"\"Strip leading and trailing whitespace from all values in `l`.\"\"\"\n  for i, value in enumerate(l): l[i] = value.strip()\n###############################################################################\ndef int_or_float(x):\n  \"\"\"Convert `x` to either `int` or `float`, preferring `int`.\n  Raises:\n    ValueError : If `x` is not convertible to either `int` or `float`\n  \"\"\"\n  try:",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "int_or_float",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def int_or_float(x):\n  \"\"\"Convert `x` to either `int` or `float`, preferring `int`.\n  Raises:\n    ValueError : If `x` is not convertible to either `int` or `float`\n  \"\"\"\n  try:\n    return int(x)\n  except ValueError:\n    return float(x)\ndef try_int_or_float(x):",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "try_int_or_float",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def try_int_or_float(x):\n  \"\"\"Try to convert `x` to either `int` or `float`, preferring `int`. `x` is\n  returned unmodified if conversion fails.\n  \"\"\"\n  try:\n    return int_or_float(x)\n  except ValueError:\n    return x\n###############################################################################\ndef find_significant_digit(x):",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "find_significant_digit",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def find_significant_digit(x):\n  \"\"\"Return the significant digit of the number x. The result is the number of\n  digits after the decimal place to round to (negative numbers indicate rounding\n  before the decimal place).\"\"\"\n  if x == 0: return 0\n  return -int(floor(log10(abs(x))))\ndef round_with_int_conversion(x, ndigits = None):\n  \"\"\"Rounds `x` to `ndigits` after the the decimal place. If `ndigits` is less\n  than 1, convert the result to `int`. If `ndigits` is `None`, the significant\n  digit of `x` is used.\"\"\"",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "round_with_int_conversion",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def round_with_int_conversion(x, ndigits = None):\n  \"\"\"Rounds `x` to `ndigits` after the the decimal place. If `ndigits` is less\n  than 1, convert the result to `int`. If `ndigits` is `None`, the significant\n  digit of `x` is used.\"\"\"\n  if ndigits is None: ndigits = find_significant_digit(x)\n  x_rounded = round(x, ndigits)\n  return int(x_rounded) if ndigits < 1 else x_rounded\n###############################################################################\nclass measured_variable(object):\n  \"\"\"A meta-variable representing measured data. It is composed of three raw",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "arithmetic_mean",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def arithmetic_mean(X):\n  \"\"\"Computes the arithmetic mean of the sequence `X`.\n  Let:\n    * `n = len(X)`.\n    * `u` denote the arithmetic mean of `X`.\n  .. math::\n    u = \\frac{\\sum_{i = 0}^{n - 1} X_i}{n}\n  \"\"\"\n  return sum(X) / len(X)\ndef sample_variance(X, u = None):",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "sample_variance",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def sample_variance(X, u = None):\n  \"\"\"Computes the sample variance of the sequence `X`.\n  Let:\n    * `n = len(X)`.\n    * `u` denote the arithmetic mean of `X`.\n    * `s` denote the sample standard deviation of `X`.\n  .. math::\n    v = \\frac{\\sum_{i = 0}^{n - 1} (X_i - u)^2}{n - 1}\n  Args:\n    X (`Iterable`) : The sequence of values.",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "sample_standard_deviation",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def sample_standard_deviation(X, u = None, v = None):\n  \"\"\"Computes the sample standard deviation of the sequence `X`.\n  Let:\n    * `n = len(X)`.\n    * `u` denote the arithmetic mean of `X`.\n    * `v` denote the sample variance of `X`.\n    * `s` denote the sample standard deviation of `X`.\n  .. math::\n    s &= \\sqrt{v}\n      &= \\sqrt{\\frac{\\sum_{i = 0}^{n - 1} (X_i - u)^2}{n - 1}}",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "combine_sample_size",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def combine_sample_size(As):\n  \"\"\"Computes the combined sample variance of a group of `measured_value`s.\n  Let:\n    * `g = len(As)`.\n    * `n_i = As[i].samples`.\n    * `n` denote the combined sample size of `As`.\n  .. math::\n    n = \\sum{i = 0}^{g - 1} n_i\n  \"\"\"\n  return sum(imap(unpack_tuple(lambda u_i, s_i, n_i, t_i: n_i), As))",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "combine_arithmetic_mean",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def combine_arithmetic_mean(As, n = None):\n  \"\"\"Computes the combined arithmetic mean of a group of `measured_value`s.\n  Let:\n    * `g = len(As)`.\n    * `u_i = As[i].quantity`.\n    * `n_i = As[i].samples`.\n    * `n` denote the combined sample size of `As`.\n    * `u` denote the arithmetic mean of the quantities of `As`.\n  .. math::\n    u = \\frac{\\sum{i = 0}^{g - 1} n_i u_i}{n}",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "combine_sample_variance",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def combine_sample_variance(As, n = None, u = None):\n  \"\"\"Computes the combined sample variance of a group of `measured_value`s.\n  Let:\n    * `g = len(As)`.\n    * `u_i = As[i].quantity`.\n    * `s_i = As[i].uncertainty`.\n    * `n_i = As[i].samples`.\n    * `n` denote the combined sample size of `As`.\n    * `u` denote the arithmetic mean of the quantities of `As`.\n    * `v` denote the sample variance of `X`.",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "combine_sample_standard_deviation",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def combine_sample_standard_deviation(As, n = None, u = None, v = None):\n  \"\"\"Computes the combined sample standard deviation of a group of\n  `measured_value`s.\n  Let:\n    * `g = len(As)`.\n    * `u_i = As[i].quantity`.\n    * `s_i = As[i].uncertainty`.\n    * `n_i = As[i].samples`.\n    * `n` denote the combined sample size of `As`.\n    * `u` denote the arithmetic mean of the quantities of `As`.",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "process_program_arguments",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def process_program_arguments():\n  ap = argument_parser(\n    description = (\n      \"Aggregates the results of multiple runs of benchmark results stored in \"\n      \"CSV format.\"\n    )\n  )\n  ap.add_argument(\n    \"-d\", \"--dependent-variable\",\n    help = (\"Treat the specified three variables as a dependent variable. The \"",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "filter_comments",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "def filter_comments(f, s = \"#\"):\n  \"\"\"Return an iterator to the file `f` which filters out all lines beginning\n  with `s`.\"\"\"\n  return filter(lambda line: not line.startswith(s), f)\n###############################################################################\nclass io_manager(object):\n  \"\"\"Manages I/O operations and represents the input data as an `Iterable`\n  sequence of `dict`s.\n  It is `Iterable` and an `Iterator`. It can be used with `with`.\n  Attributes:",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "thrust.internal.benchmark.combine_benchmark_results",
        "description": "thrust.internal.benchmark.combine_benchmark_results",
        "peekOfCode": "args = process_program_arguments()\nif args.dependent_variables is None:\n  args.dependent_variables = [\n    \"STL Average Walltime,STL Walltime Uncertainty,STL Trials\",\n    \"STL Average Throughput,STL Throughput Uncertainty,STL Trials\",\n    \"Thrust Average Walltime,Thrust Walltime Uncertainty,Thrust Trials\",\n    \"Thrust Average Throughput,Thrust Throughput Uncertainty,Thrust Trials\"\n  ]\n# Read input files and open the output file.\nwith io_manager(args.input_files,",
        "detail": "thrust.internal.benchmark.combine_benchmark_results",
        "documentation": {}
    },
    {
        "label": "measured_variable",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "class measured_variable(object):\n  \"\"\"A meta-variable representing measured data. It is composed of three raw\n  variables plus units meta-data.\n  Attributes:\n    quantity (`str`) :\n      Name of the quantity variable of this object.\n    uncertainty (`str`) :\n      Name of the uncertainty variable of this object.\n    sample_size (`str`) :\n      Name of the sample size variable of this object.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "measured_value",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "class measured_value(object):\n  \"\"\"An object that represents a value determined by multiple measurements.\n  Attributes:\n    quantity (scalar) :\n      The quantity of the value, e.g. the arithmetic mean.\n    uncertainty (scalar) :\n      The measurement uncertainty, e.g. the sample standard deviation.\n    sample_size (`int`) :\n      The number of observations contributing to the value.\n    units (units class or `None`) :",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "io_manager",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "class io_manager(object):\n  \"\"\"Manages I/O operations and represents the input data as an `Iterable`\n  sequence of `dict`s.\n  It is `Iterable` and an `Iterator`. It can be used with `with`.\n  Attributes:\n    preserve_whitespace (`bool`) :\n      If `False`, leading and trailing whitespace is stripped from each CSV cell.\n    writer (`csv_dict_writer`) :\n      CSV writer object that the output is written to.\n    output_file (`file` or `stdout`) :",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "dependent_variable_parser",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "class dependent_variable_parser(object):\n  \"\"\"Parses a `--dependent-variable=AVG,STDEV,TRIALS` command line argument.\"\"\"\n  #############################################################################\n  # Grammar\n  # Parse a variable_name.\n  variable_name_rule = r'[^,]+'\n  # Parse a variable classification.        \n  dependent_variable_rule = r'(' + variable_name_rule + r')'   \\\n                          + r','                               \\\n                          + r'(' + variable_name_rule + r')'   \\",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "record_aggregator",
        "kind": 6,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "class record_aggregator(object):\n  \"\"\"Consumes and combines records and represents the result as an `Iterable`\n  sequence of `dict`s.\n  It is `Iterable` and an `Iterator`.\n  Attributes:\n    dependent_variables (`list` of `measured_variable`s) :\n      A list of dependent variables provided on the command line.\n    control_variables (`list` of `str`s) :\n      A list of control variables provided on the command line.\n    dataset (`dict`) :",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "unpack_tuple",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def unpack_tuple(f):\n  \"\"\"Return a unary function that calls `f` with its argument unpacked.\"\"\"\n  return lambda args: f(*iter(args))\ndef strip_dict(d):\n  \"\"\"Strip leading and trailing whitespace from all keys and values in `d`.\n  Returns:\n    The modified dict `d`.\n  \"\"\"\n  d.update({key: value.strip() for (key, value) in d.items()})\n  return d",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "strip_dict",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def strip_dict(d):\n  \"\"\"Strip leading and trailing whitespace from all keys and values in `d`.\n  Returns:\n    The modified dict `d`.\n  \"\"\"\n  d.update({key: value.strip() for (key, value) in d.items()})\n  return d\ndef merge_dicts(d0, d1):\n  \"\"\"Create a new `dict` that is the union of `dict`s `d0` and `d1`.\"\"\"\n  d = d0.copy()",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "merge_dicts",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def merge_dicts(d0, d1):\n  \"\"\"Create a new `dict` that is the union of `dict`s `d0` and `d1`.\"\"\"\n  d = d0.copy()\n  d.update(d1)\n  return d\ndef change_key_in_dict(d, old_key, new_key):\n  \"\"\"Change the key of the entry in `d` with key `old_key` to `new_key`. If\n  there is an existing entry \n  Returns:\n    The modified dict `d`.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "change_key_in_dict",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def change_key_in_dict(d, old_key, new_key):\n  \"\"\"Change the key of the entry in `d` with key `old_key` to `new_key`. If\n  there is an existing entry \n  Returns:\n    The modified dict `d`.\n  Raises:\n    KeyError : If `old_key` is not in `d`.\n  \"\"\"\n  d[new_key] = d.pop(old_key)\n  return d",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "key_from_dict",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def key_from_dict(d):\n  \"\"\"Create a hashable key from a `dict` by converting the `dict` to a tuple.\"\"\"\n  return tuple(sorted(d.items()))\ndef strip_list(l):\n  \"\"\"Strip leading and trailing whitespace from all values in `l`.\"\"\"\n  for i, value in enumerate(l): l[i] = value.strip()\n  return l\ndef remove_from_list(l, item):\n  \"\"\"Remove the first occurence of `item` from list `l` and return a tuple of\n  the index that was removed and the element that was removed.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "strip_list",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def strip_list(l):\n  \"\"\"Strip leading and trailing whitespace from all values in `l`.\"\"\"\n  for i, value in enumerate(l): l[i] = value.strip()\n  return l\ndef remove_from_list(l, item):\n  \"\"\"Remove the first occurence of `item` from list `l` and return a tuple of\n  the index that was removed and the element that was removed.\n  Raises:\n    ValueError : If `item` is not in `l`.\n  \"\"\"",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "remove_from_list",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def remove_from_list(l, item):\n  \"\"\"Remove the first occurence of `item` from list `l` and return a tuple of\n  the index that was removed and the element that was removed.\n  Raises:\n    ValueError : If `item` is not in `l`.\n  \"\"\"\n  idx = l.index(item)\n  item = l.pop(idx)\n  return (idx, item)\n###############################################################################",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "int_or_float",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def int_or_float(x):\n  \"\"\"Convert `x` to either `int` or `float`, preferring `int`.\n  Raises:\n    ValueError : If `x` is not convertible to either `int` or `float`\n  \"\"\"\n  try:\n    return int(x)\n  except ValueError:\n    return float(x)\ndef try_int_or_float(x):",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "try_int_or_float",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def try_int_or_float(x):\n  \"\"\"Try to convert `x` to either `int` or `float`, preferring `int`. `x` is\n  returned unmodified if conversion fails.\n  \"\"\"\n  try:\n    return int_or_float(x)\n  except ValueError:\n    return x\n###############################################################################\ndef ranges_overlap(x1, x2, y1, y2):",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "ranges_overlap",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def ranges_overlap(x1, x2, y1, y2):\n  \"\"\"Returns true if the ranges `[x1, x2]` and `[y1, y2]` overlap,\n  where `x1 <= x2` and `y1 <= y2`.\n  Raises:\n    AssertionError : If `x1 > x2` or `y1 > y2`.\n  \"\"\"\n  assert x1 <= x2\n  assert y1 <= y2\n  return x1 <= y2 and y1 <= x2\ndef ranges_overlap_uncertainty(x, x_unc, y, y_unc):",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "ranges_overlap_uncertainty",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def ranges_overlap_uncertainty(x, x_unc, y, y_unc):\n  \"\"\"Returns true if the ranges `[x - x_unc, x + x_unc]` and\n  `[y - y_unc, y + y_unc]` overlap, where `x_unc >= 0` and `y_unc >= 0`.\n  Raises:\n    AssertionError : If `x_unc < 0` or `y_unc < 0`.\n  \"\"\"\n  assert x_unc >= 0\n  assert y_unc >= 0\n  return ranges_overlap(x - x_unc, x + x_unc, y - y_unc, y + y_unc)\n###############################################################################",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "uncertainty_multiplicative",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def uncertainty_multiplicative(f, A, A_abs_unc, B, B_abs_unc):\n  \"\"\"Compute the propagated uncertainty from the multiplication of two\n  uncertain values, `A +/- A_abs_unc` and `B +/- B_abs_unc`. Given `f = AB` or\n  `f = A/B`, where `A != 0` and `B != 0`, the uncertainty in `f` is\n  approximately:\n  .. math::\n    \\sigma_f = |f| \\sqrt{\\frac{\\sigma_A}{A} ^ 2 + \\frac{\\sigma_B}{B} ^ 2}\n  Raises:\n    ZeroDivisionError : If `A == 0` or `B == 0`.\n  \"\"\"",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "uncertainty_additive",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def uncertainty_additive(c, A_abs_unc, d, B_abs_unc):\n  \"\"\"Compute the propagated uncertainty from addition of two uncertain values,\n  `A +/- A_abs_unc` and `B +/- B_abs_unc`. Given `f = cA + dB`, where `c` and\n  `d` are certain constants, the uncertainty in `f` is approximately:\n  .. math::\n    f_{\\sigma} = \\sqrt{c ^ 2 * A_{\\sigma} ^ 2 + d ^ 2 * B_{\\sigma} ^ 2}\n  \"\"\"\n  return sqrt(((c ** 2) * (A_abs_unc ** 2)) + ((d ** 2) * (B_abs_unc ** 2)))\n###############################################################################\n# XXX Create change class.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "absolute_change",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def absolute_change(old, new):\n  \"\"\"Computes the absolute change from old to new:\n  .. math::\n    absolute_change = new - old\n  \"\"\"\n  return new - old\ndef absolute_change_uncertainty(old, old_unc, new, new_unc):\n  \"\"\"Computes the uncertainty in the absolute change from old to new and returns\n  a tuple of the absolute change and the absolute change uncertainty.\n  \"\"\"",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "absolute_change_uncertainty",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def absolute_change_uncertainty(old, old_unc, new, new_unc):\n  \"\"\"Computes the uncertainty in the absolute change from old to new and returns\n  a tuple of the absolute change and the absolute change uncertainty.\n  \"\"\"\n  absolute_change     = new - old\n  absolute_change_unc = uncertainty_additive(1.0, new_unc, -1.0, old_unc)\n  return (absolute_change, absolute_change_unc)\ndef percent_change(old, new):\n  \"\"\"Computes the percent change from old to new:\n  .. math::",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "percent_change",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def percent_change(old, new):\n  \"\"\"Computes the percent change from old to new:\n  .. math::\n    percent_change = 100 \\frac{new - old}{abs(old)}\n  \"\"\"\n  return float(new - old) / abs(old)\ndef percent_change_uncertainty(old, old_unc, new, new_unc):\n  \"\"\"Computes the uncertainty in the percent change from old to new and returns\n  a tuple of the absolute change, the absolute change uncertainty, the percent\n  change and the percent change uncertainty.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "percent_change_uncertainty",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def percent_change_uncertainty(old, old_unc, new, new_unc):\n  \"\"\"Computes the uncertainty in the percent change from old to new and returns\n  a tuple of the absolute change, the absolute change uncertainty, the percent\n  change and the percent change uncertainty.\n  \"\"\"\n  # Let's break this down into a few sub-operations:\n  # \n  #   absolute_change = new - old         <- Additive propagation.\n  #   relative_change = change / abs(old) <- Multiplicative propagation.\n  #   percent_change  = 100 * y           <- Multiplicative propagation.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "find_significant_digit",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def find_significant_digit(x):\n  \"\"\"Return the significant digit of the number x. The result is the number of\n  digits after the decimal place to round to (negative numbers indicate rounding\n  before the decimal place).\"\"\"\n  if x == 0: return 0\n  return -int(floor(log10(abs(x))))\ndef round_with_int_conversion(x, ndigits = None):\n  \"\"\"Rounds `x` to `ndigits` after the the decimal place. If `ndigits` is less\n  than 1, convert the result to `int`. If `ndigits` is `None`, the significant\n  digit of `x` is used.\"\"\"",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "round_with_int_conversion",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def round_with_int_conversion(x, ndigits = None):\n  \"\"\"Rounds `x` to `ndigits` after the the decimal place. If `ndigits` is less\n  than 1, convert the result to `int`. If `ndigits` is `None`, the significant\n  digit of `x` is used.\"\"\"\n  if ndigits is None: ndigits = find_significant_digit(x)\n  x_rounded = round(x, ndigits)\n  return int(x_rounded) if ndigits < 1 else x_rounded\n###############################################################################\nclass measured_variable(object):\n  \"\"\"A meta-variable representing measured data. It is composed of three raw",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "arithmetic_mean",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def arithmetic_mean(X):\n  \"\"\"Computes the arithmetic mean of the sequence `X`.\n  Let:\n    * `n = len(X)`.\n    * `u` denote the arithmetic mean of `X`.\n  .. math::\n    u = \\frac{\\sum_{i = 0}^{n - 1} X_i}{n}\n  \"\"\"\n  return sum(X) / len(X)\ndef sample_variance(X, u = None):",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "sample_variance",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def sample_variance(X, u = None):\n  \"\"\"Computes the sample variance of the sequence `X`.\n  Let:\n    * `n = len(X)`.\n    * `u` denote the arithmetic mean of `X`.\n    * `s` denote the sample standard deviation of `X`.\n  .. math::\n    v = \\frac{\\sum_{i = 0}^{n - 1} (X_i - u)^2}{n - 1}\n  Args:\n    X (`Iterable`) : The sequence of values.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "sample_standard_deviation",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def sample_standard_deviation(X, u = None, v = None):\n  \"\"\"Computes the sample standard deviation of the sequence `X`.\n  Let:\n    * `n = len(X)`.\n    * `u` denote the arithmetic mean of `X`.\n    * `v` denote the sample variance of `X`.\n    * `s` denote the sample standard deviation of `X`.\n  .. math::\n    s &= \\sqrt{v}\n      &= \\sqrt{\\frac{\\sum_{i = 0}^{n - 1} (X_i - u)^2}{n - 1}}",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "combine_sample_size",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def combine_sample_size(As):\n  \"\"\"Computes the combined sample variance of a group of `measured_value`s.\n  Let:\n    * `g = len(As)`.\n    * `n_i = As[i].samples`.\n    * `n` denote the combined sample size of `As`.\n  .. math::\n    n = \\sum{i = 0}^{g - 1} n_i\n  \"\"\"\n  return sum(imap(unpack_tuple(lambda u_i, s_i, n_i, t_i: n_i), As))",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "combine_arithmetic_mean",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def combine_arithmetic_mean(As, n = None):\n  \"\"\"Computes the combined arithmetic mean of a group of `measured_value`s.\n  Let:\n    * `g = len(As)`.\n    * `u_i = As[i].quantity`.\n    * `n_i = As[i].samples`.\n    * `n` denote the combined sample size of `As`.\n    * `u` denote the arithmetic mean of the quantities of `As`.\n  .. math::\n    u = \\frac{\\sum{i = 0}^{g - 1} n_i u_i}{n}",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "combine_sample_variance",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def combine_sample_variance(As, n = None, u = None):\n  \"\"\"Computes the combined sample variance of a group of `measured_value`s.\n  Let:\n    * `g = len(As)`.\n    * `u_i = As[i].quantity`.\n    * `s_i = As[i].uncertainty`.\n    * `n_i = As[i].samples`.\n    * `n` denote the combined sample size of `As`.\n    * `u` denote the arithmetic mean of the quantities of `As`.\n    * `v` denote the sample variance of `X`.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "combine_sample_standard_deviation",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def combine_sample_standard_deviation(As, n = None, u = None, v = None):\n  \"\"\"Computes the combined sample standard deviation of a group of\n  `measured_value`s.\n  Let:\n    * `g = len(As)`.\n    * `u_i = As[i].quantity`.\n    * `s_i = As[i].uncertainty`.\n    * `n_i = As[i].samples`.\n    * `n` denote the combined sample size of `As`.\n    * `u` denote the arithmetic mean of the quantities of `As`.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "store_const_multiple",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def store_const_multiple(const, *destinations):\n  \"\"\"Returns an `argument_action` class that sets multiple argument\n  destinations (`destinations`) to `const`.\"\"\"\n  class store_const_multiple_action(argument_action):\n    def __init__(self, *args, **kwargs):\n      super(store_const_multiple_action, self).__init__(\n        metavar = None, nargs = 0, const = const, *args, **kwargs\n      )\n    def __call__(self, parser, namespace, values, option_string = None):\n      for destination in destinations:",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "store_true_multiple",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def store_true_multiple(*destinations):\n  \"\"\"Returns an `argument_action` class that sets multiple argument\n  destinations (`destinations`) to `True`.\"\"\"\n  return store_const_multiple(True, *destinations)\ndef store_false_multiple(*destinations):\n  \"\"\"Returns an `argument_action` class that sets multiple argument\n  destinations (`destinations`) to `False`.\"\"\"\n  return store_const_multiple(False, *destinations)\n###############################################################################\ndef process_program_arguments():",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "store_false_multiple",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def store_false_multiple(*destinations):\n  \"\"\"Returns an `argument_action` class that sets multiple argument\n  destinations (`destinations`) to `False`.\"\"\"\n  return store_const_multiple(False, *destinations)\n###############################################################################\ndef process_program_arguments():\n  ap = argument_parser(\n    description = (\n      \"Compares two sets of combined performance results and identifies \"\n      \"statistically significant changes.\"",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "process_program_arguments",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def process_program_arguments():\n  ap = argument_parser(\n    description = (\n      \"Compares two sets of combined performance results and identifies \"\n      \"statistically significant changes.\"\n    )\n  )\n  ap.add_argument(\n    \"baseline_input_file\",\n    help = (\"CSV file containing the baseline performance results. The first \"",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "filter_comments",
        "kind": 2,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "def filter_comments(f, s = \"#\"):\n  \"\"\"Return an iterator to the file `f` which filters out all lines beginning\n  with `s`.\"\"\"\n  return filter(lambda line: not line.startswith(s), f)\n###############################################################################\nclass io_manager(object):\n  \"\"\"Manages I/O operations and represents the input data as an `Iterable`\n  sequence of `dict`s.\n  It is `Iterable` and an `Iterator`. It can be used with `with`.\n  Attributes:",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "args = process_program_arguments()\nif len(args.dependent_variables) == 0:\n  args.dependent_variables = [\n    \"STL Average Walltime,STL Walltime Uncertainty,STL Trials\",\n    \"STL Average Throughput,STL Throughput Uncertainty,STL Trials\",\n    \"Thrust Average Walltime,Thrust Walltime Uncertainty,Thrust Trials\",\n    \"Thrust Average Throughput,Thrust Throughput Uncertainty,Thrust Trials\"\n  ]\n# Parse dependent variable options.\ndependent_variables = []",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "dependent_variables",
        "kind": 5,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "dependent_variables = []\nparse_dependent_variable = dependent_variable_parser()\n#if args.dependent_variables is not None:\nfor var in args.dependent_variables:\n  dependent_variables.append(parse_dependent_variable(var))\n# Read input files and open the output file.\nwith io_manager(args.baseline_input_file, \n                args.observed_input_file,\n                args.output_file,\n                args.preserve_whitespace) as iom:",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "parse_dependent_variable",
        "kind": 5,
        "importPath": "thrust.internal.benchmark.compare_benchmark_results",
        "description": "thrust.internal.benchmark.compare_benchmark_results",
        "peekOfCode": "parse_dependent_variable = dependent_variable_parser()\n#if args.dependent_variables is not None:\nfor var in args.dependent_variables:\n  dependent_variables.append(parse_dependent_variable(var))\n# Read input files and open the output file.\nwith io_manager(args.baseline_input_file, \n                args.observed_input_file,\n                args.output_file,\n                args.preserve_whitespace) as iom:\n  # Create record aggregators.",
        "detail": "thrust.internal.benchmark.compare_benchmark_results",
        "documentation": {}
    },
    {
        "label": "find_headers",
        "kind": 2,
        "importPath": "thrust.internal.build.warningstester_create_uber_header",
        "description": "thrust.internal.build.warningstester_create_uber_header",
        "peekOfCode": "def find_headers(base_dir, rel_dir, exclude = ['\\B']):\n    '''\n    Recursively find all *.h files inside base_dir/rel_dir,\n    except any that match the exclude regexp list\n    '''\n    assert(type(exclude) == list)\n    full_dir = base_dir + '/' + rel_dir\n    result = []\n    for f in os.listdir(full_dir):\n        rel_file = rel_dir + '/' + f",
        "detail": "thrust.internal.build.warningstester_create_uber_header",
        "documentation": {}
    },
    {
        "label": "thrustdir",
        "kind": 5,
        "importPath": "thrust.internal.build.warningstester_create_uber_header",
        "description": "thrust.internal.build.warningstester_create_uber_header",
        "peekOfCode": "thrustdir = sys.argv[1]\ndef find_headers(base_dir, rel_dir, exclude = ['\\B']):\n    '''\n    Recursively find all *.h files inside base_dir/rel_dir,\n    except any that match the exclude regexp list\n    '''\n    assert(type(exclude) == list)\n    full_dir = base_dir + '/' + rel_dir\n    result = []\n    for f in os.listdir(full_dir):",
        "detail": "thrust.internal.build.warningstester_create_uber_header",
        "documentation": {}
    },
    {
        "label": "exclude_re",
        "kind": 5,
        "importPath": "thrust.internal.build.warningstester_create_uber_header",
        "description": "thrust.internal.build.warningstester_create_uber_header",
        "peekOfCode": "exclude_re = ['.*/detail$',\n              'thrust/iterator',\n              'thrust/random',\n              'thrust/system/tbb']\nheaders = find_headers(thrustdir, 'thrust', exclude_re)\nif len(headers) == 0:\n    print('#error no include files found\\n')\nprint('#define THRUST_CPP11_REQUIRED_NO_ERROR')\nprint('#define THRUST_CPP14_REQUIRED_NO_ERROR')\nprint('#define THRUST_MODERN_GCC_REQUIRED_NO_ERROR')",
        "detail": "thrust.internal.build.warningstester_create_uber_header",
        "documentation": {}
    },
    {
        "label": "headers",
        "kind": 5,
        "importPath": "thrust.internal.build.warningstester_create_uber_header",
        "description": "thrust.internal.build.warningstester_create_uber_header",
        "peekOfCode": "headers = find_headers(thrustdir, 'thrust', exclude_re)\nif len(headers) == 0:\n    print('#error no include files found\\n')\nprint('#define THRUST_CPP11_REQUIRED_NO_ERROR')\nprint('#define THRUST_CPP14_REQUIRED_NO_ERROR')\nprint('#define THRUST_MODERN_GCC_REQUIRED_NO_ERROR')\nfor h in headers:\n    print('#include <' + h + '>')\nexit()",
        "detail": "thrust.internal.build.warningstester_create_uber_header",
        "documentation": {}
    },
    {
        "label": "printable_cmd",
        "kind": 2,
        "importPath": "thrust.internal.scripts.eris_perf",
        "description": "thrust.internal.scripts.eris_perf",
        "peekOfCode": "def printable_cmd(c):\n  \"\"\"Converts a `list` of `str`s representing a shell command to a printable \n  `str`.\"\"\"\n  return \" \".join(map(lambda e: '\"' + str(e) + '\"', c))\n###############################################################################\ndef print_file(p):\n  \"\"\"Open the path `p` and print its contents to `stdout`.\"\"\"\n  print \"********************************************************************************\"\n  with open(p) as f:\n    for line in f:",
        "detail": "thrust.internal.scripts.eris_perf",
        "documentation": {}
    },
    {
        "label": "print_file",
        "kind": 2,
        "importPath": "thrust.internal.scripts.eris_perf",
        "description": "thrust.internal.scripts.eris_perf",
        "peekOfCode": "def print_file(p):\n  \"\"\"Open the path `p` and print its contents to `stdout`.\"\"\"\n  print \"********************************************************************************\"\n  with open(p) as f:\n    for line in f:\n      print line,\n  print \"********************************************************************************\"\n###############################################################################\nap = argument_parser(\n  description = (",
        "detail": "thrust.internal.scripts.eris_perf",
        "documentation": {}
    },
    {
        "label": "ap",
        "kind": 5,
        "importPath": "thrust.internal.scripts.eris_perf",
        "description": "thrust.internal.scripts.eris_perf",
        "peekOfCode": "ap = argument_parser(\n  description = (\n    \"CUDA Eris driver script: runs a benchmark suite multiple times, combines \"\n    \"the results, and outputs them in the CUDA Eris performance result format.\"\n  )\n)\nap.add_argument(\n  \"-b\", \"--benchmark\", \n  help = (\"The location of the benchmark suite executable to run.\"),\n  type = str,",
        "detail": "thrust.internal.scripts.eris_perf",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "thrust.internal.scripts.eris_perf",
        "description": "thrust.internal.scripts.eris_perf",
        "peekOfCode": "args = ap.parse_args()\nif args.runs <= 0:\n  print \"ERROR: `--runs` must be greater than `0`.\"\n  ap.print_help()\n  exit(1)\nBENCHMARK_EXE             = args.benchmark\nBENCHMARK_NAME            = basename(BENCHMARK_EXE)\nPOSTPROCESS_EXE           = args.postprocess\nOUTPUT_FILE_NAME          = lambda i: BENCHMARK_NAME + \"_\" + str(i) + \".csv\"\nCOMBINED_OUTPUT_FILE_NAME = BENCHMARK_NAME + \"_combined.csv\"",
        "detail": "thrust.internal.scripts.eris_perf",
        "documentation": {}
    },
    {
        "label": "COMBINED_OUTPUT_FILE_NAME",
        "kind": 5,
        "importPath": "thrust.internal.scripts.eris_perf",
        "description": "thrust.internal.scripts.eris_perf",
        "peekOfCode": "COMBINED_OUTPUT_FILE_NAME = BENCHMARK_NAME + \"_combined.csv\"\n###############################################################################\nprint '&&&& RUNNING {0}'.format(BENCHMARK_NAME)\nprint '#### RUNS {0}'.format(args.runs)\n###############################################################################\nprint '#### CMD {0}'.format(BENCHMARK_EXE)\nfor i in xrange(args.runs):\n  with open(OUTPUT_FILE_NAME(i), \"w\") as output_file:\n    print '#### RUN {0} OUTPUT -> {1}'.format(i, OUTPUT_FILE_NAME(i))\n    p = None",
        "detail": "thrust.internal.scripts.eris_perf",
        "documentation": {}
    },
    {
        "label": "post_cmd",
        "kind": 5,
        "importPath": "thrust.internal.scripts.eris_perf",
        "description": "thrust.internal.scripts.eris_perf",
        "peekOfCode": "post_cmd = [POSTPROCESS_EXE]\n# Add dependent variable options.\npost_cmd += [\"-dSTL Average Walltime,STL Walltime Uncertainty,STL Trials\"]\npost_cmd += [\"-dSTL Average Throughput,STL Throughput Uncertainty,STL Trials\"]\npost_cmd += [\"-dThrust Average Walltime,Thrust Walltime Uncertainty,Thrust Trials\"]\npost_cmd += [\"-dThrust Average Throughput,Thrust Throughput Uncertainty,Thrust Trials\"]\npost_cmd += [OUTPUT_FILE_NAME(i) for i in range(args.runs)] \nprint '#### CMD {0}'.format(printable_cmd(post_cmd))\nwith open(COMBINED_OUTPUT_FILE_NAME, \"w\") as output_file:\n  p = None",
        "detail": "thrust.internal.scripts.eris_perf",
        "documentation": {}
    },
    {
        "label": "encase",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def encase(pre, post, strip=False):\n    \"\"\"Return a function that prepends pre and postpends post\"\"\"\n    def f(txt):\n        if strip:\n            return pre + txt.strip() + post\n        else:\n            return pre + txt + post\n    return f\ndef constant(text):\n    def f(txt):",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "constant",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def constant(text):\n    def f(txt):\n        return text\n    return f\ndef encase_with_rules(pre, post, rules, strip=False):\n    def f(txt):\n        if strip:\n            return pre + apply_rules(txt, rules).strip() + post\n        else:\n            return pre + apply_rules(txt, rules) + post",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "encase_with_rules",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def encase_with_rules(pre, post, rules, strip=False):\n    def f(txt):\n        if strip:\n            return pre + apply_rules(txt, rules).strip() + post\n        else:\n            return pre + apply_rules(txt, rules) + post\n    return f\ndef encase_escape_underscore(pre, post):\n    def f(txt):\n        txt = sub(r'_', r'\\_', txt)",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "encase_escape_underscore",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def encase_escape_underscore(pre, post):\n    def f(txt):\n        txt = sub(r'_', r'\\_', txt)\n        return pre + txt + post\n    return f\ndef sub(pat, repl, txt):\n    \"\"\"Substitute in repl for pat in txt, txt can be multiple lines\"\"\"\n    return re.compile(pat, re.MULTILINE).sub(repl, txt)\ndef process_list(rules):\n    def f(txt):",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "sub",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def sub(pat, repl, txt):\n    \"\"\"Substitute in repl for pat in txt, txt can be multiple lines\"\"\"\n    return re.compile(pat, re.MULTILINE).sub(repl, txt)\ndef process_list(rules):\n    def f(txt):\n        txt = '  *' + txt # was removed to match begin tag of list\n        res = '\\\\begin{itemize}\\n'\n        for ln in txt.split('\\n'):\n            # Convert \"  *\" to \"\\item \"\n            ln = sub(r'^  \\*', r'\\\\item ', ln)",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "process_list",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def process_list(rules):\n    def f(txt):\n        txt = '  *' + txt # was removed to match begin tag of list\n        res = '\\\\begin{itemize}\\n'\n        for ln in txt.split('\\n'):\n            # Convert \"  *\" to \"\\item \"\n            ln = sub(r'^  \\*', r'\\\\item ', ln)\n            res += apply_rules(ln, rules) + '\\n'\n        res += '\\\\end{itemize}\\n'\n        return res",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "process_link",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def process_link(rules):\n    def f(txt):\n        lst = txt.split(' ')\n        lnk = lst[0]\n        desc = apply_rules(' '.join(lst[1:]), rules)\n        if lnk[:7] == 'http://':\n            desc = apply_rules(' '.join(lst[1:]), rules)\n            return r'\\href{' + lnk + r'}{' + desc + r'}'\n        if len(lst) > 1:\n            return r'\\href{}{' + desc + r'}'",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "match_rules",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def match_rules(txt, rules):\n    \"\"\"Find rule that first matches in txt\"\"\"\n    # Find first begin tag\n    first_begin_loc = 10e100\n    matching_rule = None\n    for rule in rules:\n        begin_tag, end_tag, func = rule\n        loc = txt.find(begin_tag)\n        if loc > -1 and loc < first_begin_loc:\n            first_begin_loc = loc",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "apply_rules",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def apply_rules(txt, rules):\n    \"\"\"Apply set of rules to give txt, return transformed version of txt\"\"\"\n    matching_rule, first_begin_loc = match_rules(txt, rules)\n    if matching_rule is None:\n        return txt\n    begin_tag, end_tag, func = matching_rule\n    end_loc = txt.find(end_tag, first_begin_loc + 1)\n    if end_loc == -1:\n        sys.exit('Could not find end tag {0} after position {1}'.format(end_tag, first_begin_loc + 1))\n    inner_txt = txt[first_begin_loc + len(begin_tag) : end_loc]",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "split_sections",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def split_sections(contents):\n    \"\"\"Given one string of all file contents, return list of sections\n    Return format is list of pairs, each pair has section title\n    and list of lines.  Result is ordered as the original input.\n    \"\"\"\n    res = []\n    cur_section = ''\n    section = []\n    for ln in contents.split('\\n'):\n        if len(ln) > 0 and ln[0] == '=':",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "filter_sections",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def filter_sections(splitinput, removelst):\n    \"\"\"Take split input and remove sections in removelst\"\"\"\n    res = []\n    for sectname, sectcontents in splitinput:\n        if sectname in removelst:\n            pass\n        else:\n            res.extend(sectcontents)\n    # convert to single string for output\n    return '\\n'.join(res)",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "def main():\n    infile = codecs.open(sys.argv[1], encoding='utf-8')\n    outfile = codecs.open(sys.argv[2], mode='w', encoding='utf-8')\n    contents = infile.read()\n    # Remove first three lines\n    contents = '\\n'.join(contents.split('\\n')[3:])\n    # Split sections and filter out some of them\n    sections = split_sections(contents)\n    contents = filter_sections(sections, ['Introduction', 'Prerequisites', 'Simple Example'])\n    # Convert to latex format",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "link_rules",
        "kind": 5,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "link_rules = [\n    ['_', '', constant(r'\\_')],\n]\nsection_rules = [\n    ['`', '`', encase_escape_underscore(r'\\texttt{', r'}')],\n]\nitem_rules = [\n    ['`', '`', encase(r'\\verb|', r'|')],\n    ['[', ']', process_link(link_rules)],\n]",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "section_rules",
        "kind": 5,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "section_rules = [\n    ['`', '`', encase_escape_underscore(r'\\texttt{', r'}')],\n]\nitem_rules = [\n    ['`', '`', encase(r'\\verb|', r'|')],\n    ['[', ']', process_link(link_rules)],\n]\n# Main rules for Latex formatting\nrules = [\n    ['{{{', '}}}', encase(r'\\begin{lstlisting}[language=c++]', r'\\end{lstlisting}')],",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "item_rules",
        "kind": 5,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "item_rules = [\n    ['`', '`', encase(r'\\verb|', r'|')],\n    ['[', ']', process_link(link_rules)],\n]\n# Main rules for Latex formatting\nrules = [\n    ['{{{', '}}}', encase(r'\\begin{lstlisting}[language=c++]', r'\\end{lstlisting}')],\n    ['[', ']', process_link(link_rules)],\n    ['  *', '\\n\\n', process_list(item_rules)],\n    ['\"', '\"', encase(\"``\", \"''\")],",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "rules",
        "kind": 5,
        "importPath": "thrust.internal.scripts.wiki2tex",
        "description": "thrust.internal.scripts.wiki2tex",
        "peekOfCode": "rules = [\n    ['{{{', '}}}', encase(r'\\begin{lstlisting}[language=c++]', r'\\end{lstlisting}')],\n    ['[', ']', process_link(link_rules)],\n    ['  *', '\\n\\n', process_list(item_rules)],\n    ['\"', '\"', encase(\"``\", \"''\")],\n    ['`', '`', encase(r'\\verb|', r'|')],\n    ['*', '*', encase(r'\\emph{', r'}')],\n    ['_', '_', encase(r'\\emph{', r'}')],\n    ['==', '==', encase_with_rules(r'\\section{', r'}', section_rules, True)],\n    ['=', '=', encase_with_rules(r'\\chapter{', r'}', section_rules, True)],",
        "detail": "thrust.internal.scripts.wiki2tex",
        "documentation": {}
    },
    {
        "label": "Glob",
        "kind": 2,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "def Glob(pattern, directory,exclude='\\B'):\n    src = glob.glob(os.path.join(directory,pattern))\n    p = re.compile(exclude)\n    src = [s for s in src if not p.match(s)]\n    return src\ndef generate_test_mk(mk_path, test_path, group, TEST_DIR):\n    print('Generating makefiles in \"'+mk_path+'\" for tests in \"'+test_path+'\"')\n    src_cu  = Glob(\"*.cu\",  test_path, \".*testframework.cu$\")\n    src_cxx = Glob(\"*.cpp\", test_path)\n    src_cu.sort();",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "generate_test_mk",
        "kind": 2,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "def generate_test_mk(mk_path, test_path, group, TEST_DIR):\n    print('Generating makefiles in \"'+mk_path+'\" for tests in \"'+test_path+'\"')\n    src_cu  = Glob(\"*.cu\",  test_path, \".*testframework.cu$\")\n    src_cxx = Glob(\"*.cpp\", test_path)\n    src_cu.sort();\n    src_cxx.sort();\n    src_all = src_cu + src_cxx;\n    tests_all = []\n    dependencies_all = []\n    for s in src_all:",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "generate_example_mk",
        "kind": 2,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "def generate_example_mk(mk_path, example_path, group, EXAMPLE_DIR):\n    print('Generating makefiles in \"'+mk_path+'\" for examples in \"'+example_path+'\"')\n    src_cu  = Glob(\"*.cu\",  example_path)\n    src_cxx = Glob(\"*.cpp\", example_path)\n    src_cu.sort();\n    src_cxx.sort();\n    src_all = src_cu + src_cxx;\n    examples_all = []\n    for s in src_all:\n        fn = os.path.splitext(os.path.basename(s));",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "relpath",
        "kind": 2,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "def relpath(path, start):\n    \"\"\"Return a relative version of a path\"\"\"\n    import posixpath\n    if not path:\n        raise ValueError(\"no path specified\")\n    start_list = posixpath.abspath(start).split(posixpath.sep)\n    path_list = posixpath.abspath(path).split(posixpath.sep)\n    # Work out how much of the filepath is shared by start and path.\n    i = len(posixpath.commonprefix([start_list, path_list]))\n    rel_list = [posixpath.pardir] * (len(start_list)-i) + path_list[i:]",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "test_template",
        "kind": 5,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "test_template = \"\"\"\nTEST_SRC   := %(TEST_SRC)s\nTEST_NAME  := %(TEST_NAME)s\ninclude $(ROOTDIR)/thrust/internal/build/generic_test.mk\n\"\"\"\nexample_template = \"\"\"\nEXAMPLE_SRC   := %(EXAMPLE_SRC)s\nEXAMPLE_NAME  := %(EXAMPLE_NAME)s\ninclude $(ROOTDIR)/thrust/internal/build/generic_example.mk\n\"\"\"",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "example_template",
        "kind": 5,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "example_template = \"\"\"\nEXAMPLE_SRC   := %(EXAMPLE_SRC)s\nEXAMPLE_NAME  := %(EXAMPLE_NAME)s\ninclude $(ROOTDIR)/thrust/internal/build/generic_example.mk\n\"\"\"\ndef Glob(pattern, directory,exclude='\\B'):\n    src = glob.glob(os.path.join(directory,pattern))\n    p = re.compile(exclude)\n    src = [s for s in src if not p.match(s)]\n    return src",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "f = open(os.path.join(mk_path,\"testing.mk\"),'w')\nf.write(testing_mk)\nf.close()\ndependencies_mk = \"\"\nfor d in dependencies_all:\n    dependencies_mk += d + \"\\n\"\nf = open(os.path.join(mk_path,\"dependencies.mk\"),'w')\nf.write(dependencies_mk)\nf.close()\nexamples_mk = \"\"",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "dependencies_mk",
        "kind": 5,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "dependencies_mk = \"\"\nfor d in dependencies_all:\n    dependencies_mk += d + \"\\n\"\nf = open(os.path.join(mk_path,\"dependencies.mk\"),'w')\nf.write(dependencies_mk)\nf.close()\nexamples_mk = \"\"\nexamples_all  = generate_example_mk(mk_path, \"examples/\", \"example\", REL_DIR)\nexamples_cuda = generate_example_mk(mk_path, \"examples/cuda/\", \"example.cuda\", REL_DIR)\nexamples_all.extend(examples_cuda)",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "f = open(os.path.join(mk_path,\"dependencies.mk\"),'w')\nf.write(dependencies_mk)\nf.close()\nexamples_mk = \"\"\nexamples_all  = generate_example_mk(mk_path, \"examples/\", \"example\", REL_DIR)\nexamples_cuda = generate_example_mk(mk_path, \"examples/cuda/\", \"example.cuda\", REL_DIR)\nexamples_all.extend(examples_cuda)\nfor e in examples_all:\n    examples_mk += \"PROJECTS += \"+e+\"\\n\"\nf = open(os.path.join(mk_path,\"examples.mk\"),'w')",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "examples_mk",
        "kind": 5,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "examples_mk = \"\"\nexamples_all  = generate_example_mk(mk_path, \"examples/\", \"example\", REL_DIR)\nexamples_cuda = generate_example_mk(mk_path, \"examples/cuda/\", \"example.cuda\", REL_DIR)\nexamples_all.extend(examples_cuda)\nfor e in examples_all:\n    examples_mk += \"PROJECTS += \"+e+\"\\n\"\nf = open(os.path.join(mk_path,\"examples.mk\"),'w')\nf.write(examples_mk)\nf.close()",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "examples_cuda",
        "kind": 5,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "examples_cuda = generate_example_mk(mk_path, \"examples/cuda/\", \"example.cuda\", REL_DIR)\nexamples_all.extend(examples_cuda)\nfor e in examples_all:\n    examples_mk += \"PROJECTS += \"+e+\"\\n\"\nf = open(os.path.join(mk_path,\"examples.mk\"),'w')\nf.write(examples_mk)\nf.close()",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "thrust.generate_mk",
        "description": "thrust.generate_mk",
        "peekOfCode": "f = open(os.path.join(mk_path,\"examples.mk\"),'w')\nf.write(examples_mk)\nf.close()",
        "detail": "thrust.generate_mk",
        "documentation": {}
    },
    {
        "label": "CMakeExtension",
        "kind": 6,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "class CMakeExtension(Extension):\n    def __init__(self, name, sourcedir, build_with_cuda):\n        Extension.__init__(self, name, sources=[])\n        self.sourcedir = os.path.abspath(sourcedir)\n        self.build_with_cuda = build_with_cuda\nclass Build(build_ext):\n    def run(self):\n        try:\n            out = subprocess.check_output(['cmake', '--version'])\n        except OSError:",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "Build",
        "kind": 6,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "class Build(build_ext):\n    def run(self):\n        try:\n            out = subprocess.check_output(['cmake', '--version'])\n        except OSError:\n            raise RuntimeError(\"CMake must be installed to build the following extensions: \" +\n                               \", \".join(e.name for e in self.extensions))\n        super().run()\n    def build_extension(self, ext):\n        if isinstance(ext, CMakeExtension):",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "torch_spec",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "torch_spec = importlib.util.find_spec(\"torch\")\ntf_spec = importlib.util.find_spec(\"tensorflow\")\npackages = []\nbuild_with_cuda = False\nif torch_spec is not None:\n    packages.append('pydiffvg')\n    import torch\n    if torch.cuda.is_available():\n        build_with_cuda = True\nif tf_spec is not None and sys.platform != 'win32':",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "tf_spec",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "tf_spec = importlib.util.find_spec(\"tensorflow\")\npackages = []\nbuild_with_cuda = False\nif torch_spec is not None:\n    packages.append('pydiffvg')\n    import torch\n    if torch.cuda.is_available():\n        build_with_cuda = True\nif tf_spec is not None and sys.platform != 'win32':\n    packages.append('pydiffvg_tensorflow')",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "packages",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "packages = []\nbuild_with_cuda = False\nif torch_spec is not None:\n    packages.append('pydiffvg')\n    import torch\n    if torch.cuda.is_available():\n        build_with_cuda = True\nif tf_spec is not None and sys.platform != 'win32':\n    packages.append('pydiffvg_tensorflow')\n    if not build_with_cuda:",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "build_with_cuda",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "build_with_cuda = False\nif torch_spec is not None:\n    packages.append('pydiffvg')\n    import torch\n    if torch.cuda.is_available():\n        build_with_cuda = True\nif tf_spec is not None and sys.platform != 'win32':\n    packages.append('pydiffvg_tensorflow')\n    if not build_with_cuda:\n        import tensorflow as tf",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "setup(name",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "setup(name = 'diffvg',\n      version = '0.0.1',\n      install_requires = [\"svgpathtools\"],\n      description = 'Differentiable Vector Graphics',\n      ext_modules = [CMakeExtension('diffvg', '', build_with_cuda)],\n      cmdclass = dict(build_ext=Build, install=install),\n      packages = packages,\n      zip_safe = False)",
        "detail": "setup",
        "documentation": {}
    }
]